[
	{
		"name": "MSR_2_3",
		"code": "MSR_2_3",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "2.3",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}包含未使用的数据类型的定义。",
			"code": "MSR_2_3",
			"override": "T",
			"master_id": "2001",
			"name": "MSR_2_3",
			"name_cn": "MSR_2_3",
			"severity": "H",
			"compliance": "A",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "A project should not include undefined data types",
			"desc_cn": "不应该包含未使用的数据类型的定义",
			"abstract": "A project should not include undefined data types",
			"explanation": "An undefined data type will cause a waste of resources. When reviewing the code, it will also be difficult to determine whether the data type is not used due to an error in the programming process or if it is just extra code. ",
			"abstract_cn": "不应该包含未使用的数据类型的定义",
			"explanation_cn": "未定义的数据类型，不单止会导致会浪费资源，还会在审查该代码时难以确定是由于编程过程中的错误导致没有使用该数据类型，还是其只是代码的多余部分。",
			"example_good": "///c:\n#include <stdio.h>\n\ntypedef int used; // type is declared here\n\nint main()\n{\n    used a = 1; // type is used here\n    printf(\"%d\",a);\n    return 0;\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\ntypedef int used; // type is declared but not used\n\nint main()\n{\n    printf(\"finished\");\n    return 0;\n}",
			"details_en": "#### Abstract\nA project should not include undefined data types\n\n#### Explanation\nAn undefined data type will cause a waste of resources. When reviewing the code, it will also be difficult to determine whether the data type is not used due to an error in the programming process or if it is just extra code. ",
			"details_cn": "#### 概要\n不应该包含未使用的数据类型的定义\n\n#### 解释\n未定义的数据类型，不单止会导致会浪费资源，还会在审查该代码时难以确定是由于编程过程中的错误导致没有使用该数据类型，还是其只是代码的多余部分。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\ntypedef int used; // type is declared here\n\nint main()\n{\n    used a = 1; // type is used here\n    printf(\"%d\",a);\n    return 0;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\ntypedef int used; // type is declared but not used\n\nint main()\n{\n    printf(\"finished\");\n    return 0;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629110330360"
	},
	{
		"name": "Unused label in function not allowed",
		"code": "MSR_2_6",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "2.6",
			"misra_cpp": "0-1-5",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, unused tags are declared in ${so.func}.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}使用了未使用的标签。",
			"code": "MSR_2_6",
			"override": "T",
			"master_id": "2002",
			"name": "Unused label in function not allowed",
			"name_cn": "函数中不允许使用未使用的标签",
			"severity": "H",
			"compliance": "A",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "Unused tags cannot be declared in the function",
			"desc_cn": "函数中不能声明未使用的标签",
			"abstract": "Unused tags cannot be declared in the function",
			"explanation": "The reviewer of the code cannot judge whether the unused tag is redundant or is not used due to negligence, so the unused label cannot be declared. ",
			"abstract_cn": "函数中不能声明未使用的标签",
			"explanation_cn": "代码的审查者无法判断未使用的标签是多余的还是因疏漏而未使用，因此不能声明未使用的标签。",
			"example_good": "///c:\n#include <stdio.h>\n\nint func( void );\n\nint func( void )\n{\n    int i = 5;\n    goto lab1; // label used\n    if (i != 5) i = 5;\nlab1: // label declared\n    return i;\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nint func( void );\n\nint func( void )\n{\n    int i = 5;\n    if (i != 5) i = 5;\nlab1: // unused label declared\n    return i;\n}",
			"details_en": "#### Abstract\nUnused tags cannot be declared in the function\n\n#### Explanation\nThe reviewer of the code cannot judge whether the unused tag is redundant or is not used due to negligence, so the unused label cannot be declared. ",
			"details_cn": "#### 概要\n函数中不能声明未使用的标签\n\n#### 解释\n代码的审查者无法判断未使用的标签是多余的还是因疏漏而未使用，因此不能声明未使用的标签。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nint func( void );\n\nint func( void )\n{\n    int i = 5;\n    goto lab1; // label used\n    if (i != 5) i = 5;\nlab1: // label declared\n    return i;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nint func( void );\n\nint func( void )\n{\n    int i = 5;\n    if (i != 5) i = 5;\nlab1: // unused label declared\n    return i;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629163530011"
	},
	{
		"name": "All declared parameters must be used",
		"code": "MSR_2_7",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "M0-1-11",
			"misra_c": "2.7",
			"misra_cpp": "0-1-11",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, unused parameters appear in ${so.func}.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中出现未使用的参数。",
			"code": "MSR_2_7",
			"override": "T",
			"master_id": "2003",
			"name": "All declared parameters must be used",
			"name_cn": "必须使用所有声明过的参数",
			"severity": "H",
			"compliance": "A",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "Unused parameters should not appear in the function",
			"desc_cn": "函数中不应出现未使用的参数",
			"abstract": "Unused parameters should not appear in the function",
			"explanation": "The function should use all its parameters. If the function does not use all its parameters, the implementation will not match the declaration of the function. ",
			"abstract_cn": "函数中不应出现未使用的参数",
			"explanation_cn": "函数应该使用其所有的参数。若函数未使用其所有的参数则其功能的实现很可能与在设计该函数时所希望达到的目的不相匹配。",
			"example_good": "///c:\n#include <stdio.h>\n\nint Addtion(int a,int b,int c);\n\nint main()\n{\n    printf(\"%d\",Addtion(1,2,3));\n    return 0;\n}\nint Addtion(int a,int b,int c)\n{\n    return a+b+c; // every parameter is used\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nint Addtion(int a,int b,int c);\n\nint main()\n{\n    printf(\"%d\",Addtion(1,2,3));\n    return 0;\n}\n // three parameters are defined\nint Addtion(int a,int b,int c)\n{\n    return a+b; // only two of them are used\n}",
			"details_en": "#### Abstract\nUnused parameters should not appear in the function\n\n#### Explanation\nThe function should use all its parameters. If the function does not use all its parameters, the implementation will not match the declaration of the function. ",
			"details_cn": "#### 概要\n函数中不应出现未使用的参数\n\n#### 解释\n函数应该使用其所有的参数。若函数未使用其所有的参数则其功能的实现很可能与在设计该函数时所希望达到的目的不相匹配。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nint Addtion(int a,int b,int c);\n\nint main()\n{\n    printf(\"%d\",Addtion(1,2,3));\n    return 0;\n}\nint Addtion(int a,int b,int c)\n{\n    return a+b+c; // every parameter is used\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nint Addtion(int a,int b,int c);\n\nint main()\n{\n    printf(\"%d\",Addtion(1,2,3));\n    return 0;\n}\n // three parameters are defined\nint Addtion(int a,int b,int c)\n{\n    return a+b; // only two of them are used\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629163682547"
	},
	{
		"name": "All external identifiers must be unique up to 31 characters",
		"code": "MSR_5_1",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "5.1",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, external identifiers are not unique.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中出现不唯一的外部标识符。",
			"code": "MSR_5_1",
			"override": "T",
			"master_id": "2004",
			"name": "All external identifiers must be unique up to 31 characters",
			"name_cn": "所有外部标识符必须是唯一的，最多31个字符",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "The external identifier must be distinguishable",
			"desc_cn": "外部标识符要求可区别",
			"abstract": "The external identifier must be distinguishable",
			"explanation": "In the C99 standard, external identifiers should be distinguished by at least the first 31 characters. The external identifiers must be distinct with respect to the first 31 characters, so they are deemed unique by the compiler. ",
			"abstract_cn": "外部标识符要求可区别",
			"explanation_cn": "在C99标准中，外部标识符应至少满足前31个字符有区别，以确保所有外部标识符可通过前31个字符得以区分。",
			"example_good": "///c:\n#include <stdio.h>\n\nint main()\n{\n    // the first 31 characters are distinct\n    int a_non_compliant_example_a = 1;\n    int a_non_compliant_example_b = 2; \n    int a;\n    a = a_non_compliant_example_a + a_non_compliant_example_b;\n    printf(\"%d\\n\",a);\n    return 0;\n} ",
			"example_bad": "///c:\n#include <stdio.h>\n\nint main()\n{\n    // the first 31 characters are not distinct\n    int this_is_a_non_compliant_example_a = 1;\n    int this_is_a_non_compliant_example_b = 2; \n    int a;\n    a = this_is_a_non_compliant_example_a + this_is_a_non_compliant_example_b;\n    printf(\"%d\\n\",a);\n    return 0;\n} ",
			"details_en": "#### Abstract\nThe external identifier must be distinguishable\n\n#### Explanation\nIn the C99 standard, external identifiers should be distinguished by at least the first 31 characters. The external identifiers must be distinct with respect to the first 31 characters, so they are deemed unique by the compiler. ",
			"details_cn": "#### 概要\n外部标识符要求可区别\n\n#### 解释\n在C99标准中，外部标识符应至少满足前31个字符有区别，以确保所有外部标识符可通过前31个字符得以区分。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nint main()\n{\n    // the first 31 characters are distinct\n    int a_non_compliant_example_a = 1;\n    int a_non_compliant_example_b = 2; \n    int a;\n    a = a_non_compliant_example_a + a_non_compliant_example_b;\n    printf(\"%d\\n\",a);\n    return 0;\n} "
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nint main()\n{\n    // the first 31 characters are not distinct\n    int this_is_a_non_compliant_example_a = 1;\n    int this_is_a_non_compliant_example_b = 2; \n    int a;\n    a = this_is_a_non_compliant_example_a + this_is_a_non_compliant_example_b;\n    printf(\"%d\\n\",a);\n    return 0;\n} "
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629163762989"
	},
	{
		"name": "Identifiers of same scope and name space must be unique",
		"code": "MSR_5_2",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "A2-11-1",
			"misra_c": "5.2",
			"misra_cpp": "2-10-2",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, identifiers are not distinguishable.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中出现不可被区分的标识符。",
			"code": "MSR_5_2",
			"override": "T",
			"master_id": "2005",
			"name": "Identifiers of same scope and name space must be unique",
			"name_cn": "相同范围和名称空间的标识符必须是唯一的",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "Identifiers declared in the same scope and name space should be distinguishable",
			"desc_cn": "在同一作用域和命名空间中被声明的标识符应该可以被区分",
			"abstract": "Identifiers declared in the same scope and name space should be distinguishable",
			"explanation": "In the same scope, the first 31 characters of different identifiers should not be exactly the same to ensure they are distinguishable.",
			"abstract_cn": "在同一作用域和命名空间中被声明的标识符应该可以被区分",
			"explanation_cn": "在同一作用域内应该满足不同标识符的前31个字符不完全相同以进行区别。",
			"example_good": "///c:\n#include <stdio.h>\n\n// this example have two identifiers, first 31 characters are the same\nextern int this_is_a_non_compliant_example_a = 1; // first identifier, global scope\n\nint main()\n{\n    int a;\n    int this_is_a_non_compliant_example_b = 2; // two identifiers are defined in local scope\n    a = 1 + this_is_a_non_compliant_example_b;\n    printf (\"%d\\n\",a);\n    return 0;\n} ",
			"example_bad": "///c:\n#include <stdio.h>\n\n// this example have two identifiers, first 31 characters are the same\nextern int a_non_compliant_example_a = 1;\nextern int a_non_compliant_example_b = 2; // two indistinct identifiers are defined in the same scope\n\nint main()\n{\n    int a;\n    a = 1 + a_non_compliant_example_b;\n    printf(\"%d\\n\",a);\n    return 0;\n} ",
			"details_en": "#### Abstract\nIdentifiers declared in the same scope and name space should be distinguishable\n\n#### Explanation\nIn the same scope, the first 31 characters of different identifiers should not be exactly the same to ensure they are distinguishable.",
			"details_cn": "#### 概要\n在同一作用域和命名空间中被声明的标识符应该可以被区分\n\n#### 解释\n在同一作用域内应该满足不同标识符的前31个字符不完全相同以进行区别。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\n// this example have two identifiers, first 31 characters are the same\nextern int this_is_a_non_compliant_example_a = 1; // first identifier, global scope\n\nint main()\n{\n    int a;\n    int this_is_a_non_compliant_example_b = 2; // two identifiers are defined in local scope\n    a = 1 + this_is_a_non_compliant_example_b;\n    printf (\"%d\\n\",a);\n    return 0;\n} "
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\n// this example have two identifiers, first 31 characters are the same\nextern int a_non_compliant_example_a = 1;\nextern int a_non_compliant_example_b = 2; // two indistinct identifiers are defined in the same scope\n\nint main()\n{\n    int a;\n    a = 1 + a_non_compliant_example_b;\n    printf(\"%d\\n\",a);\n    return 0;\n} "
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629163825507"
	},
	{
		"name": "Identifiers in inner and outer scope must be distinct",
		"code": "MSR_5_3",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "5.3",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, identifiers are not distinct.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中出现相同标识符，",
			"code": "MSR_5_3",
			"override": "T",
			"master_id": "2006",
			"name": "Identifiers in inner and outer scope must be distinct",
			"name_cn": "内部和外部作用域中的标识符必须不同",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "The identifier of the internal scope should be different from the identifier of the external scope",
			"desc_cn": "内部作用域的标识符应与外部作用域的不同",
			"abstract": "The identifier of the internal scope should be different from the identifier of the external scope",
			"explanation": "When defining variables in the internal scope, you should avoid having the same name as the external scope to prevent creating ambiguity.",
			"abstract_cn": "内部作用域的标识符应与外部作用域的不同",
			"explanation_cn": "在内部作用域定义变量时应该避免与外部作用域同名，以防止产生歧义。",
			"example_good": "///c:\n#include <stdio.h>\n\nint a = 3; // identifier defined, outer scope\n\nint main()\n{\n    int b; // identifier defined, inner scope, different form the outer one\n    b = 4;\n    printf(\"%d\",b);\n    return 0;\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nint a = 3; // identifier defined, outer scope\n\nint main()\n{\n    int a; // identifier defined, inner scope, covering the outer one\n    a = 4;\n    printf(\"%d\",a);\n    return 0;\n}",
			"details_en": "#### Abstract\nThe identifier of the internal scope should be different from the identifier of the external scope\n\n#### Explanation\nWhen defining variables in the internal scope, you should avoid having the same name as the external scope to prevent creating ambiguity.",
			"details_cn": "#### 概要\n内部作用域的标识符应与外部作用域的不同\n\n#### 解释\n在内部作用域定义变量时应该避免与外部作用域同名，以防止产生歧义。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nint a = 3; // identifier defined, outer scope\n\nint main()\n{\n    int b; // identifier defined, inner scope, different form the outer one\n    b = 4;\n    printf(\"%d\",b);\n    return 0;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nint a = 3; // identifier defined, outer scope\n\nint main()\n{\n    int a; // identifier defined, inner scope, covering the outer one\n    a = 4;\n    printf(\"%d\",a);\n    return 0;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629164007361"
	},
	{
		"name": "typedef name should be a unique identifier",
		"code": "MSR_5_6",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "M2-10-3",
			"misra_c": "5.6",
			"misra_cpp": "2-10-3",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the typedef identifier is not unique.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中，typedef标识符不唯一。",
			"code": "MSR_5_6",
			"override": "T",
			"master_id": "2007",
			"name": "typedef name should be a unique identifier",
			"name_cn": "typedef 名称应为唯一标识符",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "A typedef identifier must be unique",
			"desc_cn": "typedef标识符必须唯一",
			"abstract": "A typedef identifier must be unique",
			"explanation": "Unless the alias is defined in the header file, and the header file is included, the alias defined by the typedef used must be unique in all namespaces.",
			"abstract_cn": "typedef标识符必须唯一",
			"explanation_cn": "除非该别名在头文件中被定义且该头文件被包含，否则所用typedef定义的别名在所有命名空间中必须唯一。",
			"example_good": "///c:\n#include <stdio.h>\n\ntypedef int my_name; // unique typedef declared\n\nint main()\n{\n    int my_name_2 = 1; // unique variable declared \n    printf(\"%d\",my_name_2);\n    return 0;\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\ntypedef int my_name; // typedef declared\n\nint main()\n{\n    int my_name = 1; // variable declared, same identifier\n    printf(\"%d\",my_name);\n    return 0;\n}",
			"details_en": "#### Abstract\nA typedef identifier must be unique\n\n#### Explanation\nUnless the alias is defined in the header file, and the header file is included, the alias defined by the typedef used must be unique in all namespaces.",
			"details_cn": "#### 概要\ntypedef标识符必须唯一\n\n#### 解释\n除非该别名在头文件中被定义且该头文件被包含，否则所用typedef定义的别名在所有命名空间中必须唯一。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\ntypedef int my_name; // unique typedef declared\n\nint main()\n{\n    int my_name_2 = 1; // unique variable declared \n    printf(\"%d\",my_name_2);\n    return 0;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\ntypedef int my_name; // typedef declared\n\nint main()\n{\n    int my_name = 1; // variable declared, same identifier\n    printf(\"%d\",my_name);\n    return 0;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629164078739"
	},
	{
		"name": "Tag names should be a unique identifier",
		"code": "MSR_5_7",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "5.7",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, tag names are not unique identifiers.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中，标签名称不是唯一标识符。",
			"code": "MSR_5_7",
			"override": "T",
			"master_id": "2008",
			"name": "Tag names should be a unique identifier",
			"name_cn": "标签名称应是唯一标识符",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "A tag must be unique",
			"desc_cn": "结构体标签必须唯一",
			"abstract": "A tag must be unique",
			"explanation": "Unless the tag is defined in the header file, and the header file is included, the tag used must be unique in all namespaces.",
			"abstract_cn": "结构体标签必须唯一",
			"explanation_cn": "除非该结构体标签在头文件中被定义且该头文件被包含，否则所用标签在所有命名空间中必须唯一。",
			"example_good": "///c:\n#include <stdio.h>\n\nstruct my_name // unique tag declared\n{\n    int a;\n    int b;\n};\n\nint main()\n{\n    int my_name_2 = 1; // unique variable declared\n    printf(\"%d\",my_name_2);\n    return 0;\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nstruct my_name // tag declared\n{\n    int a;\n    int b;\n};\n\nint main()\n{\n    int my_name = 1; // variable declared, same identifier\n    printf(\"%d\",my_name);\n    return 0;\n}",
			"details_en": "#### Abstract\nA tag must be unique\n\n#### Explanation\nUnless the tag is defined in the header file, and the header file is included, the tag used must be unique in all namespaces.",
			"details_cn": "#### 概要\n结构体标签必须唯一\n\n#### 解释\n除非该结构体标签在头文件中被定义且该头文件被包含，否则所用标签在所有命名空间中必须唯一。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nstruct my_name // unique tag declared\n{\n    int a;\n    int b;\n};\n\nint main()\n{\n    int my_name_2 = 1; // unique variable declared\n    printf(\"%d\",my_name_2);\n    return 0;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nstruct my_name // tag declared\n{\n    int a;\n    int b;\n};\n\nint main()\n{\n    int my_name = 1; // variable declared, same identifier\n    printf(\"%d\",my_name);\n    return 0;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629164146207"
	},
	{
		"name": "Bit field types must not be builtin types",
		"code": "MSR_6_1",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, bit fields are not appropriate data types.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中，位域未被声明为合适的数据类型。",
			"code": "MSR_6_1",
			"override": "T",
			"master_id": "2009",
			"name": "Bit field types must not be builtin types",
			"name_cn": "位域类型不能是内置类型",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "Bit fields must be declared as appropriate data types",
			"desc_cn": "位域必须被声明为合适的数据类型",
			"abstract": "Bit fields must be declared as appropriate data types",
			"explanation": "When declaring a bit field, it must be declared as one of the specified data types either signed or unsigned. It cannot be omitted in the declaration.",
			"abstract_cn": "位域必须被声明为合适的数据类型",
			"explanation_cn": "在声明位域时，必须将其声明为规定的几种数据类型中的一种且在声明中signed与unsigned不可省略。",
			"example_good": "///c:\n#include <stdio.h>\n\nstruct str\n{\n    signed int a:2;   // signed int permitted\n    unsigned int b:2; // unsigned int permitted\n};\n\nint main()\n{\n    printf(\"finished\");\n    return 0;\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nstruct str\n{\n    int a:2;   // plain int not permitted\n    float b:2; // float is inappropriate \n};\n\nint main()\n{\n    printf(\"finished\");\n    return 0;\n}",
			"details_en": "#### Abstract\nBit fields must be declared as appropriate data types\n\n#### Explanation\nWhen declaring a bit field, it must be declared as one of the specified data types either signed or unsigned. It cannot be omitted in the declaration.",
			"details_cn": "#### 概要\n位域必须被声明为合适的数据类型\n\n#### 解释\n在声明位域时，必须将其声明为规定的几种数据类型中的一种且在声明中signed与unsigned不可省略。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nstruct str\n{\n    signed int a:2;   // signed int permitted\n    unsigned int b:2; // unsigned int permitted\n};\n\nint main()\n{\n    printf(\"finished\");\n    return 0;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nstruct str\n{\n    int a:2;   // plain int not permitted\n    float b:2; // float is inappropriate \n};\n\nint main()\n{\n    printf(\"finished\");\n    return 0;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629164209713"
	},
	{
		"name": "Single-bit named field must be unsigned",
		"code": "MSR_6_2",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the single-bit named field is signed data.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中出现有符号的单位命名字段。",
			"code": "MSR_6_2",
			"override": "T",
			"master_id": "2010",
			"name": "Single-bit named field must be unsigned",
			"name_cn": "单位命名字段必须是无符号的",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "A bit field that only occupies one bit cannot be signed data",
			"desc_cn": "只占一个位的位域不能为有符号型数据",
			"abstract": "A bit field that only occupies one bit cannot be signed data",
			"explanation": "Since signed data requires the first sign bit, a bit field that only occupies one bit is not allowed to be defined as a signed data type.",
			"abstract_cn": "只占一个位的位域不能为有符号型数据",
			"explanation_cn": "由于有符号型数据要求有第一位符号位，只占一个位的位域的位域不允许定义为有符号型的数据类型。",
			"example_good": "///c:\n#include <stdio.h>\n\nstruct str\n{\n    unsigned int a:1;   // single-bit bit field declared unsigned\n};\n\nint main()\n{\n    printf (\"finished\") ;\n    return 0;\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nstruct str\n{\n    signed int a:1;   // single-bit bit field declared signed\n};\n\nint main()\n{\n    printf(\"finished\");\n    return 0;\n}",
			"details_en": "#### Abstract\nA bit field that only occupies one bit cannot be signed data\n\n#### Explanation\nSince signed data requires the first sign bit, a bit field that only occupies one bit is not allowed to be defined as a signed data type.",
			"details_cn": "#### 概要\n只占一个位的位域不能为有符号型数据\n\n#### 解释\n由于有符号型数据要求有第一位符号位，只占一个位的位域的位域不允许定义为有符号型的数据类型。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nstruct str\n{\n    unsigned int a:1;   // single-bit bit field declared unsigned\n};\n\nint main()\n{\n    printf (\"finished\") ;\n    return 0;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nstruct str\n{\n    signed int a:1;   // single-bit bit field declared signed\n};\n\nint main()\n{\n    printf(\"finished\");\n    return 0;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629164302024"
	},
	{
		"name": "String literal must only be assigned to a const char pointer",
		"code": "MSR_7_4",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, a string literal is not assigned to char type.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中的字符串文字未分配给常量指针。",
			"code": "MSR_7_4",
			"override": "T",
			"master_id": "2011",
			"name": "String literal must only be assigned to a const char pointer",
			"name_cn": "字符串文字只能分配给常量指针",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "Always assign a string literal through a const qualified pointer to char type",
			"desc_cn": "将字符串字面量通过指向常量的指针赋值给字符型",
			"abstract": "Always assign a string literal through a const qualified pointer to char type",
			"explanation": "Since the constant string is stored in the static storage area, the modification operation will cause an error. Only the constant string can be copied to the pointer to the constant string to prevent its modification operation.",
			"abstract_cn": "将字符串字面量通过指向常量的指针赋值给字符型",
			"explanation_cn": "由于常量字符串存储在静态存储区，对其的修改操作会出错，仅能将常量字符串复制给指向常量字符串的指针以防止其修改操作。",
			"example_good": "///c:\n#include <stdio.h>\n\nextern int foo (const char *a);\nextern int foo2 (const char *b);\n\nint func()\n{\n    const char *str = \"string\"; // str is not const-qualified\n    foo ( \"string\" );\n    foo2 ( \"string\" ); // string can not be modified\n    return 0;\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nextern int foo (char *a);\nextern int foo2 (char *b);\n\nint func()\n{\n    char *str = \"string\"; // str is not const-qualified\n    foo ( \"string\" );\n    foo2 ( \"string\" ); // may be modified by foo\n    return 0;\n}",
			"details_en": "#### Abstract\nAlways assign a string literal through a const qualified pointer to char type\n\n#### Explanation\nSince the constant string is stored in the static storage area, the modification operation will cause an error. Only the constant string can be copied to the pointer to the constant string to prevent its modification operation.",
			"details_cn": "#### 概要\n将字符串字面量通过指向常量的指针赋值给字符型\n\n#### 解释\n由于常量字符串存储在静态存储区，对其的修改操作会出错，仅能将常量字符串复制给指向常量字符串的指针以防止其修改操作。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nextern int foo (const char *a);\nextern int foo2 (const char *b);\n\nint func()\n{\n    const char *str = \"string\"; // str is not const-qualified\n    foo ( \"string\" );\n    foo2 ( \"string\" ); // string can not be modified\n    return 0;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nextern int foo (char *a);\nextern int foo2 (char *b);\n\nint func()\n{\n    char *str = \"string\"; // str is not const-qualified\n    foo ( \"string\" );\n    foo2 ( \"string\" ); // may be modified by foo\n    return 0;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629164990574"
	},
	{
		"name": "External object, when defined must be the same as a visble declaration.",
		"code": "MSR_8_4",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the external object is not compatible with its declaration.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中的外部对象与其声明不兼容。",
			"code": "MSR_8_4",
			"override": "T",
			"master_id": "2012",
			"name": "External object, when defined must be the same as a visble declaration.",
			"name_cn": "外部对象，在定义时必须与可见声明相同。",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "Defining objects that have external linkage should be compatible with their declarations",
			"desc_cn": "在定义有外部链接的对象时，应保持与其声明兼容",
			"abstract": "Defining objects that have external linkage should be compatible with their declarations",
			"explanation": "When defining an object or function with external linkage, the data type, number of parameters, etc. of the object or function must be compatible with the external declaration.",
			"abstract_cn": "在定义有外部链接的对象时，应保持与其声明兼容",
			"explanation_cn": "在定义具有外部链接的对象或者函数时，必须保持该对象或者函数的数据类型，参数数量等与外部的声明兼容。",
			"example_good": "///c:\n#include <stdio.h>\n\nextern int func(int a); // extern function declared\n\nint func(int a) // extern compatible funtion defined\n{\n    return 0;\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nextern int func(int a); // extern function declared\n\nint func(int a, int b) // parameters different\n{\n    return 0;\n}",
			"details_en": "#### Abstract\nDefining objects that have external linkage should be compatible with their declarations\n\n#### Explanation\nWhen defining an object or function with external linkage, the data type, number of parameters, etc. of the object or function must be compatible with the external declaration.",
			"details_cn": "#### 概要\n在定义有外部链接的对象时，应保持与其声明兼容\n\n#### 解释\n在定义具有外部链接的对象或者函数时，必须保持该对象或者函数的数据类型，参数数量等与外部的声明兼容。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nextern int func(int a); // extern function declared\n\nint func(int a) // extern compatible funtion defined\n{\n    return 0;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nextern int func(int a); // extern function declared\n\nint func(int a, int b) // parameters different\n{\n    return 0;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629165398928"
	},
	{
		"name": "Objects with internal linkage should be declared static ",
		"code": "MSR_8_8",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "M3-3-2",
			"misra_c": "8.8",
			"misra_cpp": "3-3-2",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the object with internal linkage is not declared static.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中，具有内部链接的对象未被声明为静态。",
			"code": "MSR_8_8",
			"override": "T",
			"master_id": "2013",
			"name": "Objects with internal linkage should be declared static ",
			"name_cn": "具有内部链接的对象应声明为静态",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "The static specifier should be added to the object that has internal linkage",
			"desc_cn": "有内部链接的对象要加上static说明符",
			"abstract": "The static specifier should be added to the object that has internal linkage",
			"explanation": "When declaring an object or function with internal linkage, a static specifier must be added to ensure the declaration is correct. ",
			"abstract_cn": "有内部链接的对象要加上static说明符",
			"explanation_cn": "在声明具有内部链接的对象或者函数时，必须加上static的说明符以保持声明的正确性。",
			"example_good": "///c:\n#include <stdio.h>\n\nstatic int func (int a); // function with internal linkage declared\n\nstatic int func (int a) // function defined with \"static\"\n{\n    return a;\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nstatic int func (int a); // function with internal linkage declared\n\nint func (int a) // function defined without \"static\"\n{\n    return a;\n}",
			"details_en": "#### Abstract\nThe static specifier should be added to the object that has internal linkage\n\n#### Explanation\nWhen declaring an object or function with internal linkage, a static specifier must be added to ensure the declaration is correct. ",
			"details_cn": "#### 概要\n有内部链接的对象要加上static说明符\n\n#### 解释\n在声明具有内部链接的对象或者函数时，必须加上static的说明符以保持声明的正确性。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nstatic int func (int a); // function with internal linkage declared\n\nstatic int func (int a) // function defined with \"static\"\n{\n    return a;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nstatic int func (int a); // function with internal linkage declared\n\nint func (int a) // function defined without \"static\"\n{\n    return a;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629169804829"
	},
	{
		"name": "An object should be defined at block scope if its identifier only appears in a single function",
		"code": "MSR_8_9",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "M3-4-1",
			"misra_c": "8.9",
			"misra_cpp": "3-4-1",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the object is not defined in the scope in which it appears.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中的对象未被定义在它出现的作用域内。",
			"code": "MSR_8_9",
			"override": "T",
			"master_id": "2014",
			"name": "An object should be defined at block scope if its identifier only appears in a single function",
			"name_cn": "如果对象的标识符仅出现在单个函数中，则应在该范围内定义该对象",
			"severity": "H",
			"compliance": "A",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "The object should only be defined in the scope in which it appears",
			"desc_cn": "对象应仅被定义在它出现的作用域内",
			"abstract": "The object should only be defined in the scope in which it appears",
			"explanation": "When an object only functions in a certain scope, it should be defined in that scope to prevent other scopes from changing its value.",
			"abstract_cn": "对象应仅被定义在它出现的作用域内",
			"explanation_cn": "当一个对象仅仅在一定的作用域内作用时，应该将它定义在该作用域内以防止其他作用域改变了它的值。",
			"example_good": "///c:\n#include <stdio.h>\n\nextern int foo (int *a);\nextern void foo2 ( void );\n\nint count ( void )\n{\n    static int num = 0; // object declared at block scope\n    num++; // object appears only in this function\n    return num;\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nextern int foo(int *a);\nextern void foo2( void );\nstatic int num = 0; // object declared, global scope\n\nint count( void )\n{\n    num++; // object appears only in this function\n    return num;\n}\n\nextern void foo2( void )\n{\n    foo(&num); // object may be modified at outer scope\n}",
			"details_en": "#### Abstract\nThe object should only be defined in the scope in which it appears\n\n#### Explanation\nWhen an object only functions in a certain scope, it should be defined in that scope to prevent other scopes from changing its value.",
			"details_cn": "#### 概要\n对象应仅被定义在它出现的作用域内\n\n#### 解释\n当一个对象仅仅在一定的作用域内作用时，应该将它定义在该作用域内以防止其他作用域改变了它的值。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nextern int foo (int *a);\nextern void foo2 ( void );\n\nint count ( void )\n{\n    static int num = 0; // object declared at block scope\n    num++; // object appears only in this function\n    return num;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nextern int foo(int *a);\nextern void foo2( void );\nstatic int num = 0; // object declared, global scope\n\nint count( void )\n{\n    num++; // object appears only in this function\n    return num;\n}\n\nextern void foo2( void )\n{\n    foo(&num); // object may be modified at outer scope\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629169875168"
	},
	{
		"name": "Inline function should have a static declaration",
		"code": "MSR_8_10",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, inline function ${so.func} does not have static declaration.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中的内联函数没有静态声明 。",
			"code": "MSR_8_10",
			"override": "T",
			"master_id": "2015",
			"name": "Inline function should have a static declaration",
			"name_cn": "内联函数应具有静态声明 ",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "A static storage class should be used to declare inline functions",
			"desc_cn": "应该用静态存储类声明内联函数",
			"abstract": "A static storage class should be used to declare inline functions",
			"explanation": "Referencing an inline function of an external linkage may affect the execution time, so the inline function should be declared with a static storage class.",
			"abstract_cn": "应该用静态存储类声明内联函数",
			"explanation_cn": "引用外部链接的内联函数可能会影响执行的时间，因此应该用静态储存类声明内联函数。",
			"example_good": "///c:\n#include <stdio.h>\n\nstatic inline int func( void ); // inline function declared with internal linkage\nint func2( void );\n\nint func2( void )\n{\n    func();\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nextern inline int func( void ); // inline function declared with external linkage\nint func2( void );\n\nint func2( void )\n{\n    func();\n}",
			"details_en": "#### Abstract\nA static storage class should be used to declare inline functions\n\n#### Explanation\nReferencing an inline function of an external linkage may affect the execution time, so the inline function should be declared with a static storage class.",
			"details_cn": "#### 概要\n应该用静态存储类声明内联函数\n\n#### 解释\n引用外部链接的内联函数可能会影响执行的时间，因此应该用静态储存类声明内联函数。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nstatic inline int func( void ); // inline function declared with internal linkage\nint func2( void );\n\nint func2( void )\n{\n    func();\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nextern inline int func( void ); // inline function declared with external linkage\nint func2( void );\n\nint func2( void )\n{\n    func();\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629169937109"
	},
	{
		"name": "When an array with external linkage is declared, its size should be explicitly specified",
		"code": "MSR_8_11",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "M3-1-4",
			"misra_c": "8.11",
			"misra_cpp": "3-1-3",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the size of the array of external linkage is not explicitly specified.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中未明确外部链接的数组的大小。",
			"code": "MSR_8_11",
			"override": "T",
			"master_id": "2016",
			"name": "When an array with external linkage is declared, its size should be explicitly specified",
			"name_cn": "声明带有外部链接的数组时，应明确指定其大小",
			"severity": "H",
			"compliance": "A",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "The size of the array of external linkage must be explicitly specified",
			"desc_cn": "需要明确外部链接的数组的大小",
			"abstract": "The size of the array of external linkage must be explicitly specified",
			"explanation": "In order to ensure consistency and determine the boundaries of the storage area, the size of the array must be determined when declaring an externally linked array.",
			"abstract_cn": "需要明确外部链接的数组的大小",
			"explanation_cn": "为了保证一致性以及确定存储区的边界，在声明外部链接的数组时必须确定该数组的大小。",
			"example_good": "///c:\n#include <stdio.h>\n\nextern int array[20]; // declare array with external linkage and its size\nint foo ( void ) ;\n\nint foo ( void )\n{\n    return array[10];\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nextern int array[]; // declare array with external linkage but without size\nint foo( void );\n\nint foo ( void )\n{\n    return array[10]; // 10 may be bigger than actual array size\n}",
			"details_en": "#### Abstract\nThe size of the array of external linkage must be explicitly specified\n\n#### Explanation\nIn order to ensure consistency and determine the boundaries of the storage area, the size of the array must be determined when declaring an externally linked array.",
			"details_cn": "#### 概要\n需要明确外部链接的数组的大小\n\n#### 解释\n为了保证一致性以及确定存储区的边界，在声明外部链接的数组时必须确定该数组的大小。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nextern int array[20]; // declare array with external linkage and its size\nint foo ( void ) ;\n\nint foo ( void )\n{\n    return array[10];\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nextern int array[]; // declare array with external linkage but without size\nint foo( void );\n\nint foo ( void )\n{\n    return array[10]; // 10 may be bigger than actual array size\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629170079841"
	},
	{
		"name": "An implicitly specified enum constant list should be unique",
		"code": "MSR_8_12",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the implicitly specified enum constant list is not unique.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中的隐式指定的枚举常量列表不唯一。",
			"code": "MSR_8_12",
			"override": "T",
			"master_id": "2017",
			"name": "An implicitly specified enum constant list should be unique",
			"name_cn": "隐式指定的枚举常量列表应是唯一的",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "The value of the enumeration member assigned by default must be unique",
			"desc_cn": "默认赋值的枚举成员的值唯一",
			"abstract": "The value of the enumeration member assigned by default must be unique",
			"explanation": "In order to avoid the incorrect repetition of the value of the enumeration member, the value of the enumeration member should be ",
			"abstract_cn": "默认赋值的枚举成员的值唯一",
			"explanation_cn": "为了避免枚举成员的值错误地重复，应该保证通过枚举值列表顺序默认赋值地枚举成员的值唯一。",
			"example_good": "///c:\n#include <stdio.h>\n\n// all implicitly-specified enmueration constants is unique\ntypedef enum weekday {thu = 4, fri, sat = 6, sun = 6};",
			"example_bad": "///c:\n#include <stdio.h>\n\n// implicitly-specified enmueration sat is not unique\ntypedef enum weekday {thu = 4, fri, sat, sun = 6};",
			"details_en": "#### Abstract\nThe value of the enumeration member assigned by default must be unique\n\n#### Explanation\nIn order to avoid the incorrect repetition of the value of the enumeration member, the value of the enumeration member should be ",
			"details_cn": "#### 概要\n默认赋值的枚举成员的值唯一\n\n#### 解释\n为了避免枚举成员的值错误地重复，应该保证通过枚举值列表顺序默认赋值地枚举成员的值唯一。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\n// all implicitly-specified enmueration constants is unique\ntypedef enum weekday {thu = 4, fri, sat = 6, sun = 6};"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\n// implicitly-specified enmueration sat is not unique\ntypedef enum weekday {thu = 4, fri, sat, sun = 6};"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629170158219"
	},
	{
		"name": "A pointer should point to a const-qualified type whenever possible",
		"code": "MSR_8_13",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the pointer is not declared with const qualifier.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中指针声明不是常量。",
			"code": "MSR_8_13",
			"override": "T",
			"master_id": "2018",
			"name": "A pointer should point to a const-qualified type whenever possible",
			"name_cn": "指针应尽可能指向 const 限定的类型",
			"severity": "H",
			"compliance": "A",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "Try to declare pointers with const qualifier",
			"desc_cn": "建议将指针声明限定为常量",
			"abstract": "Try to declare pointers with const qualifier",
			"explanation": "A pointer should always point to the same underlying qualified type. Mixed type assignments should be always explicitly casted.",
			"abstract_cn": "建议将指针声明限定为常量",
			"explanation_cn": "指针应指向相同限定的类型。指针若是指向的限定类型不同，应进行显式转换。",
			"example_good": "///c:\n#include <stdio.h>\n\nvoid func (const char *ptr);\n\nvoid func (const char *ptr) // pointer declared const-qualified\n{\n    // ptr pointed to is not modified\n    printf (\"%c\", *ptr);\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nvoid func (char *ptr);\n\nvoid func (char *ptr) // pointer declared is not const-qualified\n{\n    // ptr pointed to is not modified, it should be const-qualified\n    printf (\"%c\", *ptr);\n}",
			"details_en": "#### Abstract\nTry to declare pointers with const qualifier\n\n#### Explanation\nA pointer should always point to the same underlying qualified type. Mixed type assignments should be always explicitly casted.",
			"details_cn": "#### 概要\n建议将指针声明限定为常量\n\n#### 解释\n指针应指向相同限定的类型。指针若是指向的限定类型不同，应进行显式转换。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func (const char *ptr);\n\nvoid func (const char *ptr) // pointer declared const-qualified\n{\n    // ptr pointed to is not modified\n    printf (\"%c\", *ptr);\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func (char *ptr);\n\nvoid func (char *ptr) // pointer declared is not const-qualified\n{\n    // ptr pointed to is not modified, it should be const-qualified\n    printf (\"%c\", *ptr);\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629170214347"
	},
	{
		"name": "Restrict qualifier should not be used",
		"code": "MSR_8_14",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the restrict type qualifier is used",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中使用了restrict关键字",
			"code": "MSR_8_14",
			"override": "T",
			"master_id": "2019",
			"name": "Restrict qualifier should not be used",
			"name_cn": "不能使用限制限定符",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "Try to avoid using the restrict type qualifier",
			"desc_cn": "尽量避免使用restrict关键字",
			"abstract": "Try to avoid using the restrict type qualifier",
			"explanation": "In order to prevent problems such as overlapping of the areas pointed to by the pointer, the restrict type qualifier should be avoided as much as possible.",
			"abstract_cn": "尽量避免使用restrict关键字",
			"explanation_cn": "为防止指针指向的区域重合等问题，应该尽量避免使用restrict关键字。",
			"example_good": "///c:\n#include <stdio.h>\n\n// restrict type qualifier removed\nextern void func (int * ptr1, int * ptr2);\nvoid func2 (void);\n\nvoid func2(void)\n{\n    int i;\n    int *a,*b;\n    a = b = &i;\n    func (a, b);\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\n// restrict-qualified parameters declared\nextern void func (int * restrict ptr1, int * restrict ptr2);\nvoid func2 (void);\n\nvoid func2(void)\n{\n    int i;\n    int *a,*b;\n    a = b = &i;\n    // overlap memory areas\n    func (a, b);\n}",
			"details_en": "#### Abstract\nTry to avoid using the restrict type qualifier\n\n#### Explanation\nIn order to prevent problems such as overlapping of the areas pointed to by the pointer, the restrict type qualifier should be avoided as much as possible.",
			"details_cn": "#### 概要\n尽量避免使用restrict关键字\n\n#### 解释\n为防止指针指向的区域重合等问题，应该尽量避免使用restrict关键字。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\n// restrict type qualifier removed\nextern void func (int * ptr1, int * ptr2);\nvoid func2 (void);\n\nvoid func2(void)\n{\n    int i;\n    int *a,*b;\n    a = b = &i;\n    func (a, b);\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\n// restrict-qualified parameters declared\nextern void func (int * restrict ptr1, int * restrict ptr2);\nvoid func2 (void);\n\nvoid func2(void)\n{\n    int i;\n    int *a,*b;\n    a = b = &i;\n    // overlap memory areas\n    func (a, b);\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629173998655"
	},
	{
		"name": "Arrays should not be partially initialized",
		"code": "MSR_9_3",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, arrays are partially initialized",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中的数组只被部分初始化",
			"code": "MSR_9_3",
			"override": "T",
			"master_id": "2020",
			"name": "Arrays should not be partially initialized",
			"name_cn": "数组不应该部分初始化",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "Arrays must not be partially initialized",
			"desc_cn": "不能只初始化数组的一部分",
			"abstract": "Arrays must not be partially initialized",
			"explanation": "In order to ensure that there are no unprocessed values in the array after explicitly initializing the array, all elements in the array must also be explicitly initialized.",
			"abstract_cn": "不能只初始化数组的一部分",
			"explanation_cn": "为了保证在显式初始化数组后数组中不再存在未经过处理的值，在对数组进行显式初始化时也必须对数组内所有的元素进行显式初始化操作。",
			"example_good": "///c:\n#include <stdio.h>\n\nint func( void );\n\nint func ( void )\n{\n    int a[10] = {0}; // array totally initialized\n    return a[9]; // a[9] is ",
			"example_bad": "///c:\n#include <stdio.h>\n\nint func( void );\n\nint func ( void )\n{\n    int a[10] = {0, 0, 0}; // array only initialized three elements\n    return a[9]; // a[9] is still unknown value\n}",
			"details_en": "#### Abstract\nArrays must not be partially initialized\n\n#### Explanation\nIn order to ensure that there are no unprocessed values in the array after explicitly initializing the array, all elements in the array must also be explicitly initialized.",
			"details_cn": "#### 概要\n不能只初始化数组的一部分\n\n#### 解释\n为了保证在显式初始化数组后数组中不再存在未经过处理的值，在对数组进行显式初始化时也必须对数组内所有的元素进行显式初始化操作。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nint func( void );\n\nint func ( void )\n{\n    int a[10] = {0}; // array totally initialized\n    return a[9]; // a[9] is "
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nint func( void );\n\nint func ( void )\n{\n    int a[10] = {0, 0, 0}; // array only initialized three elements\n    return a[9]; // a[9] is still unknown value\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629174050627"
	},
	{
		"name": "Multiple initialization of elements in an object is not allowed",
		"code": "MSR_9_4",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the elements in the object have been initialized more than once",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}，对象中的元素被初始化多于一次",
			"code": "MSR_9_4",
			"override": "T",
			"master_id": "2021",
			"name": "Multiple initialization of elements in an object is not allowed",
			"name_cn": "不允许对对象中的元素进行多次初始化",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "The elements in the object can only be initialized once",
			"desc_cn": "对象中的元素只能初始化一次",
			"abstract": "The elements in the object can only be initialized once",
			"explanation": "When initializing arrays and structures that are not in the default order, you must not initialize the same element(s) repeatedly.",
			"abstract_cn": "对象中的元素只能初始化一次",
			"explanation_cn": "在进行不按默认顺序的数组和结构体的初始化的时，必须注意不能对同一元素进行重复的初始化。",
			"example_good": "///c:\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func( void )\n{\n    // all elements initialized once\n    int arr[3] = { [ 0 ] = 3, [ 1 ] = 2, [ 2 ] = 1};\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func( void )\n{\n    // a[0] initialized twice\n    int arr[3] = { [ 0 ] = 3, [ 1 ] = 2, [ 2 ] = 1, [ 0 ] = 4};\n}",
			"details_en": "#### Abstract\nThe elements in the object can only be initialized once\n\n#### Explanation\nWhen initializing arrays and structures that are not in the default order, you must not initialize the same element(s) repeatedly.",
			"details_cn": "#### 概要\n对象中的元素只能初始化一次\n\n#### 解释\n在进行不按默认顺序的数组和结构体的初始化的时，必须注意不能对同一元素进行重复的初始化。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func( void )\n{\n    // all elements initialized once\n    int arr[3] = { [ 0 ] = 3, [ 1 ] = 2, [ 2 ] = 1};\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func( void )\n{\n    // a[0] initialized twice\n    int arr[3] = { [ 0 ] = 3, [ 1 ] = 2, [ 2 ] = 1, [ 0 ] = 4};\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629174105777"
	},
	{
		"name": "If initializers are used in an array, its size must be known",
		"code": "MSR_9_5",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the size of the array that uses explicit initializer is not declared",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}使用显式初始化的数组未声明其大小",
			"code": "MSR_9_5",
			"override": "T",
			"master_id": "2022",
			"name": "If initializers are used in an array, its size must be known",
			"name_cn": "如果在数组中使用初始值设定项，则必须知道其大小",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "The size of the array must be declared if an explicit initializer is used on the array",
			"desc_cn": "使用显式初始化的数组必须声明其大小",
			"abstract": "The size of the array must be declared if an explicit initializer is used on the array",
			"explanation": "In order to determine the maximum number of elements in the array, when this array is explicitly initialized, the array size must be specified.",
			"abstract_cn": "使用显式初始化的数组必须声明其大小",
			"explanation_cn": "为确定数组的最大的元素数量，使用显式初始化方法进行初始化的数组的大小必须是确定的。",
			"example_good": "///c:\n#include <stdio.h>\n\nint func ( void );\n\nint func( void )\n{\n    // arr have designated initializer with size specified explicitly\n    int arr[10] = { [ 5 ] = 1};\n    return arr[ 9 ];\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nint func ( void );\n\nint func( void )\n{\n    // flexible array declared using designated initializer\n    int arr[] = { [ 5 ] = 1};\n    // array may not have the element arr[9]\n    return arr[ 9 ];\n}",
			"details_en": "#### Abstract\nThe size of the array must be declared if an explicit initializer is used on the array\n\n#### Explanation\nIn order to determine the maximum number of elements in the array, when this array is explicitly initialized, the array size must be specified.",
			"details_cn": "#### 概要\n使用显式初始化的数组必须声明其大小\n\n#### 解释\n为确定数组的最大的元素数量，使用显式初始化方法进行初始化的数组的大小必须是确定的。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nint func ( void );\n\nint func( void )\n{\n    // arr have designated initializer with size specified explicitly\n    int arr[10] = { [ 5 ] = 1};\n    return arr[ 9 ];\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nint func ( void );\n\nint func( void )\n{\n    // flexible array declared using designated initializer\n    int arr[] = { [ 5 ] = 1};\n    // array may not have the element arr[9]\n    return arr[ 9 ];\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629174191770"
	},
	{
		"name": "Down casting of an expression is not allowed",
		"code": "MSR_10_3",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "M5-0-6",
			"misra_c": "10.3",
			"misra_cpp": "5-0-6",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func} includes down casting of an expression",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中出现向下转换表达式",
			"code": "MSR_10_3",
			"override": "T",
			"master_id": "2023",
			"name": "Down casting of an expression is not allowed",
			"name_cn": "不允许向下转换表达式",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "You cannot assign values to objects with different essential types",
			"desc_cn": "不能为不同类型的对象赋值",
			"abstract": "You cannot assign values to objects with different essential types",
			"explanation": "It is erroneous to assign the value of an expression to an object with an inappropriate type or is not large enough to represent the data type of the value.",
			"abstract_cn": "不能为不同类型的对象赋值",
			"explanation_cn": "把表达式的值赋值给不恰当类型的或者大小不足以表示该值的数据类型的对象，都是错误的做法。",
			"example_good": "///c:\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    short short_a;\n    int b;       // b declared as int for illustration\n    b = short_a; // short_a assigned to wider essential type object\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    short short_a;\n    long int b;\n    short_a = b; // c assigned to narrower essential type\n}",
			"details_en": "#### Abstract\nYou cannot assign values to objects with different essential types\n\n#### Explanation\nIt is erroneous to assign the value of an expression to an object with an inappropriate type or is not large enough to represent the data type of the value.",
			"details_cn": "#### 概要\n不能为不同类型的对象赋值\n\n#### 解释\n把表达式的值赋值给不恰当类型的或者大小不足以表示该值的数据类型的对象，都是错误的做法。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    short short_a;\n    int b;       // b declared as int for illustration\n    b = short_a; // short_a assigned to wider essential type object\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    short short_a;\n    long int b;\n    short_a = b; // c assigned to narrower essential type\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629174388735"
	},
	{
		"name": "operands and type conversion",
		"code": "MSR_10_4",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "M5-0-4",
			"misra_c": "10.4",
			"misra_cpp": "5-0-4",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the two operands of the same operator are not of the same essential type category",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中同一操作符的两个操作数不是同一类型",
			"code": "MSR_10_4",
			"override": "T",
			"master_id": "2024",
			"name": "operands and type conversion",
			"name_cn": "操作数和类型转换",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "The two operands of the same operator must be of the same essential type category",
			"desc_cn": "同一操作符的两个操作数为同一类型",
			"abstract": "The two operands of the same operator must be of the same essential type category",
			"explanation": "Using binary or ternary operands for two different types of operands may cause some information of the resulting value to be lost. Therefore, in general, the two operands of the uniform operator should be of the same type.",
			"abstract_cn": "同一操作符的两个操作数为同一类型",
			"explanation_cn": "用二元或者三元操作数对两个不同的类型的操作数可能会使所得的值的部分信息丢失。因此在一般情况下，统一操作符的两操作数应该为同一类型。",
			"example_good": "///c:\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    int int_var;\n    char char_var;\n    // int 1 added to char char_var, permitted\n    char_var += 1;\n    // int 1 added to int int_var, same type\n    int_var += 1;\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    int int_var;\n    char char_var;\n    // float 1.0f added to char char_var, not permitted\n    char_var += 1.0f;\n    // float 1.0f added to int int_var, differnt type\n    int_var += 1.0f;\n}",
			"details_en": "#### Abstract\nThe two operands of the same operator must be of the same essential type category\n\n#### Explanation\nUsing binary or ternary operands for two different types of operands may cause some information of the resulting value to be lost. Therefore, in general, the two operands of the uniform operator should be of the same type.",
			"details_cn": "#### 概要\n同一操作符的两个操作数为同一类型\n\n#### 解释\n用二元或者三元操作数对两个不同的类型的操作数可能会使所得的值的部分信息丢失。因此在一般情况下，统一操作符的两操作数应该为同一类型。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    int int_var;\n    char char_var;\n    // int 1 added to char char_var, permitted\n    char_var += 1;\n    // int 1 added to int int_var, same type\n    int_var += 1;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    int int_var;\n    char char_var;\n    // float 1.0f added to char char_var, not permitted\n    char_var += 1.0f;\n    // float 1.0f added to int int_var, differnt type\n    int_var += 1.0f;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629174488685"
	},
	{
		"name": "Same essential type within an expression ",
		"code": "MSR_10_5",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "M5-0-5",
			"misra_c": "10.5 ",
			"misra_cpp": "5-0-5",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the value of the expression is converted to an inappropriate essential type",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中表达式的值被转换为不适当的类型",
			"code": "MSR_10_5",
			"override": "T",
			"master_id": "2025",
			"name": "Same essential type within an expression ",
			"name_cn": "表达式中相同的基本类型",
			"severity": "H",
			"compliance": "A",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "The value of the expression cannot be converted to an inappropriate essential type",
			"desc_cn": "表达式的值不能被转换为不适当的类型",
			"abstract": "The value of the expression cannot be converted to an inappropriate essential type",
			"explanation": "Cast conversion between two inappropriate types may result in the loss or change of data, so the value of the expression cannot be cast to an inappropriate type.",
			"abstract_cn": "表达式的值不能被转换为不适当的类型",
			"explanation_cn": "在两种不适当的类型之间进行强制类型转换可能会导致数据的丢失或者改变，因此表达式的值不能不能被强制转换为不适当的类型。",
			"example_good": "///c:\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    char char_var;\n    bool bool_var;\n    // int can be cast to char\n    char_var = ( char ) 1;\n    // int 1 can be cast to bool by exception\n    bool_var = ( bool ) 1;\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    char char_var;\n    bool bool_var;\n    // expression 1.0f cast to an narrower type char\n    char_var = ( char ) 1.0f;\n    // char_var cast to narrower type bool\n    bool_var = ( bool ) char_var;\n}",
			"details_en": "#### Abstract\nThe value of the expression cannot be converted to an inappropriate essential type\n\n#### Explanation\nCast conversion between two inappropriate types may result in the loss or change of data, so the value of the expression cannot be cast to an inappropriate type.",
			"details_cn": "#### 概要\n表达式的值不能被转换为不适当的类型\n\n#### 解释\n在两种不适当的类型之间进行强制类型转换可能会导致数据的丢失或者改变，因此表达式的值不能不能被强制转换为不适当的类型。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    char char_var;\n    bool bool_var;\n    // int can be cast to char\n    char_var = ( char ) 1;\n    // int 1 can be cast to bool by exception\n    bool_var = ( bool ) 1;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    char char_var;\n    bool bool_var;\n    // expression 1.0f cast to an narrower type char\n    char_var = ( char ) 1.0f;\n    // char_var cast to narrower type bool\n    bool_var = ( bool ) char_var;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629174549246"
	},
	{
		"name": "Assignment from a composite expression should remain the same size ",
		"code": "MSR_10_6",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "M5-0-8",
			"misra_c": "10.6",
			"misra_cpp": "5-0-8",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the use of composite expressions to assign values to objects of larger data types does not use explicit conversions",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中，使用复合表达式为更大的数据类型的对象赋值时未使用显式转换",
			"code": "MSR_10_6",
			"override": "T",
			"master_id": "2026",
			"name": "Assignment from a composite expression should remain the same size ",
			"name_cn": "复合表达式的赋值应保持相同的大小",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "The use of composite expressions to assign values to objects of larger data types should use explicit conversions",
			"desc_cn": "使用复合表达式为更大的数据类型的对象赋值应使用显式转换",
			"abstract": "The use of composite expressions to assign values to objects of larger data types should use explicit conversions",
			"explanation": "Explicit conversion must be used when converting the value of a composite expression to a data type with more storage space and assigning it to an object.",
			"abstract_cn": "使用复合表达式为更大的数据类型的对象赋值应使用显式转换",
			"explanation_cn": "将一个复合表达式的值转换为储存空间更大的数据类型并赋值给一个对象时必须要使用显式转换。",
			"example_good": "///c:\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    long long_var;\n    short short_a, short_b;\n    short_a = 1\n    short_b = 1;\n    long_var = ( long )short_a + short_b; // explicitly converted to long\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    long int long_var;\n    short int short_a, short_b;\n    short_a = short_b = 1;\n    long_var = short_a + short_b; // implicitly converted to long\n}",
			"details_en": "#### Abstract\nThe use of composite expressions to assign values to objects of larger data types should use explicit conversions\n\n#### Explanation\nExplicit conversion must be used when converting the value of a composite expression to a data type with more storage space and assigning it to an object.",
			"details_cn": "#### 概要\n使用复合表达式为更大的数据类型的对象赋值应使用显式转换\n\n#### 解释\n将一个复合表达式的值转换为储存空间更大的数据类型并赋值给一个对象时必须要使用显式转换。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    long long_var;\n    short short_a, short_b;\n    short_a = 1\n    short_b = 1;\n    long_var = ( long )short_a + short_b; // explicitly converted to long\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    long int long_var;\n    short int short_a, short_b;\n    short_a = short_b = 1;\n    long_var = short_a + short_b; // implicitly converted to long\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629174601501"
	},
	{
		"name": "For composite expressions, any up casting on either side is not allowed",
		"code": "MSR_10_7",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "10.7",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, an explicit conversion is not used when a composite expression is converted to a larger data type as an operand",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中，复合表达式作为操作数转化为更大的数据类型时未使用显式转换",
			"code": "MSR_10_7",
			"override": "T",
			"master_id": "2027",
			"name": "For composite expressions, any up casting on either side is not allowed",
			"name_cn": "对于复合表达式，不允许在任一侧进行任何向上转换",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "An explicit conversion is used when a composite expression is converted to a larger data type as an operand",
			"desc_cn": "复合表达式作为操作数转化为更大的数据类型时用显式转换",
			"abstract": "An explicit conversion is used when a composite expression is converted to a larger data type as an operand",
			"explanation": "When a composite expression is used as one of the operands of an operator and needs to be converted to a larger data type, explicit conversion must be used.",
			"abstract_cn": "复合表达式作为操作数转化为更大的数据类型时用显式转换",
			"explanation_cn": "当复合表达式作为操作符的其中一个操作数并且需要转化为更大的数据类型时，必须使用显示转换。",
			"example_good": "///c:\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    short int short_a, short_b;\n    long int long_a, long_b;\n    long_a = 1;\n    short_a = short_b = 2;\n    long_b = ( ( long ) short_a * short_b ) * long_a; // explicitly converted to long\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    short int short_a, short_b;\n    long int long_a, long_b;\n    long_a = 1;\n    short_a = short_b = 2;\n    long_b = (short_a * short_b) * long_a; // implicitly converted to long\n}",
			"details_en": "#### Abstract\nAn explicit conversion is used when a composite expression is converted to a larger data type as an operand\n\n#### Explanation\nWhen a composite expression is used as one of the operands of an operator and needs to be converted to a larger data type, explicit conversion must be used.",
			"details_cn": "#### 概要\n复合表达式作为操作数转化为更大的数据类型时用显式转换\n\n#### 解释\n当复合表达式作为操作符的其中一个操作数并且需要转化为更大的数据类型时，必须使用显示转换。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    short int short_a, short_b;\n    long int long_a, long_b;\n    long_a = 1;\n    short_a = short_b = 2;\n    long_b = ( ( long ) short_a * short_b ) * long_a; // explicitly converted to long\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    short int short_a, short_b;\n    long int long_a, long_b;\n    long_a = 1;\n    short_a = short_b = 2;\n    long_b = (short_a * short_b) * long_a; // implicitly converted to long\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629174658525"
	},
	{
		"name": "Composite expression cannot be up casted",
		"code": "MSR_10_8",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the value of a composite expression is cast to an inappropriate data type",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中，复合表达式的值被转换为不适当的数据类型",
			"code": "MSR_10_8",
			"override": "T",
			"master_id": "2028",
			"name": "Composite expression cannot be up casted",
			"name_cn": "复合表达式不能向上转换",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "The value of a composite expression cannot be cast to an inappropriate data type",
			"desc_cn": "复合表达式的值不能被转换为不适当的数据类型",
			"abstract": "The value of a composite expression cannot be cast to an inappropriate data type",
			"explanation": "The data type cast conversion may cause the loss or change of data.",
			"abstract_cn": "复合表达式的值不能被转换为不适当的数据类型",
			"explanation_cn": "在数据类型转换中可能会导致数据的丢失或者改变，因此不能复合表达式的值不能被转换为不适当的数据类型。",
			"example_good": "///c:\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    float float_a, float_b;\n    int int_var;\n    float_a = float_b = 1.0f;\n    int_var = ( int ) float_a + ( int ) float_b; // float_a and float_b casted to type int\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    float float_a, float_b;\n    int int_var;\n    float_a = float_b = 1.0f;\n    int_var = ( int ) ( float_a + float_b ); // casted to inappropriate type int\n}",
			"details_en": "#### Abstract\nThe value of a composite expression cannot be cast to an inappropriate data type\n\n#### Explanation\nThe data type cast conversion may cause the loss or change of data.",
			"details_cn": "#### 概要\n复合表达式的值不能被转换为不适当的数据类型\n\n#### 解释\n在数据类型转换中可能会导致数据的丢失或者改变，因此不能复合表达式的值不能被转换为不适当的数据类型。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    float float_a, float_b;\n    int int_var;\n    float_a = float_b = 1.0f;\n    int_var = ( int ) float_a + ( int ) float_b; // float_a and float_b casted to type int\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    float float_a, float_b;\n    int int_var;\n    float_a = float_b = 1.0f;\n    int_var = ( int ) ( float_a + float_b ); // casted to inappropriate type int\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629174711021"
	},
	{
		"name": "No conversion of pointer to incomplete type convert to any other type",
		"code": "MSR_11_2",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "A5-2-4",
			"misra_c": "11.2",
			"misra_cpp": "5-2-7",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, pointers to incomplete types are converted to pointers of other types",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中，指向不完整类型的指针与其他类型的指针进行了转换",
			"code": "MSR_11_2",
			"override": "T",
			"master_id": "2029",
			"name": "No conversion of pointer to incomplete type convert to any other type",
			"name_cn": "不能将指向不完整类型的指针转换为任何其他类型",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "Pointers to incomplete types cannot be converted to pointers of other types and vice versa ",
			"desc_cn": "指向不完整类型的指针与其他类型的指针不能转换，反之亦然",
			"abstract": "Pointers to incomplete types cannot be converted to pointers of other types and vice versa ",
			"explanation": "Type conversion operations between pointers to incomplete types may destroy the encapsulation of incomplete types, so pointers of incomplete types cannot be converted to pointers of other types.",
			"abstract_cn": "指向不完整类型的指针与其他类型的指针不能转换，反之亦然",
			"explanation_cn": "对指向不完整类型的指针进行类型转换操作可能会破坏不完整类型的封装，因此不能对不完整类型的指针转换为其他类型的指针。",
			"example_good": "///c:\n#include <stdio.h>\n\nunion uni\n{\n    int i;\n    char c;\n}; // union declared\nvoid func ( void );\n\nvoid func ( void )\n{\n    union uni union_var;\n    union_var.i =1;\n    int *ptr_int;\n    // ptr_int point to union_var.i\n    ptr_int = &union_var.i;\n    ptr_int = ( void * )ptr_union; // also allowed by exception\n\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nunion uni; // incomplete type declared\nvoid func ( void );\n\nvoid func ( void )\n{\n    union uni *ptr_union;\n    int *ptr_int; \n    // ptr_int converted to pointer to incomplete type\n    ptr_union = ( union uni * ) ptr_int;\n    // ptr_union (incomplete type) converted to int pointer\n    ptr_int = ( int * )ptr_union;\n}",
			"details_en": "#### Abstract\nPointers to incomplete types cannot be converted to pointers of other types and vice versa \n\n#### Explanation\nType conversion operations between pointers to incomplete types may destroy the encapsulation of incomplete types, so pointers of incomplete types cannot be converted to pointers of other types.",
			"details_cn": "#### 概要\n指向不完整类型的指针与其他类型的指针不能转换，反之亦然\n\n#### 解释\n对指向不完整类型的指针进行类型转换操作可能会破坏不完整类型的封装，因此不能对不完整类型的指针转换为其他类型的指针。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nunion uni\n{\n    int i;\n    char c;\n}; // union declared\nvoid func ( void );\n\nvoid func ( void )\n{\n    union uni union_var;\n    union_var.i =1;\n    int *ptr_int;\n    // ptr_int point to union_var.i\n    ptr_int = &union_var.i;\n    ptr_int = ( void * )ptr_union; // also allowed by exception\n\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nunion uni; // incomplete type declared\nvoid func ( void );\n\nvoid func ( void )\n{\n    union uni *ptr_union;\n    int *ptr_int; \n    // ptr_int converted to pointer to incomplete type\n    ptr_union = ( union uni * ) ptr_int;\n    // ptr_union (incomplete type) converted to int pointer\n    ptr_int = ( int * )ptr_union;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629174794072"
	},
	{
		"name": "No casting between pointers of different types",
		"code": "MSR_11_3",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "11.3",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, pointers are cast to pointers of other types",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中指针被转换为其他类型的指针",
			"code": "MSR_11_3",
			"override": "T",
			"master_id": "2030",
			"name": "No casting between pointers of different types",
			"name_cn": "不同类型的指针之间不能相互转换",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "Pointers cannot be cast to pointers of other types",
			"desc_cn": "不能将指针转换为其他类型的指针",
			"abstract": "Pointers cannot be cast to pointers of other types",
			"explanation": "Casting one type of pointer to another type of pointer may be incorrectly aligned causing undefined behavior, so you cannot convert pointers to other types of pointers.",
			"abstract_cn": "不能将指针转换为其他类型的指针",
			"explanation_cn": "将指向一种类型的指针转换为另一种类型的指针可能会导致对齐错误以及未定义的行为，因此不能将指针转换为其他类型的指针。",
			"example_good": "///c:\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    int *ptr_int;    // pointer to int declared\n    char *ptr_char;  // pointer to char declared\n    *ptr_char = NULL;\n    *ptr_int = NULL; // pointers point to null\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    int *ptr_int;                 // pointer to int declared\n    char *ptr_char;               // pointer to char declared\n    ptr_int = ( int * ) ptr_char; // convert to int type pointer\n}",
			"details_en": "#### Abstract\nPointers cannot be cast to pointers of other types\n\n#### Explanation\nCasting one type of pointer to another type of pointer may be incorrectly aligned causing undefined behavior, so you cannot convert pointers to other types of pointers.",
			"details_cn": "#### 概要\n不能将指针转换为其他类型的指针\n\n#### 解释\n将指向一种类型的指针转换为另一种类型的指针可能会导致对齐错误以及未定义的行为，因此不能将指针转换为其他类型的指针。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    int *ptr_int;    // pointer to int declared\n    char *ptr_char;  // pointer to char declared\n    *ptr_char = NULL;\n    *ptr_int = NULL; // pointers point to null\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    int *ptr_int;                 // pointer to int declared\n    char *ptr_char;               // pointer to char declared\n    ptr_int = ( int * ) ptr_char; // convert to int type pointer\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629174851321"
	},
	{
		"name": "No conversion of int type to pointer",
		"code": "MSR_11_4",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "M5-2-9",
			"misra_c": "11.4",
			"misra_cpp": "5-2-9",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, there is conversion between pointers and integers",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中出现指针和整数相互转换",
			"code": "MSR_11_4",
			"override": "T",
			"master_id": "2031",
			"name": "No conversion of int type to pointer",
			"name_cn": "避免指针和整数相互转换",
			"severity": "H",
			"compliance": "A",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "Avoid the conversion between pointers and integers",
			"desc_cn": "避免指针和整数相互转换",
			"abstract": "Avoid the conversion between pointers and integers",
			"explanation": "Implementing the conversion between pointers and integers may result in data overflow of the integers or mis-alignment of the pointers. Avoid conversion between pointers and integers as much as possible.",
			"abstract_cn": "避免指针和整形的相互转换",
			"explanation_cn": "在实现指针和整形的转换可能会导致整形的数据溢出或者指针无法正常对齐，因此尽可能避免指针和整形的相互转换。",
			"example_good": "///c:\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    int *ptr_int;\n    int int_a, int_b;\n    int_a = 1;\n    ptr_int = &int_a; // ptr_int point to int_a\n    int_b = *ptr_int; // *ptr_int assigned to int_b\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    int *ptr_int;\n    int int_a, int_b;\n    int_a = 1;\n    ptr_int = ( int * ) int_a; // convert int to pointer\n    int_b = ( int ) ptr_int;   // convert pointer to type int\n}",
			"details_en": "#### Abstract\nAvoid the conversion between pointers and integers\n\n#### Explanation\nImplementing the conversion between pointers and integers may result in data overflow of the integers or mis-alignment of the pointers. Avoid conversion between pointers and integers as much as possible.",
			"details_cn": "#### 概要\n避免指针和整形的相互转换\n\n#### 解释\n在实现指针和整形的转换可能会导致整形的数据溢出或者指针无法正常对齐，因此尽可能避免指针和整形的相互转换。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    int *ptr_int;\n    int int_a, int_b;\n    int_a = 1;\n    ptr_int = &int_a; // ptr_int point to int_a\n    int_b = *ptr_int; // *ptr_int assigned to int_b\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    int *ptr_int;\n    int int_a, int_b;\n    int_a = 1;\n    ptr_int = ( int * ) int_a; // convert int to pointer\n    int_b = ( int ) ptr_int;   // convert pointer to type int\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629174903243"
	},
	{
		"name": "No conversion from pointers to void into pointer to object",
		"code": "MSR_11_5",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "M5-2-8",
			"misra_c": "11.5",
			"misra_cpp": "5-2-8",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, null pointers are coverted to pointers to objects",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中出现将空类型指针转换为指向其他对象的指针",
			"code": "MSR_11_5",
			"override": "T",
			"master_id": "2032",
			"name": "No conversion from pointers to void into pointer to object",
			"name_cn": "避免将空类型指针转换为指向其他对象的指针",
			"severity": "H",
			"compliance": "A",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "Avoid converting null pointers to pointers to objects",
			"desc_cn": "避免将空类型指针转换为指向其他对象的指针",
			"abstract": "Avoid converting null pointers to pointers to objects",
			"explanation": "In order to avoid pointer errors that may occur during type conversion, you should avoid converting null type pointers to pointers to objects. This can result in an undefined behavior. ",
			"abstract_cn": "避免将空类型指针转换为指向其他对象的指针",
			"explanation_cn": "为了避免类型转换中可能会出现的指针对其的错误，应该避免将空类型指针转换为指向其他对象的指针。",
			"example_good": "///c:\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    void *ptr_void; // void pointer declared\n    int *ptr_int;   // int pointer declared\n    int int_var;\n    ptr_int = &int_var;\n    // convert int pointer into void pointer\n    ptr_void = ( void * ) ptr_int;\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    void *ptr_void; // void pointer declared\n    int *ptr_int;   // int pointer declared\n    int int_var;\n    ptr_void = &int_var;\n    // convert void pointer into int pointer\n    ptr_int = ( int * ) ptr_void;\n}",
			"details_en": "#### Abstract\nAvoid converting null pointers to pointers to objects\n\n#### Explanation\nIn order to avoid pointer errors that may occur during type conversion, you should avoid converting null type pointers to pointers to objects. This can result in an undefined behavior. ",
			"details_cn": "#### 概要\n避免将空类型指针转换为指向其他对象的指针\n\n#### 解释\n为了避免类型转换中可能会出现的指针对其的错误，应该避免将空类型指针转换为指向其他对象的指针。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    void *ptr_void; // void pointer declared\n    int *ptr_int;   // int pointer declared\n    int int_var;\n    ptr_int = &int_var;\n    // convert int pointer into void pointer\n    ptr_void = ( void * ) ptr_int;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    void *ptr_void; // void pointer declared\n    int *ptr_int;   // int pointer declared\n    int int_var;\n    ptr_void = &int_var;\n    // convert void pointer into int pointer\n    ptr_int = ( int * ) ptr_void;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629174951145"
	},
	{
		"name": "No casting between a void pointer and an arithmatic type",
		"code": "MSR_11_6",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "11.6",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, there is null type pointer and arithmetic type conversion",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中出现空类型指针以及算术类型的转换",
			"code": "MSR_11_6",
			"override": "T",
			"master_id": "2033",
			"name": "No casting between a void pointer and an arithmatic type",
			"name_cn": "避免空指针和算术类型之间的转换",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "Cannot perform a null type pointer and arithmetic type conversion",
			"desc_cn": "不能进行空类型指针以及算术类型的转换",
			"abstract": "Cannot perform a null type pointer and arithmetic type conversion",
			"explanation": "During data conversion, data type conversion between null pointers and arithmetic types may cause unalignment with undefined behavior during data conversion.",
			"abstract_cn": "不能进行空类型指针以及算术类型的转换",
			"explanation_cn": "对空类型指针和算术类型相互的数据类型转换可能会引起对齐问题以及数据转换中出现未定义行为。",
			"example_good": "///c:\n#include <stdio.h>\n\n#define ZERO 0\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    void *ptr_void;\n    int int_var;\n    // ptr_void point to the address of int_var\n    ptr_void = &int_var;\n    ptr_void = (void *)ZERO;\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    void *ptr_void;\n    int int_var;\n    // convert int_var to void pointer\n    ptr_void = ( void * ) int_var;\n}",
			"details_en": "#### Abstract\nCannot perform a null type pointer and arithmetic type conversion\n\n#### Explanation\nDuring data conversion, data type conversion between null pointers and arithmetic types may cause unalignment with undefined behavior during data conversion.",
			"details_cn": "#### 概要\n不能进行空类型指针以及算术类型的转换\n\n#### 解释\n对空类型指针和算术类型相互的数据类型转换可能会引起对齐问题以及数据转换中出现未定义行为。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\n#define ZERO 0\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    void *ptr_void;\n    int int_var;\n    // ptr_void point to the address of int_var\n    ptr_void = &int_var;\n    ptr_void = (void *)ZERO;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    void *ptr_void;\n    int int_var;\n    // convert int_var to void pointer\n    ptr_void = ( void * ) int_var;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629175010532"
	},
	{
		"name": "No casting between void pointer and a non-int arithmatic type",
		"code": "MSR_11_7",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "11.7",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, there is casting between pointers to objects and non-integer arithmetic types",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中出现指向对象的指针与非整形的算术类型的转换",
			"code": "MSR_11_7",
			"override": "T",
			"master_id": "2034",
			"name": "No casting between void pointer and a non-int arithmatic type",
			"name_cn": "不能进行指向对象的指针与非整形的算术类型的转换",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "Cannot cast pointers to objects and non-integer arithmetic types",
			"desc_cn": "不能进行指向对象的指针与非整形的算术类型的转换",
			"abstract": "Cannot cast pointers to objects and non-integer arithmetic types",
			"explanation": "In order to prevent undefined behavior during the type conversion process, the data type conversion between the pointer to the object and the non-integer arithmetic is not allowed. ",
			"abstract_cn": "不能进行指向对象的指针与非整形的算术类型的转换",
			"explanation_cn": "为了防止在类型转换过程中出现未定义行为，不应进行指向对象的指针与非整形算术类型的相互数据类型转换。",
			"example_good": "///c:\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    char char_a, char_b;\n    char *ptr_char;\n    char_a = ",
			"example_bad": "///c:\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    char char_a, char_b;\n    char *ptr_char;\n    char_a = ",
			"details_en": "#### Abstract\nCannot cast pointers to objects and non-integer arithmetic types\n\n#### Explanation\nIn order to prevent undefined behavior during the type conversion process, the data type conversion between the pointer to the object and the non-integer arithmetic is not allowed. ",
			"details_cn": "#### 概要\n不能进行指向对象的指针与非整形的算术类型的转换\n\n#### 解释\n为了防止在类型转换过程中出现未定义行为，不应进行指向对象的指针与非整形算术类型的相互数据类型转换。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    char char_a, char_b;\n    char *ptr_char;\n    char_a = "
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    char char_a, char_b;\n    char *ptr_char;\n    char_a = "
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629175078109"
	},
	{
		"name": "Const or volatile pointers to pointed should not be cast away ",
		"code": "MSR_11_8",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "A5-2-3",
			"misra_c": "11.8",
			"misra_cpp": "5-2-5",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, pointer data type cast removes const or volatile qualifiers",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中，指针的数据类型转换去除了const和volatile限定符",
			"code": "MSR_11_8",
			"override": "T",
			"master_id": "2035",
			"name": "Const or volatile pointers to pointed should not be cast away ",
			"name_cn": "指针的数据类型转换不能去除const和volatile限定符",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "Pointer data type cast cannot remove const or volatile qualifiers",
			"desc_cn": "指针的数据类型转换不能去除const和volatile限定符",
			"abstract": "Pointer data type cast cannot remove const or volatile qualifiers",
			"explanation": "The const and volatile qualifiers in the definition cannot be removed when the pointer data type is converted. This may cause errors in the reading and writing process of the pointer.",
			"abstract_cn": "指针的数据类型转换不能去除const和volatile限定符",
			"explanation_cn": "在进行指针的数据类型转换时不能去除定义中的const和volatile限定符，否则可能导致该指针的读写过程出现错误。",
			"example_good": "///c:\n#include <stdio.h>\n#include <malloc.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    // const pointer declared\n    int * const ptr_const = ( int *) malloc ( sizeof ( int ) );\n    int *ptr_int;\n    // ptr_int point to the address of ptr_const\n    ptr_int = ptr_const;\n    // more code that may change ptr_const\n    // ...\n    \n}",
			"example_bad": "///c:\n#include <stdio.h>\n#include <malloc.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    volatile int *p_volatile;\n    // pointer to const declared\n    const int * ptr_const = ( int *) malloc ( sizeof ( int ) );\n    int *ptr_int;\n    // const qualifier removed in a cast\n    ptr_int = ( int * ) ptr_const;\n    ptr_int = (int *) p_volatile;\n    // more code that may change ptr_const\n    // ...\n    \n}",
			"details_en": "#### Abstract\nPointer data type cast cannot remove const or volatile qualifiers\n\n#### Explanation\nThe const and volatile qualifiers in the definition cannot be removed when the pointer data type is converted. This may cause errors in the reading and writing process of the pointer.",
			"details_cn": "#### 概要\n指针的数据类型转换不能去除const和volatile限定符\n\n#### 解释\n在进行指针的数据类型转换时不能去除定义中的const和volatile限定符，否则可能导致该指针的读写过程出现错误。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n#include <malloc.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    // const pointer declared\n    int * const ptr_const = ( int *) malloc ( sizeof ( int ) );\n    int *ptr_int;\n    // ptr_int point to the address of ptr_const\n    ptr_int = ptr_const;\n    // more code that may change ptr_const\n    // ...\n    \n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n#include <malloc.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    volatile int *p_volatile;\n    // pointer to const declared\n    const int * ptr_const = ( int *) malloc ( sizeof ( int ) );\n    int *ptr_int;\n    // const qualifier removed in a cast\n    ptr_int = ( int * ) ptr_const;\n    ptr_int = (int *) p_volatile;\n    // more code that may change ptr_const\n    // ...\n    \n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629175130038"
	},
	{
		"name": "int null pointer const must be the NULL macro",
		"code": "MSR_11_9",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "M4-10-2",
			"misra_c": "11.9",
			"misra_cpp": "4-10-2",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, a null integer pointer not only points to the macro NULL",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中空的整形指针不只能指向宏定义NULL",
			"code": "MSR_11_9",
			"override": "T",
			"master_id": "2036",
			"name": "int null pointer const must be the NULL macro",
			"name_cn": "空的整形指针只能指向宏定义NULL",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "A null integer pointer can only point to the macro NULL",
			"desc_cn": "空的整形指针只能指向宏定义NULL",
			"abstract": "A null integer pointer can only point to the macro NULL",
			"explanation": "An integer constant expression with the value 0 should be derived from expansion of the macro NULL if it appears as the value being assigned to a pointer or an operand of equal/not-equal, or operand of a trigraph.",
			"abstract_cn": "空的整形指针只能指向宏定义NULL",
			"explanation_cn": "在向指针赋值，或使用指针作为等于、不等于或者三目运算符时，应能用宏定义NULL表示空的整形。",
			"example_good": "///c:\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    int *int_ptr = NULL; // ptr_int point to NULL\n    // NULL appear as an operand with the other operand a pointer\n    if ( int_ptr != (int *)NULL )\n    {\n        *int_ptr = NULL;\n    }\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    int *int_ptr = 0; // 0 assigned to ptr_int\n    // 0 appear as an operand with the other operand a pointer\n    if ( int_ptr != 0 )\n    {\n        *int_ptr = NULL;\n    }\n}",
			"details_en": "#### Abstract\nA null integer pointer can only point to the macro NULL\n\n#### Explanation\nAn integer constant expression with the value 0 should be derived from expansion of the macro NULL if it appears as the value being assigned to a pointer or an operand of equal/not-equal, or operand of a trigraph.",
			"details_cn": "#### 概要\n空的整形指针只能指向宏定义NULL\n\n#### 解释\n在向指针赋值，或使用指针作为等于、不等于或者三目运算符时，应能用宏定义NULL表示空的整形。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    int *int_ptr = NULL; // ptr_int point to NULL\n    // NULL appear as an operand with the other operand a pointer\n    if ( int_ptr != (int *)NULL )\n    {\n        *int_ptr = NULL;\n    }\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    int *int_ptr = 0; // 0 assigned to ptr_int\n    // 0 appear as an operand with the other operand a pointer\n    if ( int_ptr != 0 )\n    {\n        *int_ptr = NULL;\n    }\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629175190976"
	},
	{
		"name": "Shift amount of shift operator must be smaller than the bit size of operand",
		"code": "MSR_12_2",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "M5-8-1",
			"misra_c": "12.2",
			"misra_cpp": "5-8-1",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the right operand of the shift operator is not taken from zero to one less than the number of bits in the left operand",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中，位移运算符的右操作数不是从零到左操作数的位数中取值",
			"code": "MSR_12_2",
			"override": "T",
			"master_id": "2037",
			"name": "Shift amount of shift operator must be smaller than the bit size of operand",
			"name_cn": "移位运算符的移位量必须小于操作数的位数",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "The right operand of the shift operator should be taken from zero to one less than the number of bits in the left operand",
			"desc_cn": "位移运算符的右操作数应该从零到左操作数的位数中取值",
			"abstract": "The right operand of the shift operator should be taken from zero to one less than the number of bits in the left operand",
			"explanation": "The right operand of the shift operator should be a positive integer, the value range is from zero to one less than the number of digits in the left operand. Any value beyond this range will cause undefined behavior.",
			"abstract_cn": "位移运算符的右操作数应该从零到左操作数的位数中取取值",
			"explanation_cn": "位移运算符的右操作数应该为一个正整数，取值范围为零到左操作数的位数，取超出该范围的值为未定义的行为。",
			"example_good": "///c:\n#include <stdint.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    uint16_t uint16_var = 2;\n    uint32_t uint32_var;\n    // 17 is in the range 0 to the size of uint16_var\n    uint32_var = uint32_var << 17;\n}",
			"example_bad": "///c:\n#include <stdint.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    uint16_t uint16_var = 2;\n    // 17 is bigger than the size of uint16_var\n    uint16_var = uint16_var << 17;\n}",
			"details_en": "#### Abstract\nThe right operand of the shift operator should be taken from zero to one less than the number of bits in the left operand\n\n#### Explanation\nThe right operand of the shift operator should be a positive integer, the value range is from zero to one less than the number of digits in the left operand. Any value beyond this range will cause undefined behavior.",
			"details_cn": "#### 概要\n位移运算符的右操作数应该从零到左操作数的位数中取取值\n\n#### 解释\n位移运算符的右操作数应该为一个正整数，取值范围为零到左操作数的位数，取超出该范围的值为未定义的行为。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdint.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    uint16_t uint16_var = 2;\n    uint32_t uint32_var;\n    // 17 is in the range 0 to the size of uint16_var\n    uint32_var = uint32_var << 17;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdint.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    uint16_t uint16_var = 2;\n    // 17 is bigger than the size of uint16_var\n    uint16_var = uint16_var << 17;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629175249070"
	},
	{
		"name": "Comma operator not allowed",
		"code": "MSR_12_3",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "M5-18-1",
			"misra_c": "12.3",
			"misra_cpp": "5-18-1",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the comma operator is used",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中使用了逗号运算符",
			"code": "MSR_12_3",
			"override": "T",
			"master_id": "2038",
			"name": "Comma operator not allowed",
			"name_cn": "不允许使用逗号运算符",
			"severity": "H",
			"compliance": "A",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "Try not to use the comma operator",
			"desc_cn": "尽量不使用逗号运算符",
			"abstract": "Try not to use the comma operator",
			"explanation": "Since using the comma operator will reduce the readability of the code, try to avoid using the comma operator.",
			"abstract_cn": "尽量不使用逗号运算符",
			"explanation_cn": "由于使用逗号运算符会降低代码的可读性，因此要尽量避免使用逗号运算符。",
			"example_good": "///c:\n#include <stdint.h>\n\nstatic char a[ 10 ];\nvoid func ( void );\n\nvoid func ( void )\n{\n    int i;\n    char *p;\n    // same effect achieved by other mean\n    p = &a[ 0 ];\n    for ( i = 0; i < 10 ; ++i)\n    {\n        *p++ = i;\n    }\n}",
			"example_bad": "///c:\n#include <stdint.h>\n\nstatic char a[ 10 ];\nvoid func ( void );\n\nvoid func ( void )\n{\n    int i;\n    char *p;\n    // comma operator hard the readability of code\n    for ( i = 0, p = &a[ 0 ]; i < 10 ; ++i, *p++ = i);\n}",
			"details_en": "#### Abstract\nTry not to use the comma operator\n\n#### Explanation\nSince using the comma operator will reduce the readability of the code, try to avoid using the comma operator.",
			"details_cn": "#### 概要\n尽量不使用逗号运算符\n\n#### 解释\n由于使用逗号运算符会降低代码的可读性，因此要尽量避免使用逗号运算符。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdint.h>\n\nstatic char a[ 10 ];\nvoid func ( void );\n\nvoid func ( void )\n{\n    int i;\n    char *p;\n    // same effect achieved by other mean\n    p = &a[ 0 ];\n    for ( i = 0; i < 10 ; ++i)\n    {\n        *p++ = i;\n    }\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdint.h>\n\nstatic char a[ 10 ];\nvoid func ( void );\n\nvoid func ( void )\n{\n    int i;\n    char *p;\n    // comma operator hard the readability of code\n    for ( i = 0, p = &a[ 0 ]; i < 10 ; ++i, *p++ = i);\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629175306920"
	},
	{
		"name": "Const expression should not cause unsigned wrap-around",
		"code": "MSR_12_4",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "M5-19-1",
			"misra_c": "12.4",
			"misra_cpp": "5-19-1",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, a constant expression causes an unsigned integer wrap-around",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中，无符号整形常量表达式的值导致了回绕",
			"code": "MSR_12_4",
			"override": "T",
			"master_id": "2039",
			"name": "Const expression should not cause unsigned wrap-around",
			"name_cn": "无符号整形常量表达式的值不能导致回绕",
			"severity": "H",
			"compliance": "A",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "A constant expression should not cause an unsigned integer wrap-around",
			"desc_cn": "无符号整形常量表达式的值不能导致回绕",
			"abstract": "A constant expression should not cause an unsigned integer wrap-around",
			"explanation": "To prevent wrap-around, the value range of the unsigned integer constant expression should be in the range of zero to the maximum value that the unsigned integer can represent.",
			"abstract_cn": "无符号整形常量表达式的值不能导致回绕",
			"explanation_cn": "为防止发生回绕，因此无符号整形常量表达式的值的取值范围应为零到无符号整形能表示的最大值。",
			"example_good": "///c:\n#include <stdio.h>\n\n#define MAXIMUM 0xffffffffu // maximum value of unsigned int\n\nconst unsigned int const_int = 1;\nvoid func( void );\n\nvoid func( void )\n{\n    unsigned int uint_var;\n    // 0xffffffff assigned to long_long_var\n    uint_var = MAXIMUM;\n    // uint_var + 1 and uint_var + const_int is not a constant expression\n    uint_var = uint_var + 1;\n    uint_var = uint_var + const_int;\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\n#define MAXIMUM 0xffffffffu // value of unsigned int (assume int is 32 bits)\n#define ONE     0x1u\nvoid func( void );\n\nvoid func( void )\n{\n    unsigned int uint_var;\n    // the value of MAXIMUM + 1 lead to wrap-around\n    uint_var = MAXIMUM + ONE;\n}",
			"details_en": "#### Abstract\nA constant expression should not cause an unsigned integer wrap-around\n\n#### Explanation\nTo prevent wrap-around, the value range of the unsigned integer constant expression should be in the range of zero to the maximum value that the unsigned integer can represent.",
			"details_cn": "#### 概要\n无符号整形常量表达式的值不能导致回绕\n\n#### 解释\n为防止发生回绕，因此无符号整形常量表达式的值的取值范围应为零到无符号整形能表示的最大值。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\n#define MAXIMUM 0xffffffffu // maximum value of unsigned int\n\nconst unsigned int const_int = 1;\nvoid func( void );\n\nvoid func( void )\n{\n    unsigned int uint_var;\n    // 0xffffffff assigned to long_long_var\n    uint_var = MAXIMUM;\n    // uint_var + 1 and uint_var + const_int is not a constant expression\n    uint_var = uint_var + 1;\n    uint_var = uint_var + const_int;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\n#define MAXIMUM 0xffffffffu // value of unsigned int (assume int is 32 bits)\n#define ONE     0x1u\nvoid func( void );\n\nvoid func( void )\n{\n    unsigned int uint_var;\n    // the value of MAXIMUM + 1 lead to wrap-around\n    uint_var = MAXIMUM + ONE;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629175363869"
	},
	{
		"name": "Initializer lists should not contain persistent side effects",
		"code": "MSR_13_1",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "13.1",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the initialization list has side effects",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中，初始化列表产生了副作用",
			"code": "MSR_13_1",
			"override": "T",
			"master_id": "2040",
			"name": "Initializer lists should not contain persistent side effects",
			"name_cn": "初始化列表不应含有持久的副作用",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "The initialization list should not have side effects",
			"desc_cn": "初始化列表不应该产生副作用",
			"abstract": "The initialization list should not have side effects",
			"explanation": "In order to avoid causing errors in the initialization content and side effects affecting the operation of the program, operations that produce side effects such as assigning other parameters to other parameters, should not be performed in the initialization list.",
			"abstract_cn": "初始化列表不应该产生副作用",
			"explanation_cn": "为避免导致初始化的内容出现错误以及副作用影响程序运行，不应该在初始化列表中进行对其他参数赋值等产生副作用的操作。",
			"example_good": "///c:\n#include <stdio.h>\n\nvoid func( void );\n\nvoid func( void )\n{\n    int x = 0;\n    // array initialized with no side effect\n    int arr[2] = { 1, 2 };\n    // more code may call x\n    // ...\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nvoid func( void );\n\nvoid func( void )\n{\n    int x = 0;\n    // object x modified due to side effect\n    int arr[2] = { ++x, ++x };\n    // more code may call x\n    // ...\n}",
			"details_en": "#### Abstract\nThe initialization list should not have side effects\n\n#### Explanation\nIn order to avoid causing errors in the initialization content and side effects affecting the operation of the program, operations that produce side effects such as assigning other parameters to other parameters, should not be performed in the initialization list.",
			"details_cn": "#### 概要\n初始化列表不应该产生副作用\n\n#### 解释\n为避免导致初始化的内容出现错误以及副作用影响程序运行，不应该在初始化列表中进行对其他参数赋值等产生副作用的操作。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func( void );\n\nvoid func( void )\n{\n    int x = 0;\n    // array initialized with no side effect\n    int arr[2] = { 1, 2 };\n    // more code may call x\n    // ...\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func( void );\n\nvoid func( void )\n{\n    int x = 0;\n    // object x modified due to side effect\n    int arr[2] = { ++x, ++x };\n    // more code may call x\n    // ...\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629175419977"
	},
	{
		"name": "Persistent side effect expressions should be the same",
		"code": "MSR_13_2",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "13.2",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, the value of ${so.func} is not deterministic in all possible execution orders.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，表达式${so.func}的值在所有可能的运行顺序下不是唯一确定的。",
			"code": "MSR_13_2",
			"override": "T",
			"master_id": "2041",
			"name": "Persistent side effect expressions should be the same",
			"name_cn": "持久副作用表达式应相同 ",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "The values and side effects of all expressions in the execution order must be the same",
			"desc_cn": "所有执行顺序下表达式的值及副作用一致",
			"abstract": "The values and side effects of all expressions in the execution order must be the same",
			"explanation": "Since the expression may have multiple execution orders, the design expression should ensure that the value of the expression and its side effects are the same in all possible execution orders.",
			"abstract_cn": "所有执行顺序下表达式的值及副作用一致",
			"explanation_cn": "由于表达式可能存在多种执行的顺序，设计表达式应该保证在所有可能的执行顺序下表达式的值以及其副作用都相同。",
			"example_good": "///c:\n#include <stdio.h>\n\nint func( void );\n\nint func( void )\n{\n    int a = 6;\n    // the value will sure to be -60\n    a -= a*a;\n    a += a;\n    return a;\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nint func( void );\n\nint func( void )\n{\n    int a = 6;\n\n    a += a -= a*a;\n    return a;\n}",
			"details_en": "#### Abstract\nThe values and side effects of all expressions in the execution order must be the same\n\n#### Explanation\nSince the expression may have multiple execution orders, the design expression should ensure that the value of the expression and its side effects are the same in all possible execution orders.",
			"details_cn": "#### 概要\n所有执行顺序下表达式的值及副作用一致\n\n#### 解释\n由于表达式可能存在多种执行的顺序，设计表达式应该保证在所有可能的执行顺序下表达式的值以及其副作用都相同。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nint func( void );\n\nint func( void )\n{\n    int a = 6;\n    // the value will sure to be -60\n    a -= a*a;\n    a += a;\n    return a;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nint func( void );\n\nint func( void )\n{\n    int a = 6;\n\n    a += a -= a*a;\n    return a;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629175499543"
	},
	{
		"name": "Side effect free expr (except ++, --)",
		"code": "MSR_13_3",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "M5-2-10",
			"misra_c": "13.3",
			"misra_cpp": "5-2-10",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the increment (++) or decrement (--) operators have additional side effects",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中，增减量运算符出现额外的副作用",
			"code": "MSR_13_3",
			"override": "T",
			"master_id": "2042",
			"name": "Side effect free expr (except ++, --)",
			"name_cn": "增减量运算符无副作用",
			"severity": "H",
			"compliance": "A",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "The increment (++) or decrement (--) operators cannot have additional side effects",
			"desc_cn": "增减量运算符不能有额外的副作用",
			"abstract": "The increment (++) or decrement (--) operators cannot have additional side effects",
			"explanation": "Avoid mixing increment or decrement operators with other operators in expressions, including function calls, as this will cause an undefined behavior. Doing so will impair readability of the code.",
			"abstract_cn": "增减量运算符不能有额外的副作用",
			"explanation_cn": "避免混合使用增量或减量运算符与其他运算符，包括函数调用，否则可能损害程序可读性。",
			"example_good": "///c:\n#include <stdio.h>\n\nint func( void );\n\nint func( void )\n{\n    int int_a, int_b, int_c;\n    int_a = int_b = 1;\n    // make the code more readable by this mean\n    ++int_a;\n    int_c = int_a * int_b;\n    int_b--;\n    return int_c;\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nint func( void );\n\nint func( void )\n{\n    int int_a, int_b, int_c;\n    int_a = int_b = 1;\n    // the complex expression impairs the readability\n    int_c = ++int_a * int_b--;\n    return int_c;\n}",
			"details_en": "#### Abstract\nThe increment (++) or decrement (--) operators cannot have additional side effects\n\n#### Explanation\nAvoid mixing increment or decrement operators with other operators in expressions, including function calls, as this will cause an undefined behavior. Doing so will impair readability of the code.",
			"details_cn": "#### 概要\n增减量运算符不能有额外的副作用\n\n#### 解释\n避免混合使用增量或减量运算符与其他运算符，包括函数调用，否则可能损害程序可读性。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nint func( void );\n\nint func( void )\n{\n    int int_a, int_b, int_c;\n    int_a = int_b = 1;\n    // make the code more readable by this mean\n    ++int_a;\n    int_c = int_a * int_b;\n    int_b--;\n    return int_c;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nint func( void );\n\nint func( void )\n{\n    int int_a, int_b, int_c;\n    int_a = int_b = 1;\n    // the complex expression impairs the readability\n    int_c = ++int_a * int_b--;\n    return int_c;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629175577169"
	},
	{
		"name": "Assign operators inside an expression ",
		"code": "MSR_13_4",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "13.4",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the result of the assignment operator is used",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中赋值运算符的结果被使用",
			"code": "MSR_13_4",
			"override": "T",
			"master_id": "2043",
			"name": "Assign operators inside an expression ",
			"name_cn": "在表达式中分配运算符",
			"severity": "H",
			"compliance": "A",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "The result of the assignment operator cannot be used",
			"desc_cn": "赋值运算符的结果不能被使用",
			"abstract": "The result of the assignment operator cannot be used",
			"explanation": "The result of the assignment operator should not be used since it introduces additional side-effects. Doing so also impairs readability of the code.",
			"abstract_cn": "赋值运算符的结果不能被使用",
			"explanation_cn": "由于会引入额外的副作用，赋值运算符的结果不能被作为一个值使用，否则会损害程序可读性。",
			"example_good": "///c:\n#include <stdio.h>\n\nvoid func( void );\n\nvoid func( void )\n{\n    bool bool_var;\n    bool_var = true;\n    // == is not an assignment operator\n    while (bool_var == true)\n    {\n        // some code that change bool_var\n        // ...\n    }\n    \n}",
			"example_bad": "///c:\nint func(int x, int y)\n{\n  int ret_var;\n  ret_var = 1;\n\n  while (0) {\n    // ...\n    if (x = 0) {  // typical typo interpreted as an assignment\n      ret_var = x = y; // non-compliant\n    }\n  }\n  return ret_var;\n}",
			"details_en": "#### Abstract\nThe result of the assignment operator cannot be used\n\n#### Explanation\nThe result of the assignment operator should not be used since it introduces additional side-effects. Doing so also impairs readability of the code.",
			"details_cn": "#### 概要\n赋值运算符的结果不能被使用\n\n#### 解释\n由于会引入额外的副作用，赋值运算符的结果不能被作为一个值使用，否则会损害程序可读性。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func( void );\n\nvoid func( void )\n{\n    bool bool_var;\n    bool_var = true;\n    // == is not an assignment operator\n    while (bool_var == true)\n    {\n        // some code that change bool_var\n        // ...\n    }\n    \n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nint func(int x, int y)\n{\n  int ret_var;\n  ret_var = 1;\n\n  while (0) {\n    // ...\n    if (x = 0) {  // typical typo interpreted as an assignment\n      ret_var = x = y; // non-compliant\n    }\n  }\n  return ret_var;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629175662250"
	},
	{
		"name": "The right operand of the && and || operators should not contain persist side effect",
		"code": "MSR_13_5",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the right operand of the && and || operators have side effects",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中，&&和||运算符的右操作数有副作用",
			"code": "MSR_13_5",
			"override": "T",
			"master_id": "2044",
			"name": "The right operand of the && and || operators should not contain persist side effect",
			"name_cn": "&&和||运算符的右操作数不应该有副作用",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "The right operand of the && and || operators cannot have side effects",
			"desc_cn": "&&和||运算符的右操作数不能有副作用",
			"abstract": "The right operand of the && and || operators cannot have side effects",
			"explanation": "The evaluation of the right hand operand of the && and || operators is conditional on the value of the left-hand operand. The right hand operand",
			"abstract_cn": "&&和||运算符的右操作数不能有副作用",
			"explanation_cn": "为了防止右操作数不执行导致应有的副作用没有产生，&&和||运算符的右操作数不能产生副作用。",
			"example_good": "///c:\n#include <stdio.h>\n\nstatic int int_a;\nvoid func( void );\nint func2( void );\nbool return_true( void );\n\nvoid func( void )\n{\n    int int_b;\n    \n    // right operand do not have side effect\n    if( return_true() || int_b == func2() );\n    // more code that may read int_a\n    // ...\n}\n\nint func2( void )\n{\n    return int_a + 1; // do not have side effect\n}\n\nbool return_true( void )\n{\n    return true;\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nstatic int int_a;\nvoid func( void );\nint func2( void );\nbool return_true( void );\n\nvoid func( void )\n{\n    int int_b;\n    \n    // int_a is not modified as intended\n    if( return_true() || int_b == func2() );\n    // more code that may read int_a\n    // ...\n}\n\nint func2( void )\n{\n    int_a++; // side effect: int_a is modified\n    return int_a;\n}\n\nbool return_true( void )\n{\n    return true;\n}",
			"details_en": "#### Abstract\nThe right operand of the && and || operators cannot have side effects\n\n#### Explanation\nThe evaluation of the right hand operand of the && and || operators is conditional on the value of the left-hand operand. The right hand operand",
			"details_cn": "#### 概要\n&&和||运算符的右操作数不能有副作用\n\n#### 解释\n为了防止右操作数不执行导致应有的副作用没有产生，&&和||运算符的右操作数不能产生副作用。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nstatic int int_a;\nvoid func( void );\nint func2( void );\nbool return_true( void );\n\nvoid func( void )\n{\n    int int_b;\n    \n    // right operand do not have side effect\n    if( return_true() || int_b == func2() );\n    // more code that may read int_a\n    // ...\n}\n\nint func2( void )\n{\n    return int_a + 1; // do not have side effect\n}\n\nbool return_true( void )\n{\n    return true;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nstatic int int_a;\nvoid func( void );\nint func2( void );\nbool return_true( void );\n\nvoid func( void )\n{\n    int int_b;\n    \n    // int_a is not modified as intended\n    if( return_true() || int_b == func2() );\n    // more code that may read int_a\n    // ...\n}\n\nint func2( void )\n{\n    int_a++; // side effect: int_a is modified\n    return int_a;\n}\n\nbool return_true( void )\n{\n    return true;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629175733195"
	},
	{
		"name": "The operand of sizeof operator should not have potential side effects",
		"code": "MSR_13_6",
		"rules": {
			"category": "",
			"mapping": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the operand of sizeof operator has persistent side effects",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中，sizeof的操作数有持续的副作用",
			"code": "MSR_13_6",
			"override": "T",
			"master_id": "2045",
			"name": "The operand of sizeof operator should not have potential side effects",
			"name_cn": "sizeof 运算符的操作数不应有潜在的副作用",
			"severity": "H",
			"compliance": "M",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "The operand of sizeof operator cannot have persistent side effects",
			"desc_cn": "sizeof的操作数不能有持续的副作用",
			"abstract": "The operand of sizeof operator cannot have persistent side effects",
			"explanation": "Since sizeof operator does not necessarily execute the expression in its operand, the operand of sizeof must not produce side effects.",
			"abstract_cn": "sizeof的操作数不能有持续的副作用",
			"explanation_cn": "由于sizeof不一定会执行它的操作数中的表达式，sizeof的操作数不能产生副作用。",
			"example_good": "///c:\n#include <stdio.h>\n\nvoid func( void );\n\nvoid func( void )\n{\n    int int_a, int_b;\n\n    // the operand do not have side effect\n    int_a = sizeof( int_b );\n    int_b++; // int_b modified as intended\n    // some code that may read int_b\n    // ...\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nvoid func( void );\n\nvoid func( void )\n{\n    int int_a, int_b;\n    \n    // int_b is not modified as intended\n    int_a = sizeof( int_b++ );\n    // some code that may read int_b\n    // ...\n}",
			"details_en": "#### Abstract\nThe operand of sizeof operator cannot have persistent side effects\n\n#### Explanation\nSince sizeof operator does not necessarily execute the expression in its operand, the operand of sizeof must not produce side effects.",
			"details_cn": "#### 概要\nsizeof的操作数不能有持续的副作用\n\n#### 解释\n由于sizeof不一定会执行它的操作数中的表达式，sizeof的操作数不能产生副作用。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func( void );\n\nvoid func( void )\n{\n    int int_a, int_b;\n\n    // the operand do not have side effect\n    int_a = sizeof( int_b );\n    int_b++; // int_b modified as intended\n    // some code that may read int_b\n    // ...\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func( void );\n\nvoid func( void )\n{\n    int int_a, int_b;\n    \n    // int_b is not modified as intended\n    int_a = sizeof( int_b++ );\n    // some code that may read int_b\n    // ...\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629175787637"
	},
	{
		"name": "Pointer arithmatic should not be used, except for ++ and --",
		"code": "MSR_18_4",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, pointer arithmatic is used, except for ++ and --",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中，使用了除++和--之外的指针算术",
			"code": "MSR_18_4",
			"override": "T",
			"master_id": "2047",
			"name": "Pointer arithmatic should not be used, except for ++ and --",
			"name_cn": "不能使用指针算术，除了++和--",
			"severity": "L",
			"compliance": "A",
			"desc_en": "Pointer arithmatic should not be used, except for ++ and --",
			"desc_cn": "不能使用指针算术，除了++和--",
			"abstract": "Pointer arithmatic should not be used, except for ++ and --",
			"explanation": "Pointer arithmetic is confusing to the novice programmers. The expression ptr+1 may be mistakenly interpreted as adding one byte to the address held in ptr.",
			"abstract_cn": "不能使用指针算术，除了++和--",
			"explanation_cn": "指针算法会让初学者感到困惑。表达式ptr+1可能被错误地解释为向ptr中保存的地址添加一个字节",
			"example_good": "///c:\nvoid func(){\n    int arr[3] = {0, 1, 2};\n\n    int *ptr;\n    ptr = arr;\n    ptr++;  // ++ operator is allowed\n    ptr[1] = 0;\n}",
			"example_bad": "///c:\nvoid func(){\n    int arr[3] = {0, 1, 2};\n\n    int *ptr;\n    ptr = arr;\n\n    * (ptr + 1) = 0; // Using + in pointer arithmatic is confusing\n}",
			"details_en": "#### Abstract\nPointer arithmatic should not be used, except for ++ and --\n\n#### Explanation\nPointer arithmetic is confusing to the novice programmers. The expression ptr+1 may be mistakenly interpreted as adding one byte to the address held in ptr.",
			"details_cn": "#### 概要\n不能使用指针算术，除了++和--\n\n#### 解释\n指针算法会让初学者感到困惑。表达式ptr+1可能被错误地解释为向ptr中保存的地址添加一个字节",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nvoid func(){\n    int arr[3] = {0, 1, 2};\n\n    int *ptr;\n    ptr = arr;\n    ptr++;  // ++ operator is allowed\n    ptr[1] = 0;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nvoid func(){\n    int arr[3] = {0, 1, 2};\n\n    int *ptr;\n    ptr = arr;\n\n    * (ptr + 1) = 0; // Using + in pointer arithmatic is confusing\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1630563656674"
	},
	{
		"name": "Variable length array types should not be used",
		"code": "MSR_18_8",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, variable length array types are used",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中使用了可变长数组类型",
			"code": "MSR_18_8",
			"override": "T",
			"master_id": "2048",
			"name": "Variable length array types should not be used",
			"name_cn": "不得使用可变长数组类型",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "Variable length array types should not be used",
			"desc_cn": "不得使用可变长数组类型",
			"abstract": "Variable length array types should not be used",
			"explanation": "The use of variable-length array types would make it impossible to determine statically the amount of memory that must be reserved for a stack",
			"abstract_cn": "不得使用可变长数组类型",
			"explanation_cn": "使用可变长度数组类型将无法静态确定必须为堆栈保留的内存量",
			"example_good": "",
			"example_bad": "///c:\nvoid foo(int n) {\n    int arr[n];\n}\n\nvoid func() {\n    foo(-1);\n}",
			"details_en": "#### Abstract\nVariable length array types should not be used\n\n#### Explanation\nThe use of variable-length array types would make it impossible to determine statically the amount of memory that must be reserved for a stack",
			"details_cn": "#### 概要\n不得使用可变长数组类型\n\n#### 解释\n使用可变长度数组类型将无法静态确定必须为堆栈保留的内存量",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nvoid foo(int n) {\n    int arr[n];\n}\n\nvoid func() {\n    foo(-1);\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1630565545156"
	},
	{
		"name": "Union should not be used",
		"code": "MSR_19_2",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, union is used",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中使用了联合",
			"code": "MSR_19_2",
			"override": "T",
			"master_id": "2049",
			"name": "Union should not be used",
			"name_cn": "不得使用联合",
			"compliance": "A",
			"desc_en": "Union should not be used",
			"desc_cn": "不得使用联合",
			"abstract": "Union should not be used",
			"explanation": "If the union member read is wider than the member written then the value is unspecified. Since it is possible to access bytes with unspecified values, unions should not be used.",
			"abstract_cn": "不得使用联合",
			"explanation_cn": "如果读取的联合成员比写入的成员宽，则该值未指定。由于可以访问具有未指定值的字节，因此不应使用联合",
			"example_good": "///c:\n#include <stdio.h>\n#include <string.h>\n\nstruct Foo {\n    int i;\n    float f;\n    char str[10];\n};\n\nvoid func() {\n    struct Foo data;\n\n    data.i = 5;\n    data.f = 10.5;\n    strcpy(data.str, \"string\");\n\n    // Use struct instead of union to keep everything\n    printf(\"%d\\n\", data.i);\n    printf(\"%f\\n\", data.f);\n    printf(\"%s\\n\", data.str);\n}",
			"example_bad": "///c:\ntypedef union UnionT\n{\n  int    i;\n  char   c;\n  double d;\n} UNIONT;\n\ntypedef struct MyData\n{\n  int     tag;\n  UNIONT  u;\n} MYDATA;\n\n\nint foo(char ch_param)\n{\n   MYDATA md;\n\n   md.tag = 0;  // say, 0 for int, 1 for char, 2 for double\n   md.u.c = ch_param;\n\n   return md.u.i; // return is undefined\n}",
			"details_en": "#### Abstract\nUnion should not be used\n\n#### Explanation\nIf the union member read is wider than the member written then the value is unspecified. Since it is possible to access bytes with unspecified values, unions should not be used.",
			"details_cn": "#### 概要\n不得使用联合\n\n#### 解释\n如果读取的联合成员比写入的成员宽，则该值未指定。由于可以访问具有未指定值的字节，因此不应使用联合",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n#include <string.h>\n\nstruct Foo {\n    int i;\n    float f;\n    char str[10];\n};\n\nvoid func() {\n    struct Foo data;\n\n    data.i = 5;\n    data.f = 10.5;\n    strcpy(data.str, \"string\");\n\n    // Use struct instead of union to keep everything\n    printf(\"%d\\n\", data.i);\n    printf(\"%f\\n\", data.f);\n    printf(\"%s\\n\", data.str);\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\ntypedef union UnionT\n{\n  int    i;\n  char   c;\n  double d;\n} UNIONT;\n\ntypedef struct MyData\n{\n  int     tag;\n  UNIONT  u;\n} MYDATA;\n\n\nint foo(char ch_param)\n{\n   MYDATA md;\n\n   md.tag = 0;  // say, 0 for int, 1 for char, 2 for double\n   md.u.c = ch_param;\n\n   return md.u.i; // return is undefined\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1630568247278"
	},
	{
		"name": "Memory allocation related functions in stdlib.h shall not be used",
		"code": "MSR_21_3",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, memory allocation related function ${so.func} in stdlib.h is used",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中使用了stdlib.h 中的内存分配相关函数",
			"code": "MSR_21_3",
			"override": "T",
			"master_id": "2050",
			"name": "Memory allocation related functions in stdlib.h shall not be used",
			"name_cn": "不得使用 stdlib.h 中的内存分配相关函数",
			"compliance": "R",
			"desc_en": "Memory allocation related functions in stdlib.h shall not be used",
			"desc_cn": "不得使用 stdlib.h 中的内存分配相关函数",
			"abstract": "Memory allocation related functions in stdlib.h shall not be used",
			"explanation": "The use of memory allocation related functions in stdlib.h can lead to an undefined behaviour. For example:  memory that was dynamically allocated may not be freed subsequently.",
			"abstract_cn": "不得使用 stdlib.h 中的内存分配相关函数",
			"explanation_cn": "在stdlib.h中使用内存分配相关函数可能会导致未定义的行为。例如：动态分配的内存可能不会随后释放",
			"example_good": "///c:\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid func() {\n\n    #define MAX_STR_SZ 10   \n    char str[MAX_STR_SZ];\n    strncpy(str, \"string\", MAX_STR_SZ);\n    \n    strcpy(str, \"string\");\n    printf(\"%s\", str);\n}",
			"example_bad": "///c:\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid func() {\n    char *str;\n\n    str = (char *) malloc(10);\n    strcpy(str, \"string\");\n    printf(\"%s\", str);\n\n    free(str);\n}",
			"details_en": "#### Abstract\nMemory allocation related functions in stdlib.h shall not be used\n\n#### Explanation\nThe use of memory allocation related functions in stdlib.h can lead to an undefined behaviour. For example:  memory that was dynamically allocated may not be freed subsequently.",
			"details_cn": "#### 概要\n不得使用 stdlib.h 中的内存分配相关函数\n\n#### 解释\n在stdlib.h中使用内存分配相关函数可能会导致未定义的行为。例如：动态分配的内存可能不会随后释放",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid func() {\n\n    #define MAX_STR_SZ 10   \n    char str[MAX_STR_SZ];\n    strncpy(str, \"string\", MAX_STR_SZ);\n    \n    strcpy(str, \"string\");\n    printf(\"%s\", str);\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid func() {\n    char *str;\n\n    str = (char *) malloc(10);\n    strcpy(str, \"string\");\n    printf(\"%s\", str);\n\n    free(str);\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1630568715524"
	},
	{
		"name": "setjmp.h should not be used",
		"code": "MSR_21_4",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, setjmp.h is used",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中使用了setjmp.h ",
			"code": "MSR_21_4",
			"override": "T",
			"master_id": "2051",
			"name": "setjmp.h should not be used",
			"name_cn": "不可以使用setjmp.h ",
			"compliance": "R",
			"desc_en": "setjmp.h should not be used",
			"desc_cn": "不可以使用setjmp.h ",
			"abstract": "setjmp.h should not be used",
			"explanation": "Setjmp allows the normal function call/return mechanisms to be bypassed. The use of that can lead to undefined and unspecified behavior.",
			"abstract_cn": "不可以使用setjmp.h ",
			"explanation_cn": "Setjmp允许绕过正常的函数调用/返回机制。使用该选项可能导致未定义和未指定的行为",
			"example_good": "",
			"example_bad": "///c:\n#include <stdio.h>\n#include <stdlib.h>\n#include <setjmp.h>\n\nvoid func() {\n    int val;\n    jmp_buf env_buffer;\n\n    val = setjmp(env_buffer);\n\n    // Set value to val after lngjmp\n    if (val != 0) {\n        printf(\"Return from longjmp with value = %d\", val);\n        exit(0);\n    }\n\n    // Jump back to top\n    printf(\"Jump to top\");\n    // Using longjmp and setjmp can cause undefined behaviour\n    longjmp(env_buffer, 10);\n}",
			"details_en": "#### Abstract\nsetjmp.h should not be used\n\n#### Explanation\nSetjmp allows the normal function call/return mechanisms to be bypassed. The use of that can lead to undefined and unspecified behavior.",
			"details_cn": "#### 概要\n不可以使用setjmp.h \n\n#### 解释\nSetjmp允许绕过正常的函数调用/返回机制。使用该选项可能导致未定义和未指定的行为",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n#include <stdlib.h>\n#include <setjmp.h>\n\nvoid func() {\n    int val;\n    jmp_buf env_buffer;\n\n    val = setjmp(env_buffer);\n\n    // Set value to val after lngjmp\n    if (val != 0) {\n        printf(\"Return from longjmp with value = %d\", val);\n        exit(0);\n    }\n\n    // Jump back to top\n    printf(\"Jump to top\");\n    // Using longjmp and setjmp can cause undefined behaviour\n    longjmp(env_buffer, 10);\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1630568852352"
	},
	{
		"name": "signal.h should not be used",
		"code": "MSR_21_5",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, signal.h is used",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中使用了signal.h ",
			"code": "MSR_21_5",
			"override": "T",
			"master_id": "2052",
			"name": "signal.h should not be used",
			"name_cn": "不可以使用signal.h ",
			"compliance": "R",
			"desc_en": "signal.h should not be used",
			"desc_cn": "不可以使用signal.h ",
			"abstract": "signal.h should not be used",
			"explanation": "Since signal handling contains an implementation-defined and undefined behaviour, signal.h should not be used for C90 and C99 modes.",
			"abstract_cn": "不可以使用signal.h ",
			"explanation_cn": "由于信号处理包含实现定义和未定义的行为，signal.h不得用于C90和C99模式",
			"example_good": "",
			"example_bad": "///c:\n#include <stdio.h>\n#include <signal.h>\n#include <stdbool.h>\n#include <unistd.h>\n\nvoid sig_handler(int signum) {\n    printf(\"\\nInside handler function\\n\");\n}\n\nvoid func() { \n    // Register signal handler\n    // Using functions from signal.h can lead to undefined behaviour\n    signal(SIGINT,sig_handler); \n  \n    while(true) {    \n        printf(\"Inside func()\");    \n        sleep(1);  \n    }\n}",
			"details_en": "#### Abstract\nsignal.h should not be used\n\n#### Explanation\nSince signal handling contains an implementation-defined and undefined behaviour, signal.h should not be used for C90 and C99 modes.",
			"details_cn": "#### 概要\n不可以使用signal.h \n\n#### 解释\n由于信号处理包含实现定义和未定义的行为，signal.h不得用于C90和C99模式",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n#include <signal.h>\n#include <stdbool.h>\n#include <unistd.h>\n\nvoid sig_handler(int signum) {\n    printf(\"\\nInside handler function\\n\");\n}\n\nvoid func() { \n    // Register signal handler\n    // Using functions from signal.h can lead to undefined behaviour\n    signal(SIGINT,sig_handler); \n  \n    while(true) {    \n        printf(\"Inside func()\");    \n        sleep(1);  \n    }\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1630569074551"
	},
	{
		"name": "I/O functions in stdio.h should not be used",
		"code": "MSR_21_6",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, I/O functions in stdio.h is used",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中使用了 stdio.h 中的 I/O 函数",
			"code": "MSR_21_6",
			"override": "T",
			"master_id": "2053",
			"name": "I/O functions in stdio.h should not be used",
			"name_cn": "不得使用 stdio.h 中的 I/O 函数",
			"compliance": "R",
			"desc_en": "I/O functions in stdio.h should not be used",
			"desc_cn": "不得使用 stdio.h 中的 I/O 函数",
			"abstract": "I/O functions in stdio.h should not be used",
			"explanation": "Since I/O have unspecified, undefined and implementation-defined behaviours，I/O functions and their wide char equivalents in stdio.h should not be used for C90 and C99 modes.",
			"abstract_cn": "不得使用 stdio.h 中的 I/O 函数",
			"explanation_cn": "由于I/O具有未指定的、未定义的和实现定义的行为，因此在stdio.h中，I/O函数及其字符等价物不得用于C90和C99模式",
			"example_good": "",
			"example_bad": "///c:\n#include <stdio.h>\n\nvoid bar_c(void* ptr)\n{\n    int* dest = (int*)ptr;\n    int data = (*dest);\n    int i;\n    int Buffer[10] = { 0 };\n    if(data >= 0)\n      {\n         Buffer[data] = 1;\n         for(i=0; i<10; i++)\n         {\n             printf(\"%d\", Buffer[i]);\n         }\n     }\n }\n\n void foo_v()\n {\n     int data;\n     data = -1;\n     fscanf(stdin, \"%d\", &data); // this can easily cause array out of bound\n     bar_c(&data);\n } ",
			"details_en": "#### Abstract\nI/O functions in stdio.h should not be used\n\n#### Explanation\nSince I/O have unspecified, undefined and implementation-defined behaviours，I/O functions and their wide char equivalents in stdio.h should not be used for C90 and C99 modes.",
			"details_cn": "#### 概要\n不得使用 stdio.h 中的 I/O 函数\n\n#### 解释\n由于I/O具有未指定的、未定义的和实现定义的行为，因此在stdio.h中，I/O函数及其字符等价物不得用于C90和C99模式",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid bar_c(void* ptr)\n{\n    int* dest = (int*)ptr;\n    int data = (*dest);\n    int i;\n    int Buffer[10] = { 0 };\n    if(data >= 0)\n      {\n         Buffer[data] = 1;\n         for(i=0; i<10; i++)\n         {\n             printf(\"%d\", Buffer[i]);\n         }\n     }\n }\n\n void foo_v()\n {\n     int data;\n     data = -1;\n     fscanf(stdin, \"%d\", &data); // this can easily cause array out of bound\n     bar_c(&data);\n } "
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1630569135845"
	},
	{
		"name": "ascii conversion functions in stdlib.h should not be used",
		"code": "MSR_21_7",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "A18-0-2",
			"misra_c": "21.7",
			"misra_cpp": "18-0-2",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, ascii conversion functions in stdlib.h is used",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中使用了 stdlib.h 中的 ascii 转换函数",
			"code": "MSR_21_7",
			"override": "T",
			"master_id": "2054",
			"name": "ascii conversion functions in stdlib.h should not be used",
			"name_cn": "不得使用 stdlib.h 中的 ascii 转换函数",
			"compliance": "R",
			"desc_en": "ascii conversion functions in stdlib.h should not be used",
			"desc_cn": "不得使用 stdlib.h 中的 ascii 转换函数",
			"abstract": "ascii conversion functions in stdlib.h should not be used",
			"explanation": "Since atof, atol and atoll functions have undefined behaviors associated with them when the string cannot be converted, they should not be used for C90 and C99 modes.",
			"abstract_cn": "不得使用 stdlib.h 中的 ascii 转换函数",
			"explanation_cn": "由于atof、atol和atol函数在字符串无法转换时具有未定义的行为，因此它们不应用于C90和C99模式",
			"example_good": "",
			"example_bad": "///c:\n#include <iostream>\n#include <cstdlib>\n\nint foo()\n{\n  char s[] = \"98\";\n  long num;\n\n  num = atol(s);\n\n  std::cout << \"number in long = \" << num << std::endl;\n    \n}",
			"details_en": "#### Abstract\nascii conversion functions in stdlib.h should not be used\n\n#### Explanation\nSince atof, atol and atoll functions have undefined behaviors associated with them when the string cannot be converted, they should not be used for C90 and C99 modes.",
			"details_cn": "#### 概要\n不得使用 stdlib.h 中的 ascii 转换函数\n\n#### 解释\n由于atof、atol和atol函数在字符串无法转换时具有未定义的行为，因此它们不应用于C90和C99模式",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <iostream>\n#include <cstdlib>\n\nint foo()\n{\n  char s[] = \"98\";\n  long num;\n\n  num = atol(s);\n\n  std::cout << \"number in long = \" << num << std::endl;\n    \n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1630569245970"
	},
	{
		"name": "getenv, getenv and exit functions should not be used",
		"code": "MSR_21_8",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "M18-0-3",
			"misra_c": "21.8",
			"misra_cpp": "18-0-3",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, getenv, getenv and exit functions are used",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中使用了 getenv、getenv 和 exit 函数",
			"code": "MSR_21_8",
			"override": "T",
			"master_id": "2055",
			"name": "getenv, getenv and exit functions should not be used",
			"name_cn": "不得使用 getenv、getenv 和 exit 函数",
			"compliance": "R",
			"desc_en": "getenv, getenv and exit functions should not be used",
			"desc_cn": "不得使用 getenv、getenv 和 exit 函数",
			"abstract": "getenv, getenv and exit functions should not be used",
			"explanation": "Since getenv, getenv and exit functions have undefined and implementation-defined behaviors, they should not be used for C90 and C99 modes.",
			"abstract_cn": "不得使用 getenv、getenv 和 exit 函数",
			"explanation_cn": "由于getenv、getenv和exit函数具有未定义和实现定义的行为，因此它们不应用于C90和C99模式。",
			"example_good": "///c:\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid func () {\n   printf(\"Start of program\\n\");\n   \n   // Do not use abort, exit, getenv or system\n\n   printf(\"End of program\\n\");\n\n   return(0);\n}",
			"example_bad": "///c:\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(void)\n{\n  char* ptr_h;\n  char h[64];\n\n  ptr_h = getenv(\"HOME\");  // value of HOME could be > 64, need size guard\n  if (ptr_h != NULL) {\n    // ...\n  }\n  return 0;\n}",
			"details_en": "#### Abstract\ngetenv, getenv and exit functions should not be used\n\n#### Explanation\nSince getenv, getenv and exit functions have undefined and implementation-defined behaviors, they should not be used for C90 and C99 modes.",
			"details_cn": "#### 概要\n不得使用 getenv、getenv 和 exit 函数\n\n#### 解释\n由于getenv、getenv和exit函数具有未定义和实现定义的行为，因此它们不应用于C90和C99模式。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid func () {\n   printf(\"Start of program\\n\");\n   \n   // Do not use abort, exit, getenv or system\n\n   printf(\"End of program\\n\");\n\n   return(0);\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(void)\n{\n  char* ptr_h;\n  char h[64];\n\n  ptr_h = getenv(\"HOME\");  // value of HOME could be > 64, need size guard\n  if (ptr_h != NULL) {\n    // ...\n  }\n  return 0;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1630569303741"
	},
	{
		"name": "bsearch and qsort should not be used",
		"code": "MSR_21_9",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, bsearch and qsort is used",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中使用了 bsearch 和 qsort",
			"code": "MSR_21_9",
			"master_id": "2056",
			"name": "bsearch and qsort should not be used",
			"name_cn": "不得使用 bsearch 和 qsort",
			"compliance": "R",
			"desc_en": "bsearch and qsort should not be used",
			"desc_cn": "不得使用 bsearch 和 qsort",
			"abstract": "bsearch and qsort should not be used",
			"explanation": "If bsearch and qsort function do not behave consistently when comparing elements, or they modify any of the elements, the behavior is undefined. So they should not be used for C90 and C99 modes.",
			"abstract_cn": "不得使用 bsearch 和 qsort",
			"explanation_cn": "如果bsearch和qsort函数在比较元素时行为不一致，或者它们修改了任何元素，则该行为未定义。因此，它们不应用于C90和C99模式",
			"example_good": "",
			"example_bad": "///c:\n#include <stdio.h>\n#include <stdlib.h>\n\n\nint cmpfunc(const void * a, const void * b) {\n   return ( *(int*)a - *(int*)b );\n}\n\nint arr[] = { 1, 2, 3, 4, 5 };\n\nvoid func () {\n   int *item;\n   int key = 3;\n\n   // use bsearch to compare and find values of 3 in the array arr\n   item = (int*) bsearch (&key, arr, 5, sizeof (int), cmpfunc);\n   if( item != NULL ) {\n      printf(\"Found item\");\n   } else {\n      printf(\"Item is not in the array\");\n   }\n}",
			"details_en": "#### Abstract\nbsearch and qsort should not be used\n\n#### Explanation\nIf bsearch and qsort function do not behave consistently when comparing elements, or they modify any of the elements, the behavior is undefined. So they should not be used for C90 and C99 modes.",
			"details_cn": "#### 概要\n不得使用 bsearch 和 qsort\n\n#### 解释\n如果bsearch和qsort函数在比较元素时行为不一致，或者它们修改了任何元素，则该行为未定义。因此，它们不应用于C90和C99模式",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n#include <stdlib.h>\n\n\nint cmpfunc(const void * a, const void * b) {\n   return ( *(int*)a - *(int*)b );\n}\n\nint arr[] = { 1, 2, 3, 4, 5 };\n\nvoid func () {\n   int *item;\n   int key = 3;\n\n   // use bsearch to compare and find values of 3 in the array arr\n   item = (int*) bsearch (&key, arr, 5, sizeof (int), cmpfunc);\n   if( item != NULL ) {\n      printf(\"Found item\");\n   } else {\n      printf(\"Item is not in the array\");\n   }\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1630569343049"
	},
	{
		"name": "Time and date functions in stdlib.h should not be used",
		"code": "MSR_21_10",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, time and date functions in stdlib.h are used",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中使用了 stdlib.h 中的时间和日期函数",
			"code": "MSR_21_10",
			"override": "T",
			"master_id": "2057",
			"name": "Time and date functions in stdlib.h should not be used",
			"name_cn": "不得使用 stdlib.h 中的时间和日期函数",
			"compliance": "R",
			"desc_en": "Time and date functions in stdlib.h should not be used",
			"desc_cn": "不得使用 stdlib.h 中的时间和日期函数",
			"abstract": "Time and date functions in stdlib.h should not be used",
			"explanation": "Since the time and date functions have unspecified, undefined and implementation-defined behaviors, they should not be used for C90 and C99 modes.",
			"abstract_cn": "不得使用 stdlib.h 中的时间和日期函数",
			"explanation_cn": "由于时间和日期函数具有未指定、未定义和实现定义的行为，因此它们不应用于C90和C99模式。",
			"example_good": "",
			"example_bad": "///c:\n#include <stdio.h>\n#include <time.h>\n \nvoid func (){\n   // Using time and date function can lead to undefined behaviour\n   printf(\"%ld\", time(NULL));\n}",
			"details_en": "#### Abstract\nTime and date functions in stdlib.h should not be used\n\n#### Explanation\nSince the time and date functions have unspecified, undefined and implementation-defined behaviors, they should not be used for C90 and C99 modes.",
			"details_cn": "#### 概要\n不得使用 stdlib.h 中的时间和日期函数\n\n#### 解释\n由于时间和日期函数具有未指定、未定义和实现定义的行为，因此它们不应用于C90和C99模式。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n#include <time.h>\n \nvoid func (){\n   // Using time and date function can lead to undefined behaviour\n   printf(\"%ld\", time(NULL));\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1630569401770"
	},
	{
		"name": "MSR_5_0_1",
		"code": "MSR_5_0_1",
		"rules": {
			"category": "",
			"mapping": "",
			"misra_c": "MSR13.2",
			"misra_cpp": "5-0-1",
			"gjb5369": "",
			"gjb8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, the value of ${so.func} is not the same under any evaluation order permitted by the language standard",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}的结果值在任何编程语言允许的运行顺序下都不是一样的",
			"code": "MSR_5_0_1",
			"override": "T",
			"master_id": "3001",
			"name": "MSR_5_0_1",
			"name_cn": "MSR_5_0_1",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "For an evaluation of any expression and its side effects, the value must be the same under any evaluation order permitted by the language standard",
			"desc_cn": "评估一个表达式及其副作用时，其结果值在任何编程语言允许的运行顺序下都应该是一样的",
			"abstract": "For an evaluation of any expression and its side effects, the value must be the same under any evaluation order permitted by the language standard",
			"explanation": "Since the expression may have multiple execution orders, the design for any expression, should ensure that the value of the expression and its side effects are the same in all possible execution orders as prescribed by the lexical rule for the expression.",
			"abstract_cn": "评估一个表达式及其副作用时，其结果值在任何编程语言允许的运行顺序下都应该是一样的",
			"explanation_cn": "由于表达式可能有多层运行顺序，表达式的设计应确保在所有可能的符合词法的运行顺序下，其结果值和副作用都是一样的。",
			"example_good": "///cpp:\n#define LEN 1024\n\nint array_int[LEN];\n\nint foo(int i, int j)\n{\n  if (j > 0) {\n    return i+1;\n  }\n  else\n    return i;\n}\n\nint bar(unsigned int parm_b)\n{\n  if (parm_b < LEN) {\n    unsigned int temp = parm_b++;\n    array_int[temp] = parm_b ;  // behavior is deterministic\n  \n  return parm_b;\n}\n\nint call_foo(int i)\n{\n  int j = i++;\n  return foo(j, i);  // return value non-ambiguous\n}",
			"example_bad": "///cpp:\n#define LEN 1024\n\nint array_int[LEN];\n\nint foo(int i, int j)\n{\n  if (j > 0) {\n    return i+1;\n  }\n  else\n    return i;\n}\n\n\nint bar(unsigned int parm_b)\n{\n  if (parm_b < LEN)\n    array_int[parm_b++] = parm_b ;  // behavior is undefined\n  \n  return parm_b;\n}\n\n\nint call_foo(int i)\n{\n  return foo(i++, i);  // return value is implementation defined\n}\n",
			"details_en": "#### Abstract\nFor an evaluation of any expression and its side effects, the value must be the same under any evaluation order permitted by the language standard\n\n#### Explanation\nSince the expression may have multiple execution orders, the design for any expression, should ensure that the value of the expression and its side effects are the same in all possible execution orders as prescribed by the lexical rule for the expression.",
			"details_cn": "#### 概要\n评估一个表达式及其副作用时，其结果值在任何编程语言允许的运行顺序下都应该是一样的\n\n#### 解释\n由于表达式可能有多层运行顺序，表达式的设计应确保在所有可能的符合词法的运行顺序下，其结果值和副作用都是一样的。",
			"examples": {
				"good": {
					"cpp": [
						"\n#define LEN 1024\n\nint array_int[LEN];\n\nint foo(int i, int j)\n{\n  if (j > 0) {\n    return i+1;\n  }\n  else\n    return i;\n}\n\nint bar(unsigned int parm_b)\n{\n  if (parm_b < LEN) {\n    unsigned int temp = parm_b++;\n    array_int[temp] = parm_b ;  // behavior is deterministic\n  \n  return parm_b;\n}\n\nint call_foo(int i)\n{\n  int j = i++;\n  return foo(j, i);  // return value non-ambiguous\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\n#define LEN 1024\n\nint array_int[LEN];\n\nint foo(int i, int j)\n{\n  if (j > 0) {\n    return i+1;\n  }\n  else\n    return i;\n}\n\n\nint bar(unsigned int parm_b)\n{\n  if (parm_b < LEN)\n    array_int[parm_b++] = parm_b ;  // behavior is undefined\n  \n  return parm_b;\n}\n\n\nint call_foo(int i)\n{\n  return foo(i++, i);  // return value is implementation defined\n}\n"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1631680588534"
	},
	{
		"name": "MSR_5_0_8",
		"code": "MSR_5_0_8",
		"rules": {
			"category": "",
			"mapping": "",
			"misra_c": "MSR10.6",
			"misra_cpp": "5-0-8",
			"gjb5369": "",
			"gjb8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, the value of ${so.func} is cast to sizes larger than the underlying type of the expression",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中，表达式的值转换后大于表达式现有类型的大小",
			"code": "MSR_5_0_8",
			"override": "T",
			"master_id": "3002",
			"name": "MSR_5_0_8",
			"name_cn": "MSR_5_0_8",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "The value of an expression cannot be cast to sizes larger than the underlying type of the expression",
			"desc_cn": "表达式的值转换后不能大于表达式现有类型的大小",
			"abstract": "The value of an expression cannot be cast to sizes larger than the underlying type of the expression",
			"explanation": "When the value of an expression is cast to a size larger than its underlying type, there may be information loss such as signedness of the value.",
			"abstract_cn": "表达式的值转换后不能大于表达式现有类型的大小",
			"explanation_cn": "当表达式的值在转换后大于现有类型的大小时，有可能导致信息损失，譬如表达式值的符号。",
			"example_good": "///cpp:\nvoid func_5_0_8(int si, short sh_j, float flt_k)\n{\n  short  local_sh = 0x1234;\n  int    local_int1, local_int2;\n  float  local_flt = 1.0;\n  double local_dbl, local_dbl2;\n\n  local_int1 = static_cast< int > (int)local_sh + sh_j;  // compliant\n  local_int2 = static_cast< int > (local_sh) + sh_j;     // compliant\n\n  local_dbl2 = static_cast<double> ((double)flt_k) + local_flt;  // compliant\n  \n}",
			"example_bad": "///cpp:\nvoid func_5_0_8(int si, short sh_j, float flt_k)\n{\n  short  local_sh = 0x1234;\n  int    local_int1, local_int2;\n  float  local_flt = 1.0;\n  double local_dbl, local_dbl2;\n\n  local_int1 = static_cast< int > (local_sh + sh_j);  // non-compliant\n\n  local_dbl2 = static_cast<double> (flt_k + local_flt);  // non-compliant\n  \n}",
			"details_en": "#### Abstract\nThe value of an expression cannot be cast to sizes larger than the underlying type of the expression\n\n#### Explanation\nWhen the value of an expression is cast to a size larger than its underlying type, there may be information loss such as signedness of the value.",
			"details_cn": "#### 概要\n表达式的值转换后不能大于表达式现有类型的大小\n\n#### 解释\n当表达式的值在转换后大于现有类型的大小时，有可能导致信息损失，譬如表达式值的符号。",
			"examples": {
				"good": {
					"cpp": [
						"\nvoid func_5_0_8(int si, short sh_j, float flt_k)\n{\n  short  local_sh = 0x1234;\n  int    local_int1, local_int2;\n  float  local_flt = 1.0;\n  double local_dbl, local_dbl2;\n\n  local_int1 = static_cast< int > (int)local_sh + sh_j;  // compliant\n  local_int2 = static_cast< int > (local_sh) + sh_j;     // compliant\n\n  local_dbl2 = static_cast<double> ((double)flt_k) + local_flt;  // compliant\n  \n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\nvoid func_5_0_8(int si, short sh_j, float flt_k)\n{\n  short  local_sh = 0x1234;\n  int    local_int1, local_int2;\n  float  local_flt = 1.0;\n  double local_dbl, local_dbl2;\n\n  local_int1 = static_cast< int > (local_sh + sh_j);  // non-compliant\n\n  local_dbl2 = static_cast<double> (flt_k + local_flt);  // non-compliant\n  \n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1631680711919"
	},
	{
		"name": "More than 2 indirections",
		"code": "MSR_5_0_19",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, declaration of objects contains more than two levels of pointer indirection",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}，在声明对象时有多于两层的间接指针",
			"code": "MSR_5_0_19",
			"override": "T",
			"master_id": "3003",
			"name": "More than 2 indirections",
			"name_cn": "多于两层间接指针",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "Declaration of objects cannot contain more than two levels of pointer indirection",
			"desc_cn": "在声明对象时不能有多于两层的间接指针",
			"abstract": "Declaration of objects cannot contain more than two levels of pointer indirection",
			"explanation": "Having more than two levels of indirection, which gives, at least three levels of dereferencing an object, means it can be very hard to understand the intended behavior of the program.",
			"abstract_cn": "在声明对象时不能有多于两层的间接指针",
			"explanation_cn": "当声明对象时有多于两层的间接指针，会引起至少三层的解引用，从而给理解程序预期的行为带来困难。",
			"example_good": "///cpp:\nint array[10][20];\n\n// this example is equivalent to the \"avoid\" example\n// \nint mlk_three_indirect(int val)\n{\n  int j = val;\n  int *p = &j;\n  int **p_2, **r_2;\n  int *p_2_array = &array[*p][0];\n  int p3;\n  \n  array[val][0] = val;\n  p3 = array[val][0];\n  return p3;\n\n}",
			"example_bad": "///cpp:\nint array[10][20];\n\nint mlk_three_indirect(int val)\n{\n  int j = val;\n  int *p = &j;\n  int **p_2, **r_2;\n  int *p_2_array = &array[*p][0];\n  int ***p3;\n\n  // ... \n  p_2 = &p;\n  \n  // ...\n  array[val][0] = **p_2;\n  \n  //...\n  r_2 = &p_2_array;\n  \n  // ...\n  p3 = &r_2;\n  \n  // ... \n  return ***p3;\n\n}",
			"details_en": "#### Abstract\nDeclaration of objects cannot contain more than two levels of pointer indirection\n\n#### Explanation\nHaving more than two levels of indirection, which gives, at least three levels of dereferencing an object, means it can be very hard to understand the intended behavior of the program.",
			"details_cn": "#### 概要\n在声明对象时不能有多于两层的间接指针\n\n#### 解释\n当声明对象时有多于两层的间接指针，会引起至少三层的解引用，从而给理解程序预期的行为带来困难。",
			"examples": {
				"good": {
					"cpp": [
						"\nint array[10][20];\n\n// this example is equivalent to the \"avoid\" example\n// \nint mlk_three_indirect(int val)\n{\n  int j = val;\n  int *p = &j;\n  int **p_2, **r_2;\n  int *p_2_array = &array[*p][0];\n  int p3;\n  \n  array[val][0] = val;\n  p3 = array[val][0];\n  return p3;\n\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\nint array[10][20];\n\nint mlk_three_indirect(int val)\n{\n  int j = val;\n  int *p = &j;\n  int **p_2, **r_2;\n  int *p_2_array = &array[*p][0];\n  int ***p3;\n\n  // ... \n  p_2 = &p;\n  \n  // ...\n  array[val][0] = **p_2;\n  \n  //...\n  r_2 = &p_2_array;\n  \n  // ...\n  p3 = &r_2;\n  \n  // ... \n  return ***p3;\n\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1631681301110"
	},
	{
		"name": "Bad enum initialization",
		"code": "MSR_8_5_3",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the enum initialization is incorrect",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中出现错误的枚举初始化",
			"code": "MSR_8_5_3",
			"override": "T",
			"master_id": "3004",
			"name": "Bad enum initialization",
			"name_cn": "错误的枚举初始化",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "The only explicit initialization of an enum with the “=” construct is such that all, none or the first one, are initialized",
			"desc_cn": "对于带有“=”构造的枚举，显式初始化能初始化或者不初始化全部枚举，也能仅初始化第一个枚举",
			"abstract": "The only explicit initialization of an enum with the “=” construct is such that all, none or the first one, are initialized",
			"explanation": "Explicit and uniform initialization of an enum list prevents mixing of automatic and manual assignment, which is error-prone. The compiler can also detect possible out of range errors for the enum.",
			"abstract_cn": "对于带有“=”构造的枚举，显式初始化能初始化或者不初始化全部枚举，也能仅初始化第一个枚举",
			"explanation_cn": "使用显式且一致的方式对枚举列表进行初始化，可以避免因混淆自动与手动赋值而造成错误，并且能使编译器发现枚举中可能是超出范围的错误。",
			"example_good": "///cpp:\ntypedef enum color { red=3 } GoodEnum;   // compliant\n\n// compliant (but assignment not in sequence )\ntypedef enum bad_enum_color { white=0,\n         blue=1,         // 2 is not used \n         yellow=3 } BadEnum;  \n\ntypedef enum no_assign { NO_ONE, NO_TWO, NO_THREE } GoodEnum_NoAssign;\n\nextern void bar( color c, bad_enum_color b, no_assign n);\n\nvoid func_use(void)\n{\n  color var_color = red;\n  bad_enum_color var_bad_color = blue;\n  no_assign var_no_assign = NO_TWO;\n\n  bar(var_color, var_bad_color, var_no_assign);\n  return;\n}",
			"example_bad": "///cpp:\ntypedef enum color { red=3 } GoodEnum;   // compliant\n\ntypedef enum bad_enum_color { white=0,\n\t\t\t      blue=1,\n\t\t\t      yellow } BadEnum;  // non-compliant\n\ntypedef enum no_assign { NO_ONE, NO_TWO, NO_THREE } GoodEnum_NoAssign;\n\nextern void bar( color c, bad_enum_color b, no_assign n);\n\nvoid func_use(void)\n{\n  color var_color = red;\n  bad_enum_color var_bad_color = blue;\n  no_assign var_no_assign = NO_TWO;\n\n  bar(var_color, var_bad_color, var_no_assign);\n  return;\n}",
			"details_en": "#### Abstract\nThe only explicit initialization of an enum with the “=” construct is such that all, none or the first one, are initialized\n\n#### Explanation\nExplicit and uniform initialization of an enum list prevents mixing of automatic and manual assignment, which is error-prone. The compiler can also detect possible out of range errors for the enum.",
			"details_cn": "#### 概要\n对于带有“=”构造的枚举，显式初始化能初始化或者不初始化全部枚举，也能仅初始化第一个枚举\n\n#### 解释\n使用显式且一致的方式对枚举列表进行初始化，可以避免因混淆自动与手动赋值而造成错误，并且能使编译器发现枚举中可能是超出范围的错误。",
			"examples": {
				"good": {
					"cpp": [
						"\ntypedef enum color { red=3 } GoodEnum;   // compliant\n\n// compliant (but assignment not in sequence )\ntypedef enum bad_enum_color { white=0,\n         blue=1,         // 2 is not used \n         yellow=3 } BadEnum;  \n\ntypedef enum no_assign { NO_ONE, NO_TWO, NO_THREE } GoodEnum_NoAssign;\n\nextern void bar( color c, bad_enum_color b, no_assign n);\n\nvoid func_use(void)\n{\n  color var_color = red;\n  bad_enum_color var_bad_color = blue;\n  no_assign var_no_assign = NO_TWO;\n\n  bar(var_color, var_bad_color, var_no_assign);\n  return;\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\ntypedef enum color { red=3 } GoodEnum;   // compliant\n\ntypedef enum bad_enum_color { white=0,\n\t\t\t      blue=1,\n\t\t\t      yellow } BadEnum;  // non-compliant\n\ntypedef enum no_assign { NO_ONE, NO_TWO, NO_THREE } GoodEnum_NoAssign;\n\nextern void bar( color c, bad_enum_color b, no_assign n);\n\nvoid func_use(void)\n{\n  color var_color = red;\n  bad_enum_color var_bad_color = blue;\n  no_assign var_no_assign = NO_TWO;\n\n  bar(var_color, var_bad_color, var_no_assign);\n  return;\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1631681649014"
	},
	{
		"name": "Base class has virtual and non-virtual",
		"code": "MSR_10_1_3",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, a base class is virtual and non-virtual in a multiple inheritance hierarchy",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中的基类在多继承体系中既是虚拟的又是非虚拟的",
			"code": "MSR_10_1_3",
			"override": "T",
			"master_id": "3005",
			"name": "Base class has virtual and non-virtual",
			"name_cn": "基类有虚拟和非虚拟的",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "A base class should not be both, virtual and non-virtual in a multiple inheritance hierarchy",
			"desc_cn": "基类不能在多继承体系中既是虚拟的又是非虚拟的",
			"abstract": "A base class should not be both, virtual and non-virtual in a multiple inheritance hierarchy",
			"explanation": "If the base class is both virtual and non-virtual in a multiple inheritance hierarchy, then there will be multiple copies of the base class sub-object in the derived object. This is likely a declaration error.",
			"abstract_cn": "基类不能在多继承体系中既是虚拟的又是非虚拟的",
			"explanation_cn": "如果基类在多继承体系中既是虚拟的又是非虚拟的，那么会在派生对象中产生多个基类子对象的复制版。这可能导致声明错误。",
			"example_good": "///cpp:\nclass Expr {\n  int i;\npublic:\n  Expr(); // def constructor\n  Expr(const Expr&); // copy constructor\n\n  virtual Expr* newExpr() { i+=2; return new Expr(); }\n  virtual Expr* clone()   { i++; return new Expr(*this); }\n};\n\n\nclass B1 : public virtual Expr {};\nclass B2 : public virtual Expr {};\nclass B3 : public         Expr {};\n\nclass C  : public B1, B2 {};  // both B1 and B2 are virtual\n\nclass D  : public B3, B1 {};  // B3 and B1 are different base classes",
			"example_bad": "///cpp:\nclass Expr {\n  int i;\npublic:\n  Expr(); // def constructor\n  Expr(const Expr&); // copy constructor\n\n  virtual Expr* newExpr() { i+=2; return new Expr(); }\n  virtual Expr* clone()   { i++; return new Expr(*this); }\n};\n\n\nclass B1 : public virtual Expr {};\nclass B2 : public virtual Expr {};\nclass B3 : public         Expr {};\n\n// B2 and B3 are virtual and non-virtual in a multiple inheritance hierarchy\nclass C  : public B1, B2, B3 {}; ",
			"details_en": "#### Abstract\nA base class should not be both, virtual and non-virtual in a multiple inheritance hierarchy\n\n#### Explanation\nIf the base class is both virtual and non-virtual in a multiple inheritance hierarchy, then there will be multiple copies of the base class sub-object in the derived object. This is likely a declaration error.",
			"details_cn": "#### 概要\n基类不能在多继承体系中既是虚拟的又是非虚拟的\n\n#### 解释\n如果基类在多继承体系中既是虚拟的又是非虚拟的，那么会在派生对象中产生多个基类子对象的复制版。这可能导致声明错误。",
			"examples": {
				"good": {
					"cpp": [
						"\nclass Expr {\n  int i;\npublic:\n  Expr(); // def constructor\n  Expr(const Expr&); // copy constructor\n\n  virtual Expr* newExpr() { i+=2; return new Expr(); }\n  virtual Expr* clone()   { i++; return new Expr(*this); }\n};\n\n\nclass B1 : public virtual Expr {};\nclass B2 : public virtual Expr {};\nclass B3 : public         Expr {};\n\nclass C  : public B1, B2 {};  // both B1 and B2 are virtual\n\nclass D  : public B3, B1 {};  // B3 and B1 are different base classes"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\nclass Expr {\n  int i;\npublic:\n  Expr(); // def constructor\n  Expr(const Expr&); // copy constructor\n\n  virtual Expr* newExpr() { i+=2; return new Expr(); }\n  virtual Expr* clone()   { i++; return new Expr(*this); }\n};\n\n\nclass B1 : public virtual Expr {};\nclass B2 : public virtual Expr {};\nclass B3 : public         Expr {};\n\n// B2 and B3 are virtual and non-virtual in a multiple inheritance hierarchy\nclass C  : public B1, B2, B3 {}; "
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1631682426620"
	},
	{
		"name": "Dynamic type in ctor or dtor",
		"code": "MSR_12_1_1",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, an object’s dynamic type is used from the body of its constructor or destructor",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中，对象的动态类型在构造函数或者析构函数本体使用",
			"code": "MSR_12_1_1",
			"override": "T",
			"master_id": "3006",
			"name": "Dynamic type in ctor or dtor",
			"name_cn": "ctor 或 dtor 中的动态类型",
			"compliance": "R",
			"desc_en": "An object’s dynamic type cannot be used from the body of its constructor or destructor",
			"desc_cn": "对象的动态类型不能在构造函数或者析构函数本体使用",
			"abstract": "An object’s dynamic type cannot be used from the body of its constructor or destructor",
			"explanation": "A non-static member of an object can have an initialization with the declaration of the member in its body (NSDMI). To avoid confusion, any member initialized this way (NSDMI) or with a constructor should be the same.",
			"abstract_cn": "对象的动态类型不能在构造函数或者析构函数本体使用",
			"explanation_cn": "对象的非静态成员能通过成员声明进行初始化（NSDMI)。为避免混淆，成员既可以通过NSDMI方式来初始化也可以通过构造函数来初始化，两种方式对于成员的初始化应该是一样的。",
			"example_good": "///cpp:\nclass Expr {\n  int i;\n  \npublic:\n  Expr(const Expr&); // copy constructor\n  virtual ~Expr ();\n\n  virtual Expr* newExpr() { i+=2; return new Expr(); }\n  virtual Expr* clone()   { i++; return new Expr(*this); }\n  Expr() {\n    Expr::clone();                // not a virtual call, hence compliant\n    clone();                      // a virtual call\n    // the following line must be removed from this constructor declaration\n    // commented out in the example to be clear\n    // dynamic_cast<Expr*> (this);  \n  }\n};\n",
			"example_bad": "///cpp:\nclass Expr {\n  int i;\n  \npublic:\n  Expr(const Expr&); // copy constructor\n  virtual ~Expr ();\n\n  virtual Expr* newExpr() { i+=2; return new Expr(); }\n  virtual Expr* clone()   { i++; return new Expr(*this); }\n  Expr() {\n    Expr::clone();                // not a virtual call, hence compliant\n    clone();                      // a virtual call\n    dynamic_cast<Expr*> (this);   // non-compliant\n  }\n};\n",
			"details_en": "#### Abstract\nAn object’s dynamic type cannot be used from the body of its constructor or destructor\n\n#### Explanation\nA non-static member of an object can have an initialization with the declaration of the member in its body (NSDMI). To avoid confusion, any member initialized this way (NSDMI) or with a constructor should be the same.",
			"details_cn": "#### 概要\n对象的动态类型不能在构造函数或者析构函数本体使用\n\n#### 解释\n对象的非静态成员能通过成员声明进行初始化（NSDMI)。为避免混淆，成员既可以通过NSDMI方式来初始化也可以通过构造函数来初始化，两种方式对于成员的初始化应该是一样的。",
			"examples": {
				"good": {
					"cpp": [
						"\nclass Expr {\n  int i;\n  \npublic:\n  Expr(const Expr&); // copy constructor\n  virtual ~Expr ();\n\n  virtual Expr* newExpr() { i+=2; return new Expr(); }\n  virtual Expr* clone()   { i++; return new Expr(*this); }\n  Expr() {\n    Expr::clone();                // not a virtual call, hence compliant\n    clone();                      // a virtual call\n    // the following line must be removed from this constructor declaration\n    // commented out in the example to be clear\n    // dynamic_cast<Expr*> (this);  \n  }\n};\n"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\nclass Expr {\n  int i;\n  \npublic:\n  Expr(const Expr&); // copy constructor\n  virtual ~Expr ();\n\n  virtual Expr* newExpr() { i+=2; return new Expr(); }\n  virtual Expr* clone()   { i++; return new Expr(*this); }\n  Expr() {\n    Expr::clone();                // not a virtual call, hence compliant\n    clone();                      // a virtual call\n    dynamic_cast<Expr*> (this);   // non-compliant\n  }\n};\n"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1631682569290"
	},
	{
		"name": "ctor must explicitly call ctor for all its immediate base classes",
		"code": "MSR_12_1_2",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, ctor does not explicitly call ctor for all its immediate base classes",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中ctor没有为其所有直接基类显式调用 ctor",
			"code": "MSR_12_1_2",
			"override": "T",
			"master_id": "3007",
			"name": "ctor must explicitly call ctor for all its immediate base classes",
			"name_cn": "ctor 必须为其所有直接基类显式调用 ctor",
			"compliance": "A",
			"desc_en": "ctor must explicitly call ctor for all its immediate base classes",
			"desc_cn": "ctor 必须为其所有直接基类显式调用 ctor",
			"abstract": "ctor must explicitly call ctor for all its immediate base classes",
			"explanation": "",
			"abstract_cn": "ctor 必须为其所有直接基类显式调用 ctor",
			"explanation_cn": "",
			"example_good": "///cpp:\nclass Base {\npublic:\n  Base() {}\n  Base(int i);\n};\n\n\nclass Derived1 : public virtual Base {\npublic:\n  Derived1() {}\n  Derived1(int) : Base(0) {}\n}; \n\nclass Derived2 : public virtual Base {\npublic:\n  Derived2() {}\n  Derived2(int) : Base(1) {}\n}; \n\n\nclass Hier : public Derived1, public Derived2 {\n  //  Hier()    {}\n  Hier(int) {} // constructor used is ambiguous w.r.t. Derived1 or Derived2\n\n};",
			"example_bad": "///cpp:\nclass Base {\npublic:\n  Base() {}\n  Base(int i);\n};\n\n\nclass Derived1 : public virtual Base {\npublic:\n  Derived1() {}\n  Derived1(int) : Base(0) {}\n}; \n\nclass Derived2 : public virtual Base {\npublic:\n  Derived2() {}\n  Derived2(int) : Base(1) {}\n}; \n\n\nclass Hier : public Derived1, public Derived2 {\n  //  Hier()    {}\n  Hier(int) {} // constructor used is ambiguous w.r.t. Derived1 or Derived2\n\n};",
			"details_en": "#### Abstract\nctor must explicitly call ctor for all its immediate base classes\n\n#### Explanation\n",
			"details_cn": "#### 概要\nctor 必须为其所有直接基类显式调用 ctor\n\n#### 解释\n",
			"examples": {
				"good": {
					"cpp": [
						"\nclass Base {\npublic:\n  Base() {}\n  Base(int i);\n};\n\n\nclass Derived1 : public virtual Base {\npublic:\n  Derived1() {}\n  Derived1(int) : Base(0) {}\n}; \n\nclass Derived2 : public virtual Base {\npublic:\n  Derived2() {}\n  Derived2(int) : Base(1) {}\n}; \n\n\nclass Hier : public Derived1, public Derived2 {\n  //  Hier()    {}\n  Hier(int) {} // constructor used is ambiguous w.r.t. Derived1 or Derived2\n\n};"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\nclass Base {\npublic:\n  Base() {}\n  Base(int i);\n};\n\n\nclass Derived1 : public virtual Base {\npublic:\n  Derived1() {}\n  Derived1(int) : Base(0) {}\n}; \n\nclass Derived2 : public virtual Base {\npublic:\n  Derived2() {}\n  Derived2(int) : Base(1) {}\n}; \n\n\nclass Hier : public Derived1, public Derived2 {\n  //  Hier()    {}\n  Hier(int) {} // constructor used is ambiguous w.r.t. Derived1 or Derived2\n\n};"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1631683055833"
	},
	{
		"name": "ctor with single parameter of basic type should be explicit",
		"code": "MSR_12_1_3",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, ctor with single parameter of basic type is not explicit",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中，具有基本类型的单个参数的 ctor 不是显式的",
			"code": "MSR_12_1_3",
			"override": "T",
			"master_id": "3008",
			"name": "ctor with single parameter of basic type should be explicit",
			"name_cn": "具有基本类型的单个参数的 ctor 应该是显式的",
			"compliance": "R",
			"desc_en": "ctor with single parameter of basic type should be explicit",
			"desc_cn": "具有基本类型的单个参数的 ctor 应该是显式的",
			"abstract": "ctor with single parameter of basic type should be explicit",
			"explanation": "",
			"abstract_cn": "具有基本类型的单个参数的 ctor 应该是显式的",
			"explanation_cn": "",
			"example_good": "///cpp:\nclass Base {\npublic:\n  Base() {}\n  explicit Base(int i);\n};\n\n\nclass Derived1 : public virtual Base {\npublic:\n  Derived1() {} \n  explicit Derived1(int) : Base(0) {}    // make explicit\n}; \n\nclass Derived2 : public virtual Base {\npublic:\n  Derived2() {}\n  explicit Derived2(int) : Base(1) {}    // make explicit\n}; \n\n\nclass Hier : public Derived1, public Derived2 {\n  explicit Hier(int) : Derived1(2), Derived2(), Base() {}  // make explicit\n\n};",
			"example_bad": "///cpp:\n\nclass Base {\npublic:\n  Base(void) {}\n  Base(int i);\n};\n\n\nclass Derived1 : public virtual Base {\npublic:\n  Derived1() {}\n  Derived1(int) : Base(0) {}\n}; \n\nclass Derived2 : public virtual Base {\npublic:\n  Derived2() {}\n  Derived2(int) : Base(1) {}\n}; \n\nclass Hier : public Derived1, public Derived2 {\n  Hier(int)    {}\n};",
			"details_en": "#### Abstract\nctor with single parameter of basic type should be explicit\n\n#### Explanation\n",
			"details_cn": "#### 概要\n具有基本类型的单个参数的 ctor 应该是显式的\n\n#### 解释\n",
			"examples": {
				"good": {
					"cpp": [
						"\nclass Base {\npublic:\n  Base() {}\n  explicit Base(int i);\n};\n\n\nclass Derived1 : public virtual Base {\npublic:\n  Derived1() {} \n  explicit Derived1(int) : Base(0) {}    // make explicit\n}; \n\nclass Derived2 : public virtual Base {\npublic:\n  Derived2() {}\n  explicit Derived2(int) : Base(1) {}    // make explicit\n}; \n\n\nclass Hier : public Derived1, public Derived2 {\n  explicit Hier(int) : Derived1(2), Derived2(), Base() {}  // make explicit\n\n};"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\n\nclass Base {\npublic:\n  Base(void) {}\n  Base(int i);\n};\n\n\nclass Derived1 : public virtual Base {\npublic:\n  Derived1() {}\n  Derived1(int) : Base(0) {}\n}; \n\nclass Derived2 : public virtual Base {\npublic:\n  Derived2() {}\n  Derived2(int) : Base(1) {}\n}; \n\nclass Hier : public Derived1, public Derived2 {\n  Hier(int)    {}\n};"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1631683220419"
	},
	{
		"name": "Non-POD member in a class must be private",
		"code": "MSR_11_0_1",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, non-POD member in a class is not private",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中，类中的非 POD 成员必须不是私有的",
			"code": "MSR_11_0_1",
			"override": "T",
			"master_id": "3009",
			"name": "Non-POD member in a class must be private",
			"name_cn": "类中的非 POD 成员必须是私有的",
			"compliance": "R",
			"desc_en": "Non-POD member in a class must be private",
			"desc_cn": "类中的非 POD 成员必须是私有的",
			"abstract": "Non-POD member in a class must be private",
			"explanation": "",
			"abstract_cn": "类中的非 POD 成员必须是私有的",
			"explanation_cn": "",
			"example_good": "///cpp:\ntypedef char    Letter;  \ntypedef Letter* pLetter;\n  \nclass Class_Without_POD    \n{\npublic:\n  Letter  c;  \n  pLetter p;\n};\n\nclass Class_with_POD\n{\nprivate:\n  char    c;         // will need interfaces to access and modify\n  char*   pc;  \n};",
			"example_bad": "///cpp:\n#include <stdint.h>\n\ntypedef char    Letter;  \ntypedef Letter* pLetter;\n  \nclass Class_Without_POD    \n{\npublic:\n  Letter  c;  \n  pLetter p;\n};\n\nclass Class_with_POD\n{\npublic:\n  int8_t   c;         // POD has no default constructor\n  char*   pc;  \n};",
			"details_en": "#### Abstract\nNon-POD member in a class must be private\n\n#### Explanation\n",
			"details_cn": "#### 概要\n类中的非 POD 成员必须是私有的\n\n#### 解释\n",
			"examples": {
				"good": {
					"cpp": [
						"\ntypedef char    Letter;  \ntypedef Letter* pLetter;\n  \nclass Class_Without_POD    \n{\npublic:\n  Letter  c;  \n  pLetter p;\n};\n\nclass Class_with_POD\n{\nprivate:\n  char    c;         // will need interfaces to access and modify\n  char*   pc;  \n};"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\n#include <stdint.h>\n\ntypedef char    Letter;  \ntypedef Letter* pLetter;\n  \nclass Class_Without_POD    \n{\npublic:\n  Letter  c;  \n  pLetter p;\n};\n\nclass Class_with_POD\n{\npublic:\n  int8_t   c;         // POD has no default constructor\n  char*   pc;  \n};"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1631683383735"
	},
	{
		"name": "All visible names within an inheritance hierarchy must be unique",
		"code": "MSR_10_2_1",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the visiable names within a inheritance hierarchy are not unique",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中，继承层次结构中的所有可见名称不是唯一的",
			"code": "MSR_10_2_1",
			"override": "T",
			"master_id": "3010",
			"name": "All visible names within an inheritance hierarchy must be unique",
			"name_cn": "继承层次结构中的所有可见名称必须是唯一的",
			"compliance": "A",
			"desc_en": "All visible names within an inheritance hierarchy must be unique",
			"desc_cn": "继承层次结构中的所有可见名称必须是唯一的",
			"abstract": "All visible names within an inheritance hierarchy must be unique",
			"explanation": "",
			"abstract_cn": "继承层次结构中的所有可见名称必须是唯一的",
			"explanation_cn": "",
			"example_good": "///cpp:\n\nclass Base {\npublic:\n  void func_char(char) {};\n};\n\nclass Derived : public Base {\npublic:\n  void func_int(int) {};\n};\n\n\nint foo(void)\n{\n  int   i;\n  char ch;\n  Derived example;\n\n  example.func_int(i);\n\n  example.func_char(ch);  // func(char) in Base is not visible \n  \n}",
			"example_bad": "///cpp:\n\nclass Base {\npublic:\n  void func(char) {};\n};\n\nclass Derived : public Base {\npublic:\n  void func(int) {};\n};\n\n\nint foo(void)\n{\n  int   i;\n  char ch;\n  Derived example;\n\n  example.func(i);\n  example.func(ch);  // func(char) in Base is not visible \n  \n}",
			"details_en": "#### Abstract\nAll visible names within an inheritance hierarchy must be unique\n\n#### Explanation\n",
			"details_cn": "#### 概要\n继承层次结构中的所有可见名称必须是唯一的\n\n#### 解释\n",
			"examples": {
				"good": {
					"cpp": [
						"\n\nclass Base {\npublic:\n  void func_char(char) {};\n};\n\nclass Derived : public Base {\npublic:\n  void func_int(int) {};\n};\n\n\nint foo(void)\n{\n  int   i;\n  char ch;\n  Derived example;\n\n  example.func_int(i);\n\n  example.func_char(ch);  // func(char) in Base is not visible \n  \n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\n\nclass Base {\npublic:\n  void func(char) {};\n};\n\nclass Derived : public Base {\npublic:\n  void func(int) {};\n};\n\n\nint foo(void)\n{\n  int   i;\n  char ch;\n  Derived example;\n\n  example.func(i);\n  example.func(ch);  // func(char) in Base is not visible \n  \n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1631687209359"
	},
	{
		"name": "Value returned by a function should be used",
		"code": "MSR_17_7",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, value returned by ${so.func} is not used",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}的返回值未被使用",
			"code": "MSR_17_7",
			"override": "T",
			"master_id": "2058",
			"name": "Value returned by a function should be used",
			"name_cn": "应使用函数返回的值",
			"compliance": "R",
			"desc_en": "The value returned by a function which has non-void return type should be used",
			"desc_cn": "应使用具有非 void 返回类型的函数返回的值",
			"abstract": "The value returned by a function which has non-void return type should be used",
			"explanation": "Calling a function without using the return value may be an error for a C90 and a C99 mode. Return value of a function should be cast to the void type if it is intended not to be used explicitly.",
			"abstract_cn": "应使用具有非 void 返回类型的函数返回的值",
			"explanation_cn": "对于 C90 和 C99 模式，不使用返回值调用函数可能是错误的。如果不打算显式使用函数的返回值，则应将其强制转换为 void 类型。",
			"example_good": "///c:\nextern int func_ret_int(int, int);\n\n\nvoid bar(int n, int m)\n{\n  if (n > 0) {\n    n += func_ret_int(n, m);\n  }\n  else {\n    (void)func_ret_int(m, m); // func return value ignored\n  }\n}\n",
			"example_bad": "///c:\nextern int func_ret_int(int, int);\n\n\nvoid bar(int n, int m)\n{\n  if (n > 0) {\n    n += func_ret_int(n);\n  }\n  else {\n    func_ret_int(m); // func return value ignored\n  }\n}",
			"details_en": "#### Abstract\nThe value returned by a function which has non-void return type should be used\n\n#### Explanation\nCalling a function without using the return value may be an error for a C90 and a C99 mode. Return value of a function should be cast to the void type if it is intended not to be used explicitly.",
			"details_cn": "#### 概要\n应使用具有非 void 返回类型的函数返回的值\n\n#### 解释\n对于 C90 和 C99 模式，不使用返回值调用函数可能是错误的。如果不打算显式使用函数的返回值，则应将其强制转换为 void 类型。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nextern int func_ret_int(int, int);\n\n\nvoid bar(int n, int m)\n{\n  if (n > 0) {\n    n += func_ret_int(n, m);\n  }\n  else {\n    (void)func_ret_int(m, m); // func return value ignored\n  }\n}\n"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nextern int func_ret_int(int, int);\n\n\nvoid bar(int n, int m)\n{\n  if (n > 0) {\n    n += func_ret_int(n);\n  }\n  else {\n    func_ret_int(m); // func return value ignored\n  }\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1631687289715"
	},
	{
		"name": "A function parameter should not be modified",
		"code": "MSR_17_8",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, a function parameter is modified",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中函数的参数被修改",
			"code": "MSR_17_8",
			"override": "T",
			"master_id": "2059",
			"name": "A function parameter should not be modified",
			"name_cn": "不得修改函数参数",
			"compliance": "A",
			"desc_en": "The parameter of a function should not be modified",
			"desc_cn": "不得修改函数的参数",
			"abstract": "The parameter of a function should not be modified",
			"explanation": "Modifying the parameter of a function can be confusing and in conflict with programmer expectations for C90 and C99 modes. So the The parameter of a function should not be modified.",
			"abstract_cn": "不得修改函数的参数",
			"explanation_cn": "对 C90 和 C99 模式而言，修改函数的参数可能会令人困惑并与程序员的期望相冲突。 所以不能修改函数的参数。",
			"example_good": "///c:\n#include <stdio.h>\n\nvoid func(int param){\n    // Only use param, do not ever modify it by assigning another value\n    printf(\"%d\\n\", param);\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nvoid func(int param){\n    // Modifying parameter can cause confusion\n    param = 5;\n    printf(\"%d\\n\", param);\n}",
			"details_en": "#### Abstract\nThe parameter of a function should not be modified\n\n#### Explanation\nModifying the parameter of a function can be confusing and in conflict with programmer expectations for C90 and C99 modes. So the The parameter of a function should not be modified.",
			"details_cn": "#### 概要\n不得修改函数的参数\n\n#### 解释\n对 C90 和 C99 模式而言，修改函数的参数可能会令人困惑并与程序员的期望相冲突。 所以不能修改函数的参数。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func(int param){\n    // Only use param, do not ever modify it by assigning another value\n    printf(\"%d\\n\", param);\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func(int param){\n    // Modifying parameter can cause confusion\n    param = 5;\n    printf(\"%d\\n\", param);\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1631687330687"
	},
	{
		"name": "char not allowed in arithmatic expression",
		"code": "MSR_10_2",
		"rules": {
			"category": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, char is used in arithmatic expression ${so.func}",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，算术表达式${so.func}中使用了字符",
			"code": "MSR_10_2",
			"isCustom": "F",
			"override": "T",
			"master_id": "2046",
			"name": "char not allowed in arithmatic expression",
			"name_cn": "算术表达式中不允许使用字符",
			"desc_en": "Use basic character variables appropriately for addition and subtraction",
			"desc_cn": "正确使用基本字符型变量进行加减法运算",
			"abstract": "Use basic character variables appropriately for addition and subtraction",
			"explanation": "Since the data in the basic character variable does not represent a numeric value, the basic character variable should be used appropriately in the addition and subtraction expressions.",
			"abstract_cn": "正确使用基本字符型变量进行加减法运算",
			"explanation_cn": "由于基本字符型变量中的数据并不代表数值，在加法和减法表达式中应该正确地使用基本字符型变量。",
			"example_good": "///c:\n#include <stdio.h>\n\nint func( void );\n\nint func( void )\n{\n    // essentially character type declared\n  char char_var;   \n  char numb;\n  char_var = '9';\n  // convert numa to digit value 9\n  numb = char_var - '0';\n  return numb\n\n}\n",
			"example_bad": "///c:\n#include <stdio.h>\n\nint func( void );\n\nint func( void )\n{\n    // essentially character type declared\n    char char_var;\n    int numb;\n    char_var = '9';\n    // the result of char_var + '>' do not make sense\n    numb = char_var + '>';\n    return numb;\n\n}",
			"details_en": "#### Abstract\nUse basic character variables appropriately for addition and subtraction\n\n#### Explanation\nSince the data in the basic character variable does not represent a numeric value, the basic character variable should be used appropriately in the addition and subtraction expressions.",
			"details_cn": "#### 概要\n正确使用基本字符型变量进行加减法运算\n\n#### 解释\n由于基本字符型变量中的数据并不代表数值，在加法和减法表达式中应该正确地使用基本字符型变量。",
			"examples": {
				"good": {
					"cpp": "",
					"java": "",
					"c": "\n#include <stdio.h>\n\nint func( void );\n\nint func( void )\n{\n    // essentially character type declared\n  char char_var;   \n  char numb;\n  char_var = '9';\n  // convert numa to digit value 9\n  numb = char_var - '0';\n  return numb\n\n}\n",
					"general": ""
				},
				"bad": {
					"cpp": "",
					"java": "",
					"c": "\n#include <stdio.h>\n\nint func( void );\n\nint func( void )\n{\n    // essentially character type declared\n    char char_var;\n    int numb;\n    char_var = '9';\n    // the result of char_var + '>' do not make sense\n    numb = char_var + '>';\n    return numb;\n\n}",
					"general": ""
				}
			}
		},
		"id": 1631703140264
	},
	{
		"name": "A for loop should be well-formed",
		"code": "MSR_14_2",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the for loop is not well-formed",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中的for循环语句的格式不准确",
			"code": "MSR_14_2",
			"override": "T",
			"master_id": "2060",
			"name": "A for loop should be well-formed",
			"name_cn": "for循环应该是格式良好的",
			"compliance": "R",
			"desc_en": "A loop consists of three clauses. Firstly, a loop counter properly assigned and defined (empty is permissible). Secondly, a loop terminating expression that uses the loop counter, with no persistent side effects. And that expression does not contain objects modified in the loop body. Thirdly, an expression with the loop counter being modified and no other objects used that are modified in the loop body.",
			"desc_cn": "一个循环由三个子句组成。 首先，正确分配和定义一个循环计数器（允许为空）。 其次，使用循环计数器的循环终止表达式，没有持久的副作用。 并且该表达式不包含在循环体中修改的对象。 第三，循环计数器被修改且循环体中没有使用其他被修改的对象的表达式。",
			"abstract": "A for loop should be well-formed",
			"explanation": "The second and third clause of the for loop statement should not use any object that is modified in the for loop body. Using a restricted form of for loop will make code easier to check and review.",
			"abstract_cn": "for循环应该是格式良好的",
			"explanation_cn": "for循环语句的第二个和第三个子句不应使用在 for 循环体中修改的任何对象。 使用限制形式的 for 循环将使代码更容易检查和审查。",
			"example_good": "///c:\nvoid func() {\n    for (int i = 0; i < 5; i++) {\n        // Do something \n    }\n}",
			"example_bad": "///c:\nvoid func() {\n    for (int i = 0; i < 5; i++) {\n        // modifying the induction variable i. Error prone and hard to review\n        i = i + 4;\n    }\n}",
			"details_en": "#### Abstract\nA for loop should be well-formed\n\n#### Explanation\nThe second and third clause of the for loop statement should not use any object that is modified in the for loop body. Using a restricted form of for loop will make code easier to check and review.",
			"details_cn": "#### 概要\nfor循环应该是格式良好的\n\n#### 解释\nfor循环语句的第二个和第三个子句不应使用在 for 循环体中修改的任何对象。 使用限制形式的 for 循环将使代码更容易检查和审查。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nvoid func() {\n    for (int i = 0; i < 5; i++) {\n        // Do something \n    }\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nvoid func() {\n    for (int i = 0; i < 5; i++) {\n        // modifying the induction variable i. Error prone and hard to review\n        i = i + 4;\n    }\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1634891188014"
	},
	{
		"name": "Controlling expressions should not be invariant",
		"code": "MSR_14_3",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func} is using an invariant value for controlling expressions",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}的控制表达式不应是不变的",
			"code": "MSR_14_3",
			"override": "T",
			"master_id": "2061",
			"name": "Controlling expressions should not be invariant",
			"name_cn": "控制表达式不应是不变的",
			"compliance": "R",
			"desc_en": "Controlling expression of a statement should not be invariant",
			"desc_cn": "语句的控制表达式不应是不变的",
			"abstract": "Controlling expression of a statement should not be invariant",
			"explanation": "Using invariant values as controlling expresson can cause programming error. The compiler might even remove the code as it may not be able to be reached due to invariant expression. This might result in unwanted removal of defensive code.",
			"abstract_cn": "语句的控制表达式不应是不变的",
			"explanation_cn": "使用不变值作为控制表达式会导致编程错误。 编译器甚至可能会删除代码，因为由于表达式不变，它可能无法访问。 这可能会导致不必要地删除防御性代码。",
			"example_good": "///c:\n#include <stdbool.h>\n\nvoid func() {\n    // Compliant by exception 1\n    while (true) {\n        // Do something\n    } \n\n    // Compliant by exception 2\n    do {\n        // Do something\n    } while (0 == 1);\n}",
			"example_bad": "///c:\nvoid func() {\n    // The if statement always evaluates to false, dead code\n    if (10 > 11) {\n        // Do something\n    }\n}",
			"details_en": "#### Abstract\nControlling expression of a statement should not be invariant\n\n#### Explanation\nUsing invariant values as controlling expresson can cause programming error. The compiler might even remove the code as it may not be able to be reached due to invariant expression. This might result in unwanted removal of defensive code.",
			"details_cn": "#### 概要\n语句的控制表达式不应是不变的\n\n#### 解释\n使用不变值作为控制表达式会导致编程错误。 编译器甚至可能会删除代码，因为由于表达式不变，它可能无法访问。 这可能会导致不必要地删除防御性代码。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdbool.h>\n\nvoid func() {\n    // Compliant by exception 1\n    while (true) {\n        // Do something\n    } \n\n    // Compliant by exception 2\n    do {\n        // Do something\n    } while (0 == 1);\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nvoid func() {\n    // The if statement always evaluates to false, dead code\n    if (10 > 11) {\n        // Do something\n    }\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1634894787239"
	},
	{
		"name": "The goto statement should not be used",
		"code": "MSR_15_1",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func} uses the goto statement",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}使用了goto语句",
			"code": "MSR_15_1",
			"override": "T",
			"master_id": "2062",
			"name": "The goto statement should not be used",
			"name_cn": "不应该使用goto语句",
			"compliance": "A",
			"desc_en": "The goto statement should not be used",
			"desc_cn": "不应该使用goto语句",
			"abstract": "The goto statement should not be used",
			"explanation": "Using the goto statement without constraints can lead to unstructured and extremely difficult to understand programs.",
			"abstract_cn": "不应该使用goto语句",
			"explanation_cn": "在没有约束的情况下使用 goto 语句会导致程序无结构化且极难理解。",
			"example_good": "///c:\nvoid func() {\n    int num = 0;\n\n    num += 1;\n    // Do not use the goto statement\n}",
			"example_bad": "///c:\nvoid func() {\n    int num = 0;\n\n    P1:\n    num += 1;\n\n    // Using the goto statement can cause confusion\n    goto P1;\n}",
			"details_en": "#### Abstract\nThe goto statement should not be used\n\n#### Explanation\nUsing the goto statement without constraints can lead to unstructured and extremely difficult to understand programs.",
			"details_cn": "#### 概要\n不应该使用goto语句\n\n#### 解释\n在没有约束的情况下使用 goto 语句会导致程序无结构化且极难理解。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nvoid func() {\n    int num = 0;\n\n    num += 1;\n    // Do not use the goto statement\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nvoid func() {\n    int num = 0;\n\n    P1:\n    num += 1;\n\n    // Using the goto statement can cause confusion\n    goto P1;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1634895371139"
	},
	{
		"name": "The goto statement should jump to a label declared later in the same function",
		"code": "MSR_15_2",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the goto statement does not jump to a label declared later in the same function",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中的goto语句未跳转到稍后在同一函数中声明的标签",
			"code": "MSR_15_2",
			"override": "T",
			"master_id": "2063",
			"name": "The goto statement should jump to a label declared later in the same function",
			"name_cn": "goto语句应跳转到稍后在同一函数中声明的标签",
			"compliance": "R",
			"desc_en": "If a goto statement is really needed, it shall be a forward goto.",
			"desc_cn": "如果确实需要goto语句，则应为forward goto。",
			"abstract": "If a goto statement is really needed, it shall be a forward goto.",
			"explanation": "Since using the goto statement without constraints can lead to unstructured and extremely difficult to understand programs, the use of goto statement should be restricted. Using language provided iteration statement results in much more readable code.",
			"abstract_cn": "如果确实需要goto语句，则应为forward goto。",
			"explanation_cn": "由于使用没有约束的 goto 语句会导致程序非结构化且极难理解，因此应限制使用 goto 语句。 使用语言提供的迭代语句会产生更具可读性的代码。",
			"example_good": "///c:\nvoid func() {\n    int num = 0;\n\n    // No back jump in the code\n    goto P1;\n\n    P1:\n    num += 1;\n}\n",
			"example_bad": "///c:\nvoid func() {\n    int num = 0;\n\n    P1:\n    num += 1;\n\n    // Non-compliant as back jump is allowed\n    goto P1;\n}\n",
			"details_en": "#### Abstract\nIf a goto statement is really needed, it shall be a forward goto.\n\n#### Explanation\nSince using the goto statement without constraints can lead to unstructured and extremely difficult to understand programs, the use of goto statement should be restricted. Using language provided iteration statement results in much more readable code.",
			"details_cn": "#### 概要\n如果确实需要goto语句，则应为forward goto。\n\n#### 解释\n由于使用没有约束的 goto 语句会导致程序非结构化且极难理解，因此应限制使用 goto 语句。 使用语言提供的迭代语句会产生更具可读性的代码。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nvoid func() {\n    int num = 0;\n\n    // No back jump in the code\n    goto P1;\n\n    P1:\n    num += 1;\n}\n"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nvoid func() {\n    int num = 0;\n\n    P1:\n    num += 1;\n\n    // Non-compliant as back jump is allowed\n    goto P1;\n}\n"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1635133617722"
	},
	{
		"name": "A goto statement and its label must be in the same scope",
		"code": "MSR_15_3",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, a goto statement and its label are not in the same scope",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中的goto语句和它的标签不在同一范围内",
			"code": "MSR_15_3",
			"override": "T",
			"master_id": "2064",
			"name": "A goto statement and its label must be in the same scope",
			"name_cn": "goto语句和它的标签必须在同一范围内",
			"compliance": "R",
			"desc_en": "Label should be declared in the same scope as its goto statement.",
			"desc_cn": "标签应在与其goto语句相同的范围内声明。",
			"abstract": "Label should be declared in the same scope as its goto statement.",
			"explanation": "Using the goto statement without constraints can lead to unstructured and extremely difficult to understand programs. Allowing goto statement to jump between blocks or into nested blocks to a reference label make the code visually complex.",
			"abstract_cn": "标签应在与其goto语句相同的范围内声明。",
			"explanation_cn": "在没有约束的情况下使用goto语句会导致程序无结构化且极难理解。 允许goto语句在块之间跳转或在嵌套块中跳转到引用标签使代码在视觉上变得复杂。",
			"example_good": "///c:\nvoid func() {\n    int num = 0;\n\n    P1:\n        if (num == 5) {\n        P2:\n            num += 1;\n        }\n\n    // Jumping into the reference label outside of the nested block\n    goto P1;\n}\n",
			"example_bad": "///c:\nvoid func() {\n    int num = 0;\n\n    P1:\n        if (num == 5) {\n        P2:\n            num += 1;\n        }\n\n    // Jumping into nested label is non-compliant\n    goto P2;\n}",
			"details_en": "#### Abstract\nLabel should be declared in the same scope as its goto statement.\n\n#### Explanation\nUsing the goto statement without constraints can lead to unstructured and extremely difficult to understand programs. Allowing goto statement to jump between blocks or into nested blocks to a reference label make the code visually complex.",
			"details_cn": "#### 概要\n标签应在与其goto语句相同的范围内声明。\n\n#### 解释\n在没有约束的情况下使用goto语句会导致程序无结构化且极难理解。 允许goto语句在块之间跳转或在嵌套块中跳转到引用标签使代码在视觉上变得复杂。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nvoid func() {\n    int num = 0;\n\n    P1:\n        if (num == 5) {\n        P2:\n            num += 1;\n        }\n\n    // Jumping into the reference label outside of the nested block\n    goto P1;\n}\n"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nvoid func() {\n    int num = 0;\n\n    P1:\n        if (num == 5) {\n        P2:\n            num += 1;\n        }\n\n    // Jumping into nested label is non-compliant\n    goto P2;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1635133975885"
	},
	{
		"name": "Loop early exits should not use both break and goto in the same loop",
		"code": "MSR_15_4",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, loop early exits use both break and goto in the same loop",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}的循环提前退出在同一循环中同时使用了break和goto。",
			"code": "MSR_15_4",
			"override": "T",
			"master_id": "2065",
			"name": "Loop early exits should not use both break and goto in the same loop",
			"name_cn": "循环提前退出不应在同一循环中同时使用break和goto",
			"compliance": "A",
			"desc_en": "Should not use both goto and break in a loop for early exit",
			"desc_cn": "循环提前退出不应在同一循环中同时使用break和goto。",
			"abstract": "不应在循环中同时使用 goto 和 break 来提前退出",
			"explanation": "Using the goto statement without constraints can lead to unstructured and extremely difficult to understand programs. Restricting the number of exits in a loop helps simplify the source code.",
			"abstract_cn": "循环提前退出不应在同一循环中同时使用break和goto。",
			"explanation_cn": "在没有约束的情况下使用goto语句会导致程序无结构化且极难理解。 限制循环中的退出次数有助于简化源代码。",
			"example_good": "///c:\nvoid func() {\n    for (int i = 0; i < 5; i++) {\n        // Only use either break or goto, don",
			"example_bad": "///c:\nvoid func() {\n    for (int i = 0; i < 5; i++) {\n        // Multiple early termination\n        if (i == 2) {\n            break;\n        }\n        // Multiple early termination\n        else if (i == 2) {\n            goto EXIT;\n        }\n        else {\n            // Continue\n        }\n    }\n\n    EXIT:\n        ;\n}",
			"details_en": "#### Abstract\n不应在循环中同时使用 goto 和 break 来提前退出\n\n#### Explanation\nUsing the goto statement without constraints can lead to unstructured and extremely difficult to understand programs. Restricting the number of exits in a loop helps simplify the source code.",
			"details_cn": "#### 概要\n循环提前退出不应在同一循环中同时使用break和goto。\n\n#### 解释\n在没有约束的情况下使用goto语句会导致程序无结构化且极难理解。 限制循环中的退出次数有助于简化源代码。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nvoid func() {\n    for (int i = 0; i < 5; i++) {\n        // Only use either break or goto, don"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nvoid func() {\n    for (int i = 0; i < 5; i++) {\n        // Multiple early termination\n        if (i == 2) {\n            break;\n        }\n        // Multiple early termination\n        else if (i == 2) {\n            goto EXIT;\n        }\n        else {\n            // Continue\n        }\n    }\n\n    EXIT:\n        ;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1635134563597"
	},
	{
		"name": "Each if statement in if-else should have an else statement",
		"code": "MSR_15_7",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func} did not end with an else statement.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}的if-else缺少else语句。",
			"code": "MSR_15_7",
			"override": "T",
			"master_id": "2066",
			"name": "Each if statement in if-else should have an else statement",
			"name_cn": "if-else中的每一个if语句都应该有一个else语句",
			"compliance": "R",
			"desc_en": "Each if-else should have an if statement and end with an else statement.",
			"desc_cn": "if-else应包括if语句并以else语句结束。",
			"abstract": "Each if-else should have an if statement and end with an else statement.",
			"explanation": "Using the else statement to terminate the if ... else if constructs complements the requirement for a default clause in a switch statement ad is a kind of defensive programming.",
			"abstract_cn": "if-else应包括if语句并以else语句结束。",
			"explanation_cn": "使用else语句终止if...else if 结构补充了switch语句中对默认子句的要求，这是一种防御性编程。",
			"example_good": "///c:\n#include <stdbool.h>\n\nvoid func() {\n    bool flag;\n\n    if (flag == true) {\n        // Do something\n    }\n    else if (flag == false) {\n        // Do something\n    }\n    else {\n        // Add else statement as defensive programming\n        // Do something\n    }\n}",
			"example_bad": "///c:\n#include <stdbool.h>\n\nvoid func() {\n    bool flag;\n\n    if (flag == true) {\n        // Do something\n    }\n    else if (flag == false) {\n        // Do something\n    }\n    // Non-compliant as there is no else statement\n}",
			"details_en": "#### Abstract\nEach if-else should have an if statement and end with an else statement.\n\n#### Explanation\nUsing the else statement to terminate the if ... else if constructs complements the requirement for a default clause in a switch statement ad is a kind of defensive programming.",
			"details_cn": "#### 概要\nif-else应包括if语句并以else语句结束。\n\n#### 解释\n使用else语句终止if...else if 结构补充了switch语句中对默认子句的要求，这是一种防御性编程。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdbool.h>\n\nvoid func() {\n    bool flag;\n\n    if (flag == true) {\n        // Do something\n    }\n    else if (flag == false) {\n        // Do something\n    }\n    else {\n        // Add else statement as defensive programming\n        // Do something\n    }\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdbool.h>\n\nvoid func() {\n    bool flag;\n\n    if (flag == true) {\n        // Do something\n    }\n    else if (flag == false) {\n        // Do something\n    }\n    // Non-compliant as there is no else statement\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1635135725160"
	},
	{
		"name": "A default label should appear as either the first or the last switch label of a switch statement",
		"code": "MSR_16_5",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the default label for the switch statement was not placed in first or last.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}，switch语句的默认标签没有放在first或last。",
			"code": "MSR_16_5",
			"override": "T",
			"master_id": "2067",
			"name": "A default label should appear as either the first or the last switch label of a switch statement",
			"name_cn": "默认标签应作为switch语句的第一个或最后一个switch标签出现",
			"compliance": "R",
			"desc_en": "The default label for the switch statement should be placed in first or last.",
			"desc_cn": "switch语句的默认标签没有放在第一个或最后一个位置。",
			"abstract": "The default label for the switch statement is not placed in first or last.",
			"explanation": "Putting the default label anywhere else other than the first or last in a switch statement makes it difficult to locate.",
			"abstract_cn": "switch语句的默认标签没有放在第一个或最后一个位置。",
			"explanation_cn": "将默认标签放在switch语句中的第一个或最后一个以外的任何其他位置会使其难以定位。",
			"example_good": "///c:\n#include <stdio.h>\n\nvoid func() {\n    int num = 2;\n\n    switch(num + 2) {\n        case 1:\n            printf(\"case 1\");\n            break;\n        case 2:\n            printf(\"case 2\");\n            break;\n        default:\n            // Default case is placed at last\n            printf(\"default case\");\n            break;\n    }\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nvoid func() {\n    int num = 2;\n    switch(num + 2) {\n        case 1:\n            printf(\"case 1\");\n            break;\n        default:\n            // Default case is not at first or last\n            printf(\"default case\");\n            break;\n        case 2:\n            printf(\"case 2\");\n            break;\n    }\n}",
			"details_en": "#### Abstract\nThe default label for the switch statement is not placed in first or last.\n\n#### Explanation\nPutting the default label anywhere else other than the first or last in a switch statement makes it difficult to locate.",
			"details_cn": "#### 概要\nswitch语句的默认标签没有放在第一个或最后一个位置。\n\n#### 解释\n将默认标签放在switch语句中的第一个或最后一个以外的任何其他位置会使其难以定位。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func() {\n    int num = 2;\n\n    switch(num + 2) {\n        case 1:\n            printf(\"case 1\");\n            break;\n        case 2:\n            printf(\"case 2\");\n            break;\n        default:\n            // Default case is placed at last\n            printf(\"default case\");\n            break;\n    }\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func() {\n    int num = 2;\n    switch(num + 2) {\n        case 1:\n            printf(\"case 1\");\n            break;\n        default:\n            // Default case is not at first or last\n            printf(\"default case\");\n            break;\n        case 2:\n            printf(\"case 2\");\n            break;\n    }\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1635136242052"
	},
	{
		"name": "A switch-expression should not have essentially Boolean type",
		"code": "MSR_16_7",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, a switch expression was of boolean type.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}，switch表达式是布尔类型。",
			"code": "MSR_16_7",
			"override": "T",
			"master_id": "2068",
			"name": "A switch-expression should not have essentially Boolean type",
			"name_cn": "switch表达式不应具有本质上的布尔类型",
			"compliance": "R",
			"desc_en": "A switch expression should not be of boolean type.",
			"desc_cn": "switch表达式不应是布尔类型。",
			"abstract": "A switch expression should not be of boolean type.",
			"explanation": "Although it is possible to implement a switch statement controlling expression with a Boolean, it would be more appropriate to implement the logic with an if-else construct as defined by the standard.",
			"abstract_cn": "switch表达式不应是布尔类型。",
			"explanation_cn": "尽管可以使用布尔值实现switch语句控制表达式，但使用标准定义的if-else构造实现逻辑会更合适。",
			"example_good": "///c:\n#include <stdbool.h>\n#include <stdio.h>\n\nvoid func() {\n    int num = 0;\n    // If else is more appropriate than switch for controlling expression with boolean\n    if (num == 0) {\n        printf(\"True\");\n    }\n    else {\n        printf(\"default\");\n    }\n}",
			"example_bad": "///c:\n#include <stdbool.h>\n#include <stdio.h>\n\nvoid func() {\n    int num = 0;\n    // Switch with boolean caluse as the controlling expression is redundant\n    switch(num == 0) {\n        case true:\n            printf(\"True case\");\n            break;\n        default:\n            printf(\"default case\");\n            break;\n    }\n}",
			"details_en": "#### Abstract\nA switch expression should not be of boolean type.\n\n#### Explanation\nAlthough it is possible to implement a switch statement controlling expression with a Boolean, it would be more appropriate to implement the logic with an if-else construct as defined by the standard.",
			"details_cn": "#### 概要\nswitch表达式不应是布尔类型。\n\n#### 解释\n尽管可以使用布尔值实现switch语句控制表达式，但使用标准定义的if-else构造实现逻辑会更合适。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdbool.h>\n#include <stdio.h>\n\nvoid func() {\n    int num = 0;\n    // If else is more appropriate than switch for controlling expression with boolean\n    if (num == 0) {\n        printf(\"True\");\n    }\n    else {\n        printf(\"default\");\n    }\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdbool.h>\n#include <stdio.h>\n\nvoid func() {\n    int num = 0;\n    // Switch with boolean caluse as the controlling expression is redundant\n    switch(num == 0) {\n        case true:\n            printf(\"True case\");\n            break;\n        default:\n            printf(\"default case\");\n            break;\n    }\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1635136460765"
	},
	{
		"name": "The features of <stdarg.h> should not be used",
		"code": "MSR_17_1",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func},  features of <stdarg.h> were used.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}使用了<stdarg.h>的特性。",
			"code": "MSR_17_1",
			"override": "T",
			"master_id": "2069",
			"name": "The features of <stdarg.h> should not be used",
			"name_cn": "不得使用<stdarg.h>的特性",
			"compliance": "R",
			"desc_en": "The features of <stdarg.h> should not be used.",
			"desc_cn": "不能使用<stdarg.h>的特性。",
			"abstract": "The features of <stdarg.h> should not be used.",
			"explanation": "va_list, va_arg, va_start, va_end, and va_copy should never be used. There are many instances of undefined behaviour when the source code are not organized properly causing inconsistency in type or usages.",
			"abstract_cn": "不能使用<stdarg.h>的特性。",
			"explanation_cn": "不应使用va_list、va_arg、va_start、va_end和va_copy。 当源代码没有正确组织导致类型或用法不一致时，有许多未定义行为的实例。",
			"example_good": "///c:\n#include <stdarg.h>\n\nvoid func(double arg) {\n    double var;\n    \n    // Should not use <stdarg.h> for variable argument processing\n    var = arg;\n}",
			"example_bad": "///c:\n#include <stdarg.h>\n\nvoid func(va_list var_arg) {\n    double var;\n    \n    // Using va_list and va_arg can cause undefined behaviour\n    var = va_arg(var_arg, double);\n}",
			"details_en": "#### Abstract\nThe features of <stdarg.h> should not be used.\n\n#### Explanation\nva_list, va_arg, va_start, va_end, and va_copy should never be used. There are many instances of undefined behaviour when the source code are not organized properly causing inconsistency in type or usages.",
			"details_cn": "#### 概要\n不能使用<stdarg.h>的特性。\n\n#### 解释\n不应使用va_list、va_arg、va_start、va_end和va_copy。 当源代码没有正确组织导致类型或用法不一致时，有许多未定义行为的实例。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdarg.h>\n\nvoid func(double arg) {\n    double var;\n    \n    // Should not use <stdarg.h> for variable argument processing\n    var = arg;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdarg.h>\n\nvoid func(va_list var_arg) {\n    double var;\n    \n    // Using va_list and va_arg can cause undefined behaviour\n    var = va_arg(var_arg, double);\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1635143431884"
	},
	{
		"name": "Functions should not call themselves, either directly or indirectly",
		"code": "MSR_17_2",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func} called itself.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}调用了自身。",
			"code": "MSR_17_2",
			"override": "T",
			"master_id": "2070",
			"name": "Functions should not call themselves, either directly or indirectly",
			"name_cn": "函数不应直接或间接调用自身",
			"compliance": "R",
			"desc_en": "Functions should not call themselves, either directly or indirectly - recursive function (direct or indirect) should not be reused.",
			"desc_cn": "函数不得直接或间接调用自身 - 不得重用递归函数（直接或间接）。",
			"abstract": "Functions should not call themselves, either directly or indirectly - recursive function (direct or indirect) should not be reused.",
			"explanation": "When a function is calling itself, i.e. recursion, it can lead to stack space exhaustion. It is not possible to determine what the worst-case stack usage is before execution.",
			"abstract_cn": "函数不得直接或间接调用自身 - 不得重用递归函数（直接或间接）。",
			"explanation_cn": "当函数调用自身时，即递归，它会导致堆栈空间耗尽。 在执行之前无法确定最坏情况下的堆栈使用情况。",
			"example_good": "///c:\n#include <stdio.h>\n\nvoid func(int num){\n    // Implement recursion using for loop instead\n    for (int i = num; i == 0; i--){\n        printf(\"%d\\n\", i);\n    }\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nvoid func(int num){\n    if (num == 0) {\n        return;\n    }\n\n    printf(\"%d\\n\", num);\n\n    func(num - 1); // Using recursion unless tightly controlled can exceed available stack\n}",
			"details_en": "#### Abstract\nFunctions should not call themselves, either directly or indirectly - recursive function (direct or indirect) should not be reused.\n\n#### Explanation\nWhen a function is calling itself, i.e. recursion, it can lead to stack space exhaustion. It is not possible to determine what the worst-case stack usage is before execution.",
			"details_cn": "#### 概要\n函数不得直接或间接调用自身 - 不得重用递归函数（直接或间接）。\n\n#### 解释\n当函数调用自身时，即递归，它会导致堆栈空间耗尽。 在执行之前无法确定最坏情况下的堆栈使用情况。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func(int num){\n    // Implement recursion using for loop instead\n    for (int i = num; i == 0; i--){\n        printf(\"%d\\n\", i);\n    }\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func(int num){\n    if (num == 0) {\n        return;\n    }\n\n    printf(\"%d\\n\", num);\n\n    func(num - 1); // Using recursion unless tightly controlled can exceed available stack\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1635144708325"
	},
	{
		"name": "Parameters of array type should have specified sizes",
		"code": "MSR_17_5",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, parameters of array type did not have specific sizes.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}，数组类型的参数未确定其大小。",
			"code": "MSR_17_5",
			"override": "T",
			"master_id": "2071",
			"name": "Parameters of array type should have specified sizes",
			"name_cn": "数组类型的参数应具有特定大小",
			"compliance": "A",
			"desc_en": "Parameters of array type should have specified sizes.",
			"desc_cn": "数组类型的参数应具有特定大小。",
			"abstract": "Parameters of array type should have specified sizes.",
			"explanation": "Although it is legal in C to pass an array of the unspecified size to a parameter with a specified size, doing so can lead to unexpected behaviour such as array out of bound.",
			"abstract_cn": "数组类型的参数应具有特定大小。",
			"explanation_cn": "尽管在C中将未指定大小的数组传递给具有指定大小的参数是合法的，但这样做会导致意外行为，例如数组越界。",
			"example_good": "///c:\nvoid arr1 (int array[4]) {\n    // Do something\n}\n\nvoid func(int num){\n    int arr[4] = {1, 2, 3, 4};\n\n    // Array size match prototype\n    arr1(arr);\n}\n",
			"example_bad": "///c:\nvoid arr1 (int array[4]) {\n    // Do something\n}\n\nvoid func(int num){\n    int arr[3] = {1, 2, 3};\n\n    // Array size does not match prototype\n    arr1(arr);\n}",
			"details_en": "#### Abstract\nParameters of array type should have specified sizes.\n\n#### Explanation\nAlthough it is legal in C to pass an array of the unspecified size to a parameter with a specified size, doing so can lead to unexpected behaviour such as array out of bound.",
			"details_cn": "#### 概要\n数组类型的参数应具有特定大小。\n\n#### 解释\n尽管在C中将未指定大小的数组传递给具有指定大小的参数是合法的，但这样做会导致意外行为，例如数组越界。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nvoid arr1 (int array[4]) {\n    // Do something\n}\n\nvoid func(int num){\n    int arr[4] = {1, 2, 3, 4};\n\n    // Array size match prototype\n    arr1(arr);\n}\n"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nvoid arr1 (int array[4]) {\n    // Do something\n}\n\nvoid func(int num){\n    int arr[3] = {1, 2, 3};\n\n    // Array size does not match prototype\n    arr1(arr);\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1635145093759"
	},
	{
		"name": "A pointer resulting from arithmetic on a pointer operand shall address an element of the same array as that pointer operand",
		"code": "MSR_18_1",
		"rules": {
			"category": "",
			"mapping": "",
			"misra_c": "",
			"misra_cpp": "",
			"gjb5369": "",
			"gjb8114": "",
			"language": "",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func} assessed an undefined location with a pointer that went out of bound.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}使用了越界的指针评估未定义的位置。",
			"code": "MSR_18_1",
			"override": "T",
			"master_id": "2072",
			"name": "A pointer resulting from arithmetic on a pointer operand shall address an element of the same array as that pointer operand",
			"name_cn": "对指针操作数进行算术运算产生的指针应寻址与该指针操作数相同的数组中的元素",
			"severity": "H",
			"compliance": "R",
			"desc_en": "Pointer arithmatic should not cause an array out of bound access",
			"desc_cn": "指针运算不应导致数组越界访问",
			"abstract": "Pointer arithmatic should not cause an array out of bound access",
			"explanation": "Compilers can only determine at compile time whether an array boundary has been exceeded. No checks are done at run-time for invalid array indexing. Using invalid indexing can cause program to have erroneous behaviour.",
			"abstract_cn": "指针运算不应导致数组越界访问",
			"explanation_cn": "编译器只能在编译时确定是否超出了数组边界。 在运行时不检查无效的数组索引。 使用无效的索引会导致程序出现错误行为。",
			"example_good": "///c:\nvoid func(){\n    int arr[3] = {0, 1, 2};\n\n    // Points to one beyond only, still defined\n    int *p = &arr[3];\n}",
			"example_bad": "///c:\nvoid func(){\n    int arr[3] = {0, 1, 2};\n\n    // Points to two beyond, undefined\n    int *p = &arr[4];\n}",
			"details_en": "#### Abstract\nPointer arithmatic should not cause an array out of bound access\n\n#### Explanation\nCompilers can only determine at compile time whether an array boundary has been exceeded. No checks are done at run-time for invalid array indexing. Using invalid indexing can cause program to have erroneous behaviour.",
			"details_cn": "#### 概要\n指针运算不应导致数组越界访问\n\n#### 解释\n编译器只能在编译时确定是否超出了数组边界。 在运行时不检查无效的数组索引。 使用无效的索引会导致程序出现错误行为。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nvoid func(){\n    int arr[3] = {0, 1, 2};\n\n    // Points to one beyond only, still defined\n    int *p = &arr[3];\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nvoid func(){\n    int arr[3] = {0, 1, 2};\n\n    // Points to two beyond, undefined\n    int *p = &arr[4];\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1635145609184"
	},
	{
		"name": "The standard header file <tgmath.h> should not be used",
		"code": "MSR_21_11",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func} use the standard header file <tgmath.h>",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}使用标准头文件 <tgmath.h>",
			"code": "MSR_21_11",
			"override": "T",
			"master_id": "2073",
			"name": "The standard header file <tgmath.h> should not be used",
			"name_cn": "不得使用标准头文件 <tgmath.h>",
			"compliance": "R",
			"desc_en": "The standard header file <tgmath.h> should not be used",
			"desc_cn": "不得使用标准头文件 <tgmath.h>",
			"abstract": "The standard header file <tgmath.h> should not be used",
			"explanation": "Since using functions declared in tgmath.h can result in undefined behaviour, <tgmath.h> shall not be used",
			"abstract_cn": "不得使用标准头文件 <tgmath.h>",
			"explanation_cn": "因为使用 tgmath.h 中声明的函数可能会导致未定义的行为，所以不应该使用<tgmath.h>",
			"example_good": "",
			"example_bad": "///c:\n#include <tgmath.h>\n\nvoid func() {\n   float f1;\n   // Generic square root is used, can cause undefined behaviour\n   f1 = sqrt(49);\n}",
			"details_en": "#### Abstract\nThe standard header file <tgmath.h> should not be used\n\n#### Explanation\nSince using functions declared in tgmath.h can result in undefined behaviour, <tgmath.h> shall not be used",
			"details_cn": "#### 概要\n不得使用标准头文件 <tgmath.h>\n\n#### 解释\n因为使用 tgmath.h 中声明的函数可能会导致未定义的行为，所以不应该使用<tgmath.h>",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <tgmath.h>\n\nvoid func() {\n   float f1;\n   // Generic square root is used, can cause undefined behaviour\n   f1 = sqrt(49);\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1635409359459"
	},
	{
		"name": "The exception handling features of <fenv.h> should not be used",
		"code": "MSR_21_12",
		"rules": {
			"category": "",
			"mapping": "",
			"misra_c": "",
			"misra_cpp": "",
			"gjb5369": "",
			"gjb8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func} use exception handling features declared in <fenv.h>",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}使用了 <fenv.h> 中声明的异常处理特性",
			"code": "MSR_21_12",
			"override": "T",
			"master_id": "2074",
			"name": "The exception handling features of <fenv.h> should not be used",
			"name_cn": "不应使用 <fenv.h> 的异常处理功能",
			"compliance": "A",
			"desc_en": "The program used exception handling features declared in <fenv.h>",
			"desc_cn": "程序使用了 <fenv.h> 中声明的异常处理特性",
			"abstract": "The program used exception handling features declared in <fenv.h>",
			"explanation": "The floatin-point status flags may become unspecified in some circumstances. Attempting to access them may cause undefined behaviour. ",
			"abstract_cn": "程序使用了 <fenv.h> 中声明的异常处理特性",
			"explanation_cn": "在某些情况下，浮点状态标志可能变得未指定。 尝试访问它们可能会导致未定义的行为",
			"example_good": "",
			"example_bad": "///c:\n#include <fenv.h>\n#include <stdio.h>\n#include <math.h>\n\nvoid func() {\n   // Using exception handlinf features can cause undefined behaviour\n   feclearexcept(FE_ALL_EXCEPT);\n   \n   sqrt(-1);\n\n   if (fetestexcept(FE_INVALID)) {\n      printf(\"FE_INVALID casued by sqrt(-1\");\n   }\n}",
			"details_en": "#### Abstract\nThe program used exception handling features declared in <fenv.h>\n\n#### Explanation\nThe floatin-point status flags may become unspecified in some circumstances. Attempting to access them may cause undefined behaviour. ",
			"details_cn": "#### 概要\n程序使用了 <fenv.h> 中声明的异常处理特性\n\n#### 解释\n在某些情况下，浮点状态标志可能变得未指定。 尝试访问它们可能会导致未定义的行为",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <fenv.h>\n#include <stdio.h>\n#include <math.h>\n\nvoid func() {\n   // Using exception handlinf features can cause undefined behaviour\n   feclearexcept(FE_ALL_EXCEPT);\n   \n   sqrt(-1);\n\n   if (fetestexcept(FE_INVALID)) {\n      printf(\"FE_INVALID casued by sqrt(-1\");\n   }\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1635410221208"
	},
	{
		"name": "A loop counter should not have essentially floating type",
		"code": "MSR_14_1",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func} use floating point as a loop counter",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}使用了浮点作为循环计数器",
			"code": "MSR_14_1",
			"override": "T",
			"master_id": "2075",
			"name": "A loop counter should not have essentially floating type",
			"name_cn": "循环计数器不应具有本质上的浮动类型",
			"compliance": "R",
			"desc_en": "The program uses floating point as a loop counter which can cause mismatch betweeen expected and actual result.",
			"desc_cn": "该程序使用浮点作为循环计数器，这可能导致预期结果与实际结果不匹配。",
			"abstract": "The program uses floating point as a loop counter which can cause mismatch betweeen expected and actual result.",
			"explanation": "Using a floating point as a loop counter can cause accumulation of rounding errors. This might cause mismatch between the expected number of iterations and the actual number of iterations when the program runs depending on the implementation.",
			"abstract_cn": "该程序使用浮点作为循环计数器，这可能导致预期结果与实际结果不匹配。",
			"explanation_cn": "使用浮点数作为循环计数器会导致舍入误差的累积。 这可能会导致程序运行时预期迭代次数与实际迭代次数不匹配，具体取决于实现。",
			"example_good": "",
			"example_bad": "///c:\nvoid func() {\n    // Using float as a loop counter can lead to unexpected result\n    for (float f = 0.0f; f < 10.0f; f += 0.1f) {\n        // Do something\n    }\n}",
			"details_en": "#### Abstract\nThe program uses floating point as a loop counter which can cause mismatch betweeen expected and actual result.\n\n#### Explanation\nUsing a floating point as a loop counter can cause accumulation of rounding errors. This might cause mismatch between the expected number of iterations and the actual number of iterations when the program runs depending on the implementation.",
			"details_cn": "#### 概要\n该程序使用浮点作为循环计数器，这可能导致预期结果与实际结果不匹配。\n\n#### 解释\n使用浮点数作为循环计数器会导致舍入误差的累积。 这可能会导致程序运行时预期迭代次数与实际迭代次数不匹配，具体取决于实现。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nvoid func() {\n    // Using float as a loop counter can lead to unexpected result\n    for (float f = 0.0f; f < 10.0f; f += 0.1f) {\n        // Do something\n    }\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1635412602072"
	},
	{
		"name": "Every switch statement should have at least two switch-clauses",
		"code": "MSR_16_6",
		"rules": {
			"category": "",
			"mapping": "",
			"misra_c": "16_6",
			"misra_cpp": "6-4-8",
			"gjb5369": "",
			"gjb8114": "",
			"language": "",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func} have less than two switch-clause",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}有少于两个 switch 子句",
			"code": "MSR_16_6",
			"override": "T",
			"master_id": "2076",
			"name": "Every switch statement should have at least two switch-clauses",
			"name_cn": "每个 switch 语句应至少有两个 switch 子句",
			"compliance": "R",
			"desc_en": "Every switch statement should have more than one switch-clause",
			"desc_cn": "每个 switch 语句应该有多个 switch 子句",
			"abstract": "Every switch statement should have more than one switch-clause",
			"explanation": "Having a single path for a switch statement is not only redundant but also an indicative of programming error.",
			"abstract_cn": "每个 switch 语句应该有多个 switch 子句",
			"explanation_cn": "switch 语句只有一条路径不仅是多余的，而且也是编程错误的指示。",
			"example_good": "",
			"example_bad": "///c:\n#include <stdio.h>\n\nvoid func() {\n    int num = 2;\n    switch(num + 2) {\n        default:\n            // Only one switch-clause\n            printf(\"default case\");\n            break;\n    }\n}",
			"details_en": "#### Abstract\nEvery switch statement should have more than one switch-clause\n\n#### Explanation\nHaving a single path for a switch statement is not only redundant but also an indicative of programming error.",
			"details_cn": "#### 概要\n每个 switch 语句应该有多个 switch 子句\n\n#### 解释\nswitch 语句只有一条路径不仅是多余的，而且也是编程错误的指示。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func() {\n    int num = 2;\n    switch(num + 2) {\n        default:\n            // Only one switch-clause\n            printf(\"default case\");\n            break;\n    }\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1635474460724"
	},
	{
		"name": "Local variables should be initialized before being read",
		"code": "MSR_9_1",
		"rules": {
			"category": "",
			"mapping": "",
			"misra_c": "",
			"misra_cpp": "",
			"gjb5369": "",
			"gjb8114": "",
			"language": "",
			"msg_templ_en": "",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}，在设置之前就读取具有自动存储持续时间的对象的值",
			"code": "MSR_9_1",
			"override": "T",
			"master_id": "2077",
			"name": "Local variables should be initialized before being read",
			"name_cn": "局部变量在被读取之前应该被初始化",
			"compliance": "M",
			"desc_en": "Local variables should be initialized before being read",
			"desc_cn": "局部变量在被读取之前应该被初始化",
			"abstract": "Local variables should be initialized before being read",
			"explanation": "Objects with static storage duration are automatically initialized to zero unless initialized explicitly. Objects with atutomatic storage duration are not automatically initialized so that they can have indeterminate values.",
			"abstract_cn": "局部变量在被读取之前应该被初始化",
			"explanation_cn": "具有静态存储持续时间的对象会自动初始化为零\n除非显式初始化。 具有自动存储持续时间的对象不会自动初始化，因此它们可能具有不确定的值。",
			"example_good": "",
			"example_bad": "",
			"details_en": "#### Abstract\nLocal variables should be initialized before being read\n\n#### Explanation\nObjects with static storage duration are automatically initialized to zero unless initialized explicitly. Objects with atutomatic storage duration are not automatically initialized so that they can have indeterminate values.",
			"details_cn": "#### 概要\n局部变量在被读取之前应该被初始化\n\n#### 解释\n具有静态存储持续时间的对象会自动初始化为零\n除非显式初始化。 具有自动存储持续时间的对象不会自动初始化，因此它们可能具有不确定的值。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1635923801357"
	},
	{
		"name": "Subtraction between pointers should only be applied to pointers that address elements of the same array",
		"code": "MSR_18_2",
		"rules": {
			"category": "",
			"mapping": "",
			"misra_c": "",
			"misra_cpp": "",
			"gjb5369": "",
			"gjb8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}，pointer subtraction causes an array out of bound access",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}，指针减法导致了数组越界访问",
			"code": "MSR_18_2",
			"override": "T",
			"master_id": "2078",
			"name": "Subtraction between pointers should only be applied to pointers that address elements of the same array",
			"name_cn": "指针之间的减法应仅适用于寻址同一数组元素的指针",
			"compliance": "R",
			"desc_en": "Pointer subtraction should not cause access violation, such as array out of bound.",
			"desc_cn": "指针减法不应导致访问冲突，例如数组越界。",
			"abstract": "Pointer subtraction should not cause access violation, such as array out of bound.",
			"explanation": "If pointers do not point to elements of the same array or the element one beyond the end of that array, the subtraction between them is undefined behaviour.",
			"abstract_cn": "指针减法不应导致访问冲突，例如数组越界。",
			"explanation_cn": "如果指针不指向同一数组的元素或超出该数组末尾的元素，则它们之间的减法是未定义的行为。",
			"example_good": "",
			"example_bad": "///c:\nvoid func(){\n    int arr[3] = {0, 1, 2};\n\n    // Points to two beyond\n    int *p1 = &arr[0];\n    int *p2 = &arr[2];\n\n    ptrdiff_t diff;\n    diff = p1 - p2 // undefined\n}",
			"details_en": "#### Abstract\nPointer subtraction should not cause access violation, such as array out of bound.\n\n#### Explanation\nIf pointers do not point to elements of the same array or the element one beyond the end of that array, the subtraction between them is undefined behaviour.",
			"details_cn": "#### 概要\n指针减法不应导致访问冲突，例如数组越界。\n\n#### 解释\n如果指针不指向同一数组的元素或超出该数组末尾的元素，则它们之间的减法是未定义的行为。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nvoid func(){\n    int arr[3] = {0, 1, 2};\n\n    // Points to two beyond\n    int *p1 = &arr[0];\n    int *p2 = &arr[2];\n\n    ptrdiff_t diff;\n    diff = p1 - p2 // undefined\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1637137441796"
	},
	{
		"name": "The address of an object with automatic storage should not be copied to another object that persists after the first object has ceased to exist",
		"code": "MSR_18_6",
		"rules": {
			"category": "",
			"mapping": "",
			"misra_c": "",
			"misra_cpp": "",
			"gjb5369": "",
			"gjb8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}，the address of an object with automatic storage is copied to another object that persists after the first object has ceased to exist",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}，具有自动存储的对象的地址被复制到第一个对象不存在后仍然存在的另一个对象",
			"code": "MSR_18_6",
			"master_id": "2079",
			"name": "The address of an object with automatic storage should not be copied to another object that persists after the first object has ceased to exist",
			"name_cn": "具有自动存储的对象的地址不应复制到第一个对象不存在后仍然存在的另一个对象",
			"compliance": "R",
			"desc_en": "The address of an object with automatic storage should not be copied to another object that persists after the first object has ceased to exist",
			"desc_cn": "具有自动存储的对象的地址不应复制到第一个对象不存在后仍然存在的另一个对象",
			"abstract": "The address of an object with automatic storage should not be copied to another object that persists after the first object has ceased to exist",
			"explanation": "When the lifetime of one object expires, its address becomes indeterminate. Then the use of that inderterminate address would result in undefined behaviour.",
			"abstract_cn": "具有自动存储的对象的地址不应复制到第一个对象不存在后仍然存在的另一个对象",
			"explanation_cn": "当一个对象的生命周期到期时，其地址变得不确定。因此使用该中间终止地址将导致未定义的行为。",
			"example_good": "",
			"example_bad": "",
			"details_en": "#### Abstract\nThe address of an object with automatic storage should not be copied to another object that persists after the first object has ceased to exist\n\n#### Explanation\nWhen the lifetime of one object expires, its address becomes indeterminate. Then the use of that inderterminate address would result in undefined behaviour.",
			"details_cn": "#### 概要\n具有自动存储的对象的地址不应复制到第一个对象不存在后仍然存在的另一个对象\n\n#### 解释\n当一个对象的生命周期到期时，其地址变得不确定。因此使用该中间终止地址将导致未定义的行为。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1637147737612"
	},
	{
		"name": "All resources obtained dynamically by means of Standard Library functions should be released",
		"code": "MSR_22_1",
		"rules": {
			"category": "",
			"mapping": "",
			"misra_c": "",
			"misra_cpp": "",
			"gjb5369": "",
			"gjb8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}，resources obtained dynamically from Standard library functions are not relaeased.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}，通过标准库函数动态获取的资源没有被释放",
			"code": "MSR_22_1",
			"override": "T",
			"master_id": "2080",
			"name": "All resources obtained dynamically by means of Standard Library functions should be released",
			"name_cn": "所有通过标准库函数动态获取的资源都应该被释放",
			"compliance": "R",
			"desc_en": "Resources obtained dynamically from Standard library functions should be relaeased.",
			"desc_cn": "应释放从标准库函数动态获取的资源。",
			"abstract": "Resources obtained dynamically from Standard library functions should be relaeased.",
			"explanation": "It is possible for a failure to occur due to exhaustion of resources if those resources are not explicitly released . Releasing resources as soon as possible reduces the possibility of exhaustion.",
			"abstract_cn": "应释放从标准库函数动态获取的资源。",
			"explanation_cn": "如果没有明确释放这些资源，则可能由于资源耗尽而发生故障。 尽快释放资源可以减少耗尽的可能性。",
			"example_good": "",
			"example_bad": "",
			"details_en": "#### Abstract\nResources obtained dynamically from Standard library functions should be relaeased.\n\n#### Explanation\nIt is possible for a failure to occur due to exhaustion of resources if those resources are not explicitly released . Releasing resources as soon as possible reduces the possibility of exhaustion.",
			"details_cn": "#### 概要\n应释放从标准库函数动态获取的资源。\n\n#### 解释\n如果没有明确释放这些资源，则可能由于资源耗尽而发生故障。 尽快释放资源可以减少耗尽的可能性。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1637149414993"
	},
	{
		"name": "A block of memory should only be freed if it was allocated by Standard Library function",
		"code": "MSR_22_2",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}，a block of memory is freed when it was not allocated by Standard Library function",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}，不是由标准库函数分配的内存块被释放",
			"code": "MSR_22_2",
			"override": "T",
			"master_id": "2081",
			"name": "A block of memory should only be freed if it was allocated by Standard Library function",
			"name_cn": "内存块仅当由标准库函数分配时才可以被释放",
			"compliance": "M",
			"desc_en": "A block of memory should only be freed if it was allocated by Standard Library function",
			"desc_cn": "内存块仅当由标准库函数分配时才可以被释放",
			"abstract": "A block of memory should only be freed if it was allocated by Standard Library function",
			"explanation": "It is undefined behavior to freeing non-allocated memory or freeing the same allocated memory more than one time.",
			"abstract_cn": "内存块仅当由标准库函数分配时才可以被释放",
			"explanation_cn": "释放未分配的内存或多次释放相同的分配内存是未定义的行为。",
			"example_good": "",
			"example_bad": "",
			"details_en": "#### Abstract\nA block of memory should only be freed if it was allocated by Standard Library function\n\n#### Explanation\nIt is undefined behavior to freeing non-allocated memory or freeing the same allocated memory more than one time.",
			"details_cn": "#### 概要\n内存块仅当由标准库函数分配时才可以被释放\n\n#### 解释\n释放未分配的内存或多次释放相同的分配内存是未定义的行为。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1637151548710"
	},
	{
		"name": "There should be no attempt to write to a stream which has been opened as read-only",
		"code": "MSR_22_4",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the stream which is opened as read-only is written to.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}，以只读方式打开的流被写入。",
			"code": "MSR_22_4",
			"override": "T",
			"master_id": "2082",
			"name": "There should be no attempt to write to a stream which has been opened as read-only",
			"name_cn": "不应尝试写入已以只读方式打开的流",
			"compliance": "M",
			"desc_en": "Read-only stream should not be written to",
			"desc_cn": "不应写入以只读方式打开的流。",
			"abstract": "Read-only stream should not be written to",
			"explanation": "Since the Standard does not specify the behaviour if an attempt is made to write to a read-only stream, writting to a read-only stream is unsafe.",
			"abstract_cn": "不应写入以只读方式打开的流。",
			"explanation_cn": "由于标准没有指定尝试写入只读流时的行为，因此写入只读流是不安全的。",
			"example_good": "",
			"example_bad": "",
			"details_en": "#### Abstract\nRead-only stream should not be written to\n\n#### Explanation\nSince the Standard does not specify the behaviour if an attempt is made to write to a read-only stream, writting to a read-only stream is unsafe.",
			"details_cn": "#### 概要\n不应写入以只读方式打开的流。\n\n#### 解释\n由于标准没有指定尝试写入只读流时的行为，因此写入只读流是不安全的。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1637198001045"
	}
]