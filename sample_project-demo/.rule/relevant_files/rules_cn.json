[
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_2_3",
		"master_id": "2001",
		"severity": "H",
		"compliance": "A",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\ntypedef int used; // type is declared here\n\nint main()\n{\n    used a = 1; // type is used here\n    printf(\"%d\",a);\n    return 0;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\ntypedef int used; // type is declared but not used\n\nint main()\n{\n    printf(\"finished\");\n    return 0;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}包含未使用的数据类型的定义。",
		"name": "MSR_2_3",
		"desc": "不应该包含未使用的数据类型的定义",
		"details": "#### 概要\n不应该包含未使用的数据类型的定义\n\n#### 解释\n未定义的数据类型，不单止会导致会浪费资源，还会在审查该代码时难以确定是由于编程过程中的错误导致没有使用该数据类型，还是其只是代码的多余部分。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_2_6",
		"master_id": "2002",
		"severity": "H",
		"compliance": "A",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nint func( void );\n\nint func( void )\n{\n    int i = 5;\n    goto lab1; // label used\n    if (i != 5) i = 5;\nlab1: // label declared\n    return i;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nint func( void );\n\nint func( void )\n{\n    int i = 5;\n    if (i != 5) i = 5;\nlab1: // unused label declared\n    return i;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}使用了未使用的标签。",
		"name": "函数中不允许使用未使用的标签",
		"desc": "函数中不能声明未使用的标签",
		"details": "#### 概要\n函数中不能声明未使用的标签\n\n#### 解释\n代码的审查者无法判断未使用的标签是多余的还是因疏漏而未使用，因此不能声明未使用的标签。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_2_7",
		"master_id": "2003",
		"severity": "H",
		"compliance": "A",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nint Addtion(int a,int b,int c);\n\nint main()\n{\n    printf(\"%d\",Addtion(1,2,3));\n    return 0;\n}\nint Addtion(int a,int b,int c)\n{\n    return a+b+c; // every parameter is used\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nint Addtion(int a,int b,int c);\n\nint main()\n{\n    printf(\"%d\",Addtion(1,2,3));\n    return 0;\n}\n // three parameters are defined\nint Addtion(int a,int b,int c)\n{\n    return a+b; // only two of them are used\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中出现未使用的参数。",
		"name": "必须使用所有声明过的参数",
		"desc": "函数中不应出现未使用的参数",
		"details": "#### 概要\n函数中不应出现未使用的参数\n\n#### 解释\n函数应该使用其所有的参数。若函数未使用其所有的参数则其功能的实现很可能与在设计该函数时所希望达到的目的不相匹配。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_5_1",
		"master_id": "2004",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nint main()\n{\n    // the first 31 characters are distinct\n    int a_non_compliant_example_a = 1;\n    int a_non_compliant_example_b = 2; \n    int a;\n    a = a_non_compliant_example_a + a_non_compliant_example_b;\n    printf(\"%d\\n\",a);\n    return 0;\n} "
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nint main()\n{\n    // the first 31 characters are not distinct\n    int this_is_a_non_compliant_example_a = 1;\n    int this_is_a_non_compliant_example_b = 2; \n    int a;\n    a = this_is_a_non_compliant_example_a + this_is_a_non_compliant_example_b;\n    printf(\"%d\\n\",a);\n    return 0;\n} "
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中出现不唯一的外部标识符。",
		"name": "所有外部标识符必须是唯一的，最多31个字符",
		"desc": "外部标识符要求可区别",
		"details": "#### 概要\n外部标识符要求可区别\n\n#### 解释\n在C99标准中，外部标识符应至少满足前31个字符有区别，以确保所有外部标识符可通过前31个字符得以区分。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_5_2",
		"master_id": "2005",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\n// this example have two identifiers, first 31 characters are the same\nextern int this_is_a_non_compliant_example_a = 1; // first identifier, global scope\n\nint main()\n{\n    int a;\n    int this_is_a_non_compliant_example_b = 2; // two identifiers are defined in local scope\n    a = 1 + this_is_a_non_compliant_example_b;\n    printf (\"%d\\n\",a);\n    return 0;\n} "
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\n// this example have two identifiers, first 31 characters are the same\nextern int a_non_compliant_example_a = 1;\nextern int a_non_compliant_example_b = 2; // two indistinct identifiers are defined in the same scope\n\nint main()\n{\n    int a;\n    a = 1 + a_non_compliant_example_b;\n    printf(\"%d\\n\",a);\n    return 0;\n} "
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中出现不可被区分的标识符。",
		"name": "相同范围和名称空间的标识符必须是唯一的",
		"desc": "在同一作用域和命名空间中被声明的标识符应该可以被区分",
		"details": "#### 概要\n在同一作用域和命名空间中被声明的标识符应该可以被区分\n\n#### 解释\n在同一作用域内应该满足不同标识符的前31个字符不完全相同以进行区别。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_5_3",
		"master_id": "2006",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nint a = 3; // identifier defined, outer scope\n\nint main()\n{\n    int b; // identifier defined, inner scope, different form the outer one\n    b = 4;\n    printf(\"%d\",b);\n    return 0;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nint a = 3; // identifier defined, outer scope\n\nint main()\n{\n    int a; // identifier defined, inner scope, covering the outer one\n    a = 4;\n    printf(\"%d\",a);\n    return 0;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中出现相同标识符，",
		"name": "内部和外部作用域中的标识符必须不同",
		"desc": "内部作用域的标识符应与外部作用域的不同",
		"details": "#### 概要\n内部作用域的标识符应与外部作用域的不同\n\n#### 解释\n在内部作用域定义变量时应该避免与外部作用域同名，以防止产生歧义。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_5_6",
		"master_id": "2007",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\ntypedef int my_name; // unique typedef declared\n\nint main()\n{\n    int my_name_2 = 1; // unique variable declared \n    printf(\"%d\",my_name_2);\n    return 0;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\ntypedef int my_name; // typedef declared\n\nint main()\n{\n    int my_name = 1; // variable declared, same identifier\n    printf(\"%d\",my_name);\n    return 0;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中，typedef标识符不唯一。",
		"name": "typedef 名称应为唯一标识符",
		"desc": "typedef标识符必须唯一",
		"details": "#### 概要\ntypedef标识符必须唯一\n\n#### 解释\n除非该别名在头文件中被定义且该头文件被包含，否则所用typedef定义的别名在所有命名空间中必须唯一。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_5_7",
		"master_id": "2008",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nstruct my_name // unique tag declared\n{\n    int a;\n    int b;\n};\n\nint main()\n{\n    int my_name_2 = 1; // unique variable declared\n    printf(\"%d\",my_name_2);\n    return 0;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nstruct my_name // tag declared\n{\n    int a;\n    int b;\n};\n\nint main()\n{\n    int my_name = 1; // variable declared, same identifier\n    printf(\"%d\",my_name);\n    return 0;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中，标签名称不是唯一标识符。",
		"name": "标签名称应是唯一标识符",
		"desc": "结构体标签必须唯一",
		"details": "#### 概要\n结构体标签必须唯一\n\n#### 解释\n除非该结构体标签在头文件中被定义且该头文件被包含，否则所用标签在所有命名空间中必须唯一。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_6_1",
		"master_id": "2009",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nstruct str\n{\n    signed int a:2;   // signed int permitted\n    unsigned int b:2; // unsigned int permitted\n};\n\nint main()\n{\n    printf(\"finished\");\n    return 0;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nstruct str\n{\n    int a:2;   // plain int not permitted\n    float b:2; // float is inappropriate \n};\n\nint main()\n{\n    printf(\"finished\");\n    return 0;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中，位域未被声明为合适的数据类型。",
		"name": "位域类型不能是内置类型",
		"desc": "位域必须被声明为合适的数据类型",
		"details": "#### 概要\n位域必须被声明为合适的数据类型\n\n#### 解释\n在声明位域时，必须将其声明为规定的几种数据类型中的一种且在声明中signed与unsigned不可省略。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_6_2",
		"master_id": "2010",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nstruct str\n{\n    unsigned int a:1;   // single-bit bit field declared unsigned\n};\n\nint main()\n{\n    printf (\"finished\") ;\n    return 0;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nstruct str\n{\n    signed int a:1;   // single-bit bit field declared signed\n};\n\nint main()\n{\n    printf(\"finished\");\n    return 0;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中出现有符号的单位命名字段。",
		"name": "单位命名字段必须是无符号的",
		"desc": "只占一个位的位域不能为有符号型数据",
		"details": "#### 概要\n只占一个位的位域不能为有符号型数据\n\n#### 解释\n由于有符号型数据要求有第一位符号位，只占一个位的位域的位域不允许定义为有符号型的数据类型。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_7_4",
		"master_id": "2011",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nextern int foo (const char *a);\nextern int foo2 (const char *b);\n\nint func()\n{\n    const char *str = \"string\"; // str is not const-qualified\n    foo ( \"string\" );\n    foo2 ( \"string\" ); // string can not be modified\n    return 0;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nextern int foo (char *a);\nextern int foo2 (char *b);\n\nint func()\n{\n    char *str = \"string\"; // str is not const-qualified\n    foo ( \"string\" );\n    foo2 ( \"string\" ); // may be modified by foo\n    return 0;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中的字符串文字未分配给常量指针。",
		"name": "字符串文字只能分配给常量指针",
		"desc": "将字符串字面量通过指向常量的指针赋值给字符型",
		"details": "#### 概要\n将字符串字面量通过指向常量的指针赋值给字符型\n\n#### 解释\n由于常量字符串存储在静态存储区，对其的修改操作会出错，仅能将常量字符串复制给指向常量字符串的指针以防止其修改操作。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_8_4",
		"master_id": "2012",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nextern int func(int a); // extern function declared\n\nint func(int a) // extern compatible funtion defined\n{\n    return 0;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nextern int func(int a); // extern function declared\n\nint func(int a, int b) // parameters different\n{\n    return 0;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中的外部对象与其声明不兼容。",
		"name": "外部对象，在定义时必须与可见声明相同。",
		"desc": "在定义有外部链接的对象时，应保持与其声明兼容",
		"details": "#### 概要\n在定义有外部链接的对象时，应保持与其声明兼容\n\n#### 解释\n在定义具有外部链接的对象或者函数时，必须保持该对象或者函数的数据类型，参数数量等与外部的声明兼容。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_8_8",
		"master_id": "2013",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nstatic int func (int a); // function with internal linkage declared\n\nstatic int func (int a) // function defined with \"static\"\n{\n    return a;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nstatic int func (int a); // function with internal linkage declared\n\nint func (int a) // function defined without \"static\"\n{\n    return a;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中，具有内部链接的对象未被声明为静态。",
		"name": "具有内部链接的对象应声明为静态",
		"desc": "有内部链接的对象要加上static说明符",
		"details": "#### 概要\n有内部链接的对象要加上static说明符\n\n#### 解释\n在声明具有内部链接的对象或者函数时，必须加上static的说明符以保持声明的正确性。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_8_9",
		"master_id": "2014",
		"severity": "H",
		"compliance": "A",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nextern int foo (int *a);\nextern void foo2 ( void );\n\nint count ( void )\n{\n    static int num = 0; // object declared at block scope\n    num++; // object appears only in this function\n    return num;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nextern int foo(int *a);\nextern void foo2( void );\nstatic int num = 0; // object declared, global scope\n\nint count( void )\n{\n    num++; // object appears only in this function\n    return num;\n}\n\nextern void foo2( void )\n{\n    foo(&num); // object may be modified at outer scope\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中的对象未被定义在它出现的作用域内。",
		"name": "如果对象的标识符仅出现在单个函数中，则应在该范围内定义该对象",
		"desc": "对象应仅被定义在它出现的作用域内",
		"details": "#### 概要\n对象应仅被定义在它出现的作用域内\n\n#### 解释\n当一个对象仅仅在一定的作用域内作用时，应该将它定义在该作用域内以防止其他作用域改变了它的值。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_8_10",
		"master_id": "2015",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nstatic inline int func( void ); // inline function declared with internal linkage\nint func2( void );\n\nint func2( void )\n{\n    func();\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nextern inline int func( void ); // inline function declared with external linkage\nint func2( void );\n\nint func2( void )\n{\n    func();\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中的内联函数没有静态声明 。",
		"name": "内联函数应具有静态声明 ",
		"desc": "应该用静态存储类声明内联函数",
		"details": "#### 概要\n应该用静态存储类声明内联函数\n\n#### 解释\n引用外部链接的内联函数可能会影响执行的时间，因此应该用静态储存类声明内联函数。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_8_11",
		"master_id": "2016",
		"severity": "H",
		"compliance": "A",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nextern int array[20]; // declare array with external linkage and its size\nint foo ( void ) ;\n\nint foo ( void )\n{\n    return array[10];\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nextern int array[]; // declare array with external linkage but without size\nint foo( void );\n\nint foo ( void )\n{\n    return array[10]; // 10 may be bigger than actual array size\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中未明确外部链接的数组的大小。",
		"name": "声明带有外部链接的数组时，应明确指定其大小",
		"desc": "需要明确外部链接的数组的大小",
		"details": "#### 概要\n需要明确外部链接的数组的大小\n\n#### 解释\n为了保证一致性以及确定存储区的边界，在声明外部链接的数组时必须确定该数组的大小。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_8_12",
		"master_id": "2017",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\n// all implicitly-specified enmueration constants is unique\ntypedef enum weekday {thu = 4, fri, sat = 6, sun = 6};"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\n// implicitly-specified enmueration sat is not unique\ntypedef enum weekday {thu = 4, fri, sat, sun = 6};"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中的隐式指定的枚举常量列表不唯一。",
		"name": "隐式指定的枚举常量列表应是唯一的",
		"desc": "默认赋值的枚举成员的值唯一",
		"details": "#### 概要\n默认赋值的枚举成员的值唯一\n\n#### 解释\n为了避免枚举成员的值错误地重复，应该保证通过枚举值列表顺序默认赋值地枚举成员的值唯一。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_8_13",
		"master_id": "2018",
		"severity": "H",
		"compliance": "A",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func (const char *ptr);\n\nvoid func (const char *ptr) // pointer declared const-qualified\n{\n    // ptr pointed to is not modified\n    printf (\"%c\", *ptr);\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func (char *ptr);\n\nvoid func (char *ptr) // pointer declared is not const-qualified\n{\n    // ptr pointed to is not modified, it should be const-qualified\n    printf (\"%c\", *ptr);\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中指针声明不是常量。",
		"name": "指针应尽可能指向 const 限定的类型",
		"desc": "建议将指针声明限定为常量",
		"details": "#### 概要\n建议将指针声明限定为常量\n\n#### 解释\n指针应指向相同限定的类型。指针若是指向的限定类型不同，应进行显式转换。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_8_14",
		"master_id": "2019",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\n// restrict type qualifier removed\nextern void func (int * ptr1, int * ptr2);\nvoid func2 (void);\n\nvoid func2(void)\n{\n    int i;\n    int *a,*b;\n    a = b = &i;\n    func (a, b);\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\n// restrict-qualified parameters declared\nextern void func (int * restrict ptr1, int * restrict ptr2);\nvoid func2 (void);\n\nvoid func2(void)\n{\n    int i;\n    int *a,*b;\n    a = b = &i;\n    // overlap memory areas\n    func (a, b);\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中使用了restrict关键字",
		"name": "不能使用限制限定符",
		"desc": "尽量避免使用restrict关键字",
		"details": "#### 概要\n尽量避免使用restrict关键字\n\n#### 解释\n为防止指针指向的区域重合等问题，应该尽量避免使用restrict关键字。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_9_3",
		"master_id": "2020",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nint func( void );\n\nint func ( void )\n{\n    int a[10] = {0}; // array totally initialized\n    return a[9]; // a[9] is "
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nint func( void );\n\nint func ( void )\n{\n    int a[10] = {0, 0, 0}; // array only initialized three elements\n    return a[9]; // a[9] is still unknown value\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中的数组只被部分初始化",
		"name": "数组不应该部分初始化",
		"desc": "不能只初始化数组的一部分",
		"details": "#### 概要\n不能只初始化数组的一部分\n\n#### 解释\n为了保证在显式初始化数组后数组中不再存在未经过处理的值，在对数组进行显式初始化时也必须对数组内所有的元素进行显式初始化操作。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_9_4",
		"master_id": "2021",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func( void )\n{\n    // all elements initialized once\n    int arr[3] = { [ 0 ] = 3, [ 1 ] = 2, [ 2 ] = 1};\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func( void )\n{\n    // a[0] initialized twice\n    int arr[3] = { [ 0 ] = 3, [ 1 ] = 2, [ 2 ] = 1, [ 0 ] = 4};\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}，对象中的元素被初始化多于一次",
		"name": "不允许对对象中的元素进行多次初始化",
		"desc": "对象中的元素只能初始化一次",
		"details": "#### 概要\n对象中的元素只能初始化一次\n\n#### 解释\n在进行不按默认顺序的数组和结构体的初始化的时，必须注意不能对同一元素进行重复的初始化。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_9_5",
		"master_id": "2022",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nint func ( void );\n\nint func( void )\n{\n    // arr have designated initializer with size specified explicitly\n    int arr[10] = { [ 5 ] = 1};\n    return arr[ 9 ];\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nint func ( void );\n\nint func( void )\n{\n    // flexible array declared using designated initializer\n    int arr[] = { [ 5 ] = 1};\n    // array may not have the element arr[9]\n    return arr[ 9 ];\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}使用显式初始化的数组未声明其大小",
		"name": "如果在数组中使用初始值设定项，则必须知道其大小",
		"desc": "使用显式初始化的数组必须声明其大小",
		"details": "#### 概要\n使用显式初始化的数组必须声明其大小\n\n#### 解释\n为确定数组的最大的元素数量，使用显式初始化方法进行初始化的数组的大小必须是确定的。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_10_3",
		"master_id": "2023",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    short short_a;\n    int b;       // b declared as int for illustration\n    b = short_a; // short_a assigned to wider essential type object\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    short short_a;\n    long int b;\n    short_a = b; // c assigned to narrower essential type\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中出现向下转换表达式",
		"name": "不允许向下转换表达式",
		"desc": "不能为不同类型的对象赋值",
		"details": "#### 概要\n不能为不同类型的对象赋值\n\n#### 解释\n把表达式的值赋值给不恰当类型的或者大小不足以表示该值的数据类型的对象，都是错误的做法。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_10_4",
		"master_id": "2024",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    int int_var;\n    char char_var;\n    // int 1 added to char char_var, permitted\n    char_var += 1;\n    // int 1 added to int int_var, same type\n    int_var += 1;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    int int_var;\n    char char_var;\n    // float 1.0f added to char char_var, not permitted\n    char_var += 1.0f;\n    // float 1.0f added to int int_var, differnt type\n    int_var += 1.0f;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中同一操作符的两个操作数不是同一类型",
		"name": "操作数和类型转换",
		"desc": "同一操作符的两个操作数为同一类型",
		"details": "#### 概要\n同一操作符的两个操作数为同一类型\n\n#### 解释\n用二元或者三元操作数对两个不同的类型的操作数可能会使所得的值的部分信息丢失。因此在一般情况下，统一操作符的两操作数应该为同一类型。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_10_5",
		"master_id": "2025",
		"severity": "H",
		"compliance": "A",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    char char_var;\n    bool bool_var;\n    // int can be cast to char\n    char_var = ( char ) 1;\n    // int 1 can be cast to bool by exception\n    bool_var = ( bool ) 1;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    char char_var;\n    bool bool_var;\n    // expression 1.0f cast to an narrower type char\n    char_var = ( char ) 1.0f;\n    // char_var cast to narrower type bool\n    bool_var = ( bool ) char_var;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中表达式的值被转换为不适当的类型",
		"name": "表达式中相同的基本类型",
		"desc": "表达式的值不能被转换为不适当的类型",
		"details": "#### 概要\n表达式的值不能被转换为不适当的类型\n\n#### 解释\n在两种不适当的类型之间进行强制类型转换可能会导致数据的丢失或者改变，因此表达式的值不能不能被强制转换为不适当的类型。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_10_6",
		"master_id": "2026",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    long long_var;\n    short short_a, short_b;\n    short_a = 1\n    short_b = 1;\n    long_var = ( long )short_a + short_b; // explicitly converted to long\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    long int long_var;\n    short int short_a, short_b;\n    short_a = short_b = 1;\n    long_var = short_a + short_b; // implicitly converted to long\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中，使用复合表达式为更大的数据类型的对象赋值时未使用显式转换",
		"name": "复合表达式的赋值应保持相同的大小",
		"desc": "使用复合表达式为更大的数据类型的对象赋值应使用显式转换",
		"details": "#### 概要\n使用复合表达式为更大的数据类型的对象赋值应使用显式转换\n\n#### 解释\n将一个复合表达式的值转换为储存空间更大的数据类型并赋值给一个对象时必须要使用显式转换。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_10_7",
		"master_id": "2027",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    short int short_a, short_b;\n    long int long_a, long_b;\n    long_a = 1;\n    short_a = short_b = 2;\n    long_b = ( ( long ) short_a * short_b ) * long_a; // explicitly converted to long\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    short int short_a, short_b;\n    long int long_a, long_b;\n    long_a = 1;\n    short_a = short_b = 2;\n    long_b = (short_a * short_b) * long_a; // implicitly converted to long\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中，复合表达式作为操作数转化为更大的数据类型时未使用显式转换",
		"name": "对于复合表达式，不允许在任一侧进行任何向上转换",
		"desc": "复合表达式作为操作数转化为更大的数据类型时用显式转换",
		"details": "#### 概要\n复合表达式作为操作数转化为更大的数据类型时用显式转换\n\n#### 解释\n当复合表达式作为操作符的其中一个操作数并且需要转化为更大的数据类型时，必须使用显示转换。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_10_8",
		"master_id": "2028",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    float float_a, float_b;\n    int int_var;\n    float_a = float_b = 1.0f;\n    int_var = ( int ) float_a + ( int ) float_b; // float_a and float_b casted to type int\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    float float_a, float_b;\n    int int_var;\n    float_a = float_b = 1.0f;\n    int_var = ( int ) ( float_a + float_b ); // casted to inappropriate type int\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中，复合表达式的值被转换为不适当的数据类型",
		"name": "复合表达式不能向上转换",
		"desc": "复合表达式的值不能被转换为不适当的数据类型",
		"details": "#### 概要\n复合表达式的值不能被转换为不适当的数据类型\n\n#### 解释\n在数据类型转换中可能会导致数据的丢失或者改变，因此不能复合表达式的值不能被转换为不适当的数据类型。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_11_2",
		"master_id": "2029",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nunion uni\n{\n    int i;\n    char c;\n}; // union declared\nvoid func ( void );\n\nvoid func ( void )\n{\n    union uni union_var;\n    union_var.i =1;\n    int *ptr_int;\n    // ptr_int point to union_var.i\n    ptr_int = &union_var.i;\n    ptr_int = ( void * )ptr_union; // also allowed by exception\n\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nunion uni; // incomplete type declared\nvoid func ( void );\n\nvoid func ( void )\n{\n    union uni *ptr_union;\n    int *ptr_int; \n    // ptr_int converted to pointer to incomplete type\n    ptr_union = ( union uni * ) ptr_int;\n    // ptr_union (incomplete type) converted to int pointer\n    ptr_int = ( int * )ptr_union;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中，指向不完整类型的指针与其他类型的指针进行了转换",
		"name": "不能将指向不完整类型的指针转换为任何其他类型",
		"desc": "指向不完整类型的指针与其他类型的指针不能转换，反之亦然",
		"details": "#### 概要\n指向不完整类型的指针与其他类型的指针不能转换，反之亦然\n\n#### 解释\n对指向不完整类型的指针进行类型转换操作可能会破坏不完整类型的封装，因此不能对不完整类型的指针转换为其他类型的指针。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_11_3",
		"master_id": "2030",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    int *ptr_int;    // pointer to int declared\n    char *ptr_char;  // pointer to char declared\n    *ptr_char = NULL;\n    *ptr_int = NULL; // pointers point to null\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    int *ptr_int;                 // pointer to int declared\n    char *ptr_char;               // pointer to char declared\n    ptr_int = ( int * ) ptr_char; // convert to int type pointer\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中指针被转换为其他类型的指针",
		"name": "不同类型的指针之间不能相互转换",
		"desc": "不能将指针转换为其他类型的指针",
		"details": "#### 概要\n不能将指针转换为其他类型的指针\n\n#### 解释\n将指向一种类型的指针转换为另一种类型的指针可能会导致对齐错误以及未定义的行为，因此不能将指针转换为其他类型的指针。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_11_4",
		"master_id": "2031",
		"severity": "H",
		"compliance": "A",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    int *ptr_int;\n    int int_a, int_b;\n    int_a = 1;\n    ptr_int = &int_a; // ptr_int point to int_a\n    int_b = *ptr_int; // *ptr_int assigned to int_b\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    int *ptr_int;\n    int int_a, int_b;\n    int_a = 1;\n    ptr_int = ( int * ) int_a; // convert int to pointer\n    int_b = ( int ) ptr_int;   // convert pointer to type int\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中出现指针和整数相互转换",
		"name": "避免指针和整数相互转换",
		"desc": "避免指针和整数相互转换",
		"details": "#### 概要\n避免指针和整形的相互转换\n\n#### 解释\n在实现指针和整形的转换可能会导致整形的数据溢出或者指针无法正常对齐，因此尽可能避免指针和整形的相互转换。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_11_5",
		"master_id": "2032",
		"severity": "H",
		"compliance": "A",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    void *ptr_void; // void pointer declared\n    int *ptr_int;   // int pointer declared\n    int int_var;\n    ptr_int = &int_var;\n    // convert int pointer into void pointer\n    ptr_void = ( void * ) ptr_int;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    void *ptr_void; // void pointer declared\n    int *ptr_int;   // int pointer declared\n    int int_var;\n    ptr_void = &int_var;\n    // convert void pointer into int pointer\n    ptr_int = ( int * ) ptr_void;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中出现将空类型指针转换为指向其他对象的指针",
		"name": "避免将空类型指针转换为指向其他对象的指针",
		"desc": "避免将空类型指针转换为指向其他对象的指针",
		"details": "#### 概要\n避免将空类型指针转换为指向其他对象的指针\n\n#### 解释\n为了避免类型转换中可能会出现的指针对其的错误，应该避免将空类型指针转换为指向其他对象的指针。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_11_6",
		"master_id": "2033",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\n#define ZERO 0\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    void *ptr_void;\n    int int_var;\n    // ptr_void point to the address of int_var\n    ptr_void = &int_var;\n    ptr_void = (void *)ZERO;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    void *ptr_void;\n    int int_var;\n    // convert int_var to void pointer\n    ptr_void = ( void * ) int_var;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中出现空类型指针以及算术类型的转换",
		"name": "避免空指针和算术类型之间的转换",
		"desc": "不能进行空类型指针以及算术类型的转换",
		"details": "#### 概要\n不能进行空类型指针以及算术类型的转换\n\n#### 解释\n对空类型指针和算术类型相互的数据类型转换可能会引起对齐问题以及数据转换中出现未定义行为。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_11_7",
		"master_id": "2034",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    char char_a, char_b;\n    char *ptr_char;\n    char_a = "
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    char char_a, char_b;\n    char *ptr_char;\n    char_a = "
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中出现指向对象的指针与非整形的算术类型的转换",
		"name": "不能进行指向对象的指针与非整形的算术类型的转换",
		"desc": "不能进行指向对象的指针与非整形的算术类型的转换",
		"details": "#### 概要\n不能进行指向对象的指针与非整形的算术类型的转换\n\n#### 解释\n为了防止在类型转换过程中出现未定义行为，不应进行指向对象的指针与非整形算术类型的相互数据类型转换。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_11_8",
		"master_id": "2035",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n#include <malloc.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    // const pointer declared\n    int * const ptr_const = ( int *) malloc ( sizeof ( int ) );\n    int *ptr_int;\n    // ptr_int point to the address of ptr_const\n    ptr_int = ptr_const;\n    // more code that may change ptr_const\n    // ...\n    \n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n#include <malloc.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    volatile int *p_volatile;\n    // pointer to const declared\n    const int * ptr_const = ( int *) malloc ( sizeof ( int ) );\n    int *ptr_int;\n    // const qualifier removed in a cast\n    ptr_int = ( int * ) ptr_const;\n    ptr_int = (int *) p_volatile;\n    // more code that may change ptr_const\n    // ...\n    \n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中，指针的数据类型转换去除了const和volatile限定符",
		"name": "指针的数据类型转换不能去除const和volatile限定符",
		"desc": "指针的数据类型转换不能去除const和volatile限定符",
		"details": "#### 概要\n指针的数据类型转换不能去除const和volatile限定符\n\n#### 解释\n在进行指针的数据类型转换时不能去除定义中的const和volatile限定符，否则可能导致该指针的读写过程出现错误。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_11_9",
		"master_id": "2036",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    int *int_ptr = NULL; // ptr_int point to NULL\n    // NULL appear as an operand with the other operand a pointer\n    if ( int_ptr != (int *)NULL )\n    {\n        *int_ptr = NULL;\n    }\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    int *int_ptr = 0; // 0 assigned to ptr_int\n    // 0 appear as an operand with the other operand a pointer\n    if ( int_ptr != 0 )\n    {\n        *int_ptr = NULL;\n    }\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中空的整形指针不只能指向宏定义NULL",
		"name": "空的整形指针只能指向宏定义NULL",
		"desc": "空的整形指针只能指向宏定义NULL",
		"details": "#### 概要\n空的整形指针只能指向宏定义NULL\n\n#### 解释\n在向指针赋值，或使用指针作为等于、不等于或者三目运算符时，应能用宏定义NULL表示空的整形。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_12_2",
		"master_id": "2037",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdint.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    uint16_t uint16_var = 2;\n    uint32_t uint32_var;\n    // 17 is in the range 0 to the size of uint16_var\n    uint32_var = uint32_var << 17;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdint.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    uint16_t uint16_var = 2;\n    // 17 is bigger than the size of uint16_var\n    uint16_var = uint16_var << 17;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中，位移运算符的右操作数不是从零到左操作数的位数中取值",
		"name": "移位运算符的移位量必须小于操作数的位数",
		"desc": "位移运算符的右操作数应该从零到左操作数的位数中取值",
		"details": "#### 概要\n位移运算符的右操作数应该从零到左操作数的位数中取取值\n\n#### 解释\n位移运算符的右操作数应该为一个正整数，取值范围为零到左操作数的位数，取超出该范围的值为未定义的行为。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_12_3",
		"master_id": "2038",
		"severity": "H",
		"compliance": "A",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdint.h>\n\nstatic char a[ 10 ];\nvoid func ( void );\n\nvoid func ( void )\n{\n    int i;\n    char *p;\n    // same effect achieved by other mean\n    p = &a[ 0 ];\n    for ( i = 0; i < 10 ; ++i)\n    {\n        *p++ = i;\n    }\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdint.h>\n\nstatic char a[ 10 ];\nvoid func ( void );\n\nvoid func ( void )\n{\n    int i;\n    char *p;\n    // comma operator hard the readability of code\n    for ( i = 0, p = &a[ 0 ]; i < 10 ; ++i, *p++ = i);\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中使用了逗号运算符",
		"name": "不允许使用逗号运算符",
		"desc": "尽量不使用逗号运算符",
		"details": "#### 概要\n尽量不使用逗号运算符\n\n#### 解释\n由于使用逗号运算符会降低代码的可读性，因此要尽量避免使用逗号运算符。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_12_4",
		"master_id": "2039",
		"severity": "H",
		"compliance": "A",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\n#define MAXIMUM 0xffffffffu // maximum value of unsigned int\n\nconst unsigned int const_int = 1;\nvoid func( void );\n\nvoid func( void )\n{\n    unsigned int uint_var;\n    // 0xffffffff assigned to long_long_var\n    uint_var = MAXIMUM;\n    // uint_var + 1 and uint_var + const_int is not a constant expression\n    uint_var = uint_var + 1;\n    uint_var = uint_var + const_int;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\n#define MAXIMUM 0xffffffffu // value of unsigned int (assume int is 32 bits)\n#define ONE     0x1u\nvoid func( void );\n\nvoid func( void )\n{\n    unsigned int uint_var;\n    // the value of MAXIMUM + 1 lead to wrap-around\n    uint_var = MAXIMUM + ONE;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中，无符号整形常量表达式的值导致了回绕",
		"name": "无符号整形常量表达式的值不能导致回绕",
		"desc": "无符号整形常量表达式的值不能导致回绕",
		"details": "#### 概要\n无符号整形常量表达式的值不能导致回绕\n\n#### 解释\n为防止发生回绕，因此无符号整形常量表达式的值的取值范围应为零到无符号整形能表示的最大值。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_13_1",
		"master_id": "2040",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func( void );\n\nvoid func( void )\n{\n    int x = 0;\n    // array initialized with no side effect\n    int arr[2] = { 1, 2 };\n    // more code may call x\n    // ...\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func( void );\n\nvoid func( void )\n{\n    int x = 0;\n    // object x modified due to side effect\n    int arr[2] = { ++x, ++x };\n    // more code may call x\n    // ...\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中，初始化列表产生了副作用",
		"name": "初始化列表不应含有持久的副作用",
		"desc": "初始化列表不应该产生副作用",
		"details": "#### 概要\n初始化列表不应该产生副作用\n\n#### 解释\n为避免导致初始化的内容出现错误以及副作用影响程序运行，不应该在初始化列表中进行对其他参数赋值等产生副作用的操作。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_13_2",
		"master_id": "2041",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nint func( void );\n\nint func( void )\n{\n    int a = 6;\n    // the value will sure to be -60\n    a -= a*a;\n    a += a;\n    return a;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nint func( void );\n\nint func( void )\n{\n    int a = 6;\n\n    a += a -= a*a;\n    return a;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，表达式${so.func}的值在所有可能的运行顺序下不是唯一确定的。",
		"name": "持久副作用表达式应相同 ",
		"desc": "所有执行顺序下表达式的值及副作用一致",
		"details": "#### 概要\n所有执行顺序下表达式的值及副作用一致\n\n#### 解释\n由于表达式可能存在多种执行的顺序，设计表达式应该保证在所有可能的执行顺序下表达式的值以及其副作用都相同。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_13_3",
		"master_id": "2042",
		"severity": "H",
		"compliance": "A",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nint func( void );\n\nint func( void )\n{\n    int int_a, int_b, int_c;\n    int_a = int_b = 1;\n    // make the code more readable by this mean\n    ++int_a;\n    int_c = int_a * int_b;\n    int_b--;\n    return int_c;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nint func( void );\n\nint func( void )\n{\n    int int_a, int_b, int_c;\n    int_a = int_b = 1;\n    // the complex expression impairs the readability\n    int_c = ++int_a * int_b--;\n    return int_c;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中，增减量运算符出现额外的副作用",
		"name": "增减量运算符无副作用",
		"desc": "增减量运算符不能有额外的副作用",
		"details": "#### 概要\n增减量运算符不能有额外的副作用\n\n#### 解释\n避免混合使用增量或减量运算符与其他运算符，包括函数调用，否则可能损害程序可读性。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_13_4",
		"master_id": "2043",
		"severity": "H",
		"compliance": "A",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func( void );\n\nvoid func( void )\n{\n    bool bool_var;\n    bool_var = true;\n    // == is not an assignment operator\n    while (bool_var == true)\n    {\n        // some code that change bool_var\n        // ...\n    }\n    \n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nint func(int x, int y)\n{\n  int ret_var;\n  ret_var = 1;\n\n  while (0) {\n    // ...\n    if (x = 0) {  // typical typo interpreted as an assignment\n      ret_var = x = y; // non-compliant\n    }\n  }\n  return ret_var;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中赋值运算符的结果被使用",
		"name": "在表达式中分配运算符",
		"desc": "赋值运算符的结果不能被使用",
		"details": "#### 概要\n赋值运算符的结果不能被使用\n\n#### 解释\n由于会引入额外的副作用，赋值运算符的结果不能被作为一个值使用，否则会损害程序可读性。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_13_5",
		"master_id": "2044",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nstatic int int_a;\nvoid func( void );\nint func2( void );\nbool return_true( void );\n\nvoid func( void )\n{\n    int int_b;\n    \n    // right operand do not have side effect\n    if( return_true() || int_b == func2() );\n    // more code that may read int_a\n    // ...\n}\n\nint func2( void )\n{\n    return int_a + 1; // do not have side effect\n}\n\nbool return_true( void )\n{\n    return true;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nstatic int int_a;\nvoid func( void );\nint func2( void );\nbool return_true( void );\n\nvoid func( void )\n{\n    int int_b;\n    \n    // int_a is not modified as intended\n    if( return_true() || int_b == func2() );\n    // more code that may read int_a\n    // ...\n}\n\nint func2( void )\n{\n    int_a++; // side effect: int_a is modified\n    return int_a;\n}\n\nbool return_true( void )\n{\n    return true;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中，&&和||运算符的右操作数有副作用",
		"name": "&&和||运算符的右操作数不应该有副作用",
		"desc": "&&和||运算符的右操作数不能有副作用",
		"details": "#### 概要\n&&和||运算符的右操作数不能有副作用\n\n#### 解释\n为了防止右操作数不执行导致应有的副作用没有产生，&&和||运算符的右操作数不能产生副作用。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_13_6",
		"master_id": "2045",
		"severity": "H",
		"compliance": "M",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func( void );\n\nvoid func( void )\n{\n    int int_a, int_b;\n\n    // the operand do not have side effect\n    int_a = sizeof( int_b );\n    int_b++; // int_b modified as intended\n    // some code that may read int_b\n    // ...\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func( void );\n\nvoid func( void )\n{\n    int int_a, int_b;\n    \n    // int_b is not modified as intended\n    int_a = sizeof( int_b++ );\n    // some code that may read int_b\n    // ...\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中，sizeof的操作数有持续的副作用",
		"name": "sizeof 运算符的操作数不应有潜在的副作用",
		"desc": "sizeof的操作数不能有持续的副作用",
		"details": "#### 概要\nsizeof的操作数不能有持续的副作用\n\n#### 解释\n由于sizeof不一定会执行它的操作数中的表达式，sizeof的操作数不能产生副作用。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_18_4",
		"master_id": "2047",
		"severity": "L",
		"compliance": "A",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nvoid func(){\n    int arr[3] = {0, 1, 2};\n\n    int *ptr;\n    ptr = arr;\n    ptr++;  // ++ operator is allowed\n    ptr[1] = 0;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nvoid func(){\n    int arr[3] = {0, 1, 2};\n\n    int *ptr;\n    ptr = arr;\n\n    * (ptr + 1) = 0; // Using + in pointer arithmatic is confusing\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中，使用了除++和--之外的指针算术",
		"name": "不能使用指针算术，除了++和--",
		"desc": "不能使用指针算术，除了++和--",
		"details": "#### 概要\n不能使用指针算术，除了++和--\n\n#### 解释\n指针算法会让初学者感到困惑。表达式ptr+1可能被错误地解释为向ptr中保存的地址添加一个字节"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_18_8",
		"master_id": "2048",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nvoid foo(int n) {\n    int arr[n];\n}\n\nvoid func() {\n    foo(-1);\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中使用了可变长数组类型",
		"name": "不得使用可变长数组类型",
		"desc": "不得使用可变长数组类型",
		"details": "#### 概要\n不得使用可变长数组类型\n\n#### 解释\n使用可变长度数组类型将无法静态确定必须为堆栈保留的内存量"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_19_2",
		"master_id": "2049",
		"compliance": "A",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n#include <string.h>\n\nstruct Foo {\n    int i;\n    float f;\n    char str[10];\n};\n\nvoid func() {\n    struct Foo data;\n\n    data.i = 5;\n    data.f = 10.5;\n    strcpy(data.str, \"string\");\n\n    // Use struct instead of union to keep everything\n    printf(\"%d\\n\", data.i);\n    printf(\"%f\\n\", data.f);\n    printf(\"%s\\n\", data.str);\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\ntypedef union UnionT\n{\n  int    i;\n  char   c;\n  double d;\n} UNIONT;\n\ntypedef struct MyData\n{\n  int     tag;\n  UNIONT  u;\n} MYDATA;\n\n\nint foo(char ch_param)\n{\n   MYDATA md;\n\n   md.tag = 0;  // say, 0 for int, 1 for char, 2 for double\n   md.u.c = ch_param;\n\n   return md.u.i; // return is undefined\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中使用了联合",
		"name": "不得使用联合",
		"desc": "不得使用联合",
		"details": "#### 概要\n不得使用联合\n\n#### 解释\n如果读取的联合成员比写入的成员宽，则该值未指定。由于可以访问具有未指定值的字节，因此不应使用联合"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_21_3",
		"master_id": "2050",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid func() {\n\n    #define MAX_STR_SZ 10   \n    char str[MAX_STR_SZ];\n    strncpy(str, \"string\", MAX_STR_SZ);\n    \n    strcpy(str, \"string\");\n    printf(\"%s\", str);\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid func() {\n    char *str;\n\n    str = (char *) malloc(10);\n    strcpy(str, \"string\");\n    printf(\"%s\", str);\n\n    free(str);\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中使用了stdlib.h 中的内存分配相关函数",
		"name": "不得使用 stdlib.h 中的内存分配相关函数",
		"desc": "不得使用 stdlib.h 中的内存分配相关函数",
		"details": "#### 概要\n不得使用 stdlib.h 中的内存分配相关函数\n\n#### 解释\n在stdlib.h中使用内存分配相关函数可能会导致未定义的行为。例如：动态分配的内存可能不会随后释放"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_21_4",
		"master_id": "2051",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n#include <stdlib.h>\n#include <setjmp.h>\n\nvoid func() {\n    int val;\n    jmp_buf env_buffer;\n\n    val = setjmp(env_buffer);\n\n    // Set value to val after lngjmp\n    if (val != 0) {\n        printf(\"Return from longjmp with value = %d\", val);\n        exit(0);\n    }\n\n    // Jump back to top\n    printf(\"Jump to top\");\n    // Using longjmp and setjmp can cause undefined behaviour\n    longjmp(env_buffer, 10);\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中使用了setjmp.h ",
		"name": "不可以使用setjmp.h ",
		"desc": "不可以使用setjmp.h ",
		"details": "#### 概要\n不可以使用setjmp.h \n\n#### 解释\nSetjmp允许绕过正常的函数调用/返回机制。使用该选项可能导致未定义和未指定的行为"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_21_5",
		"master_id": "2052",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n#include <signal.h>\n#include <stdbool.h>\n#include <unistd.h>\n\nvoid sig_handler(int signum) {\n    printf(\"\\nInside handler function\\n\");\n}\n\nvoid func() { \n    // Register signal handler\n    // Using functions from signal.h can lead to undefined behaviour\n    signal(SIGINT,sig_handler); \n  \n    while(true) {    \n        printf(\"Inside func()\");    \n        sleep(1);  \n    }\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中使用了signal.h ",
		"name": "不可以使用signal.h ",
		"desc": "不可以使用signal.h ",
		"details": "#### 概要\n不可以使用signal.h \n\n#### 解释\n由于信号处理包含实现定义和未定义的行为，signal.h不得用于C90和C99模式"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_21_6",
		"master_id": "2053",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid bar_c(void* ptr)\n{\n    int* dest = (int*)ptr;\n    int data = (*dest);\n    int i;\n    int Buffer[10] = { 0 };\n    if(data >= 0)\n      {\n         Buffer[data] = 1;\n         for(i=0; i<10; i++)\n         {\n             printf(\"%d\", Buffer[i]);\n         }\n     }\n }\n\n void foo_v()\n {\n     int data;\n     data = -1;\n     fscanf(stdin, \"%d\", &data); // this can easily cause array out of bound\n     bar_c(&data);\n } "
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中使用了 stdio.h 中的 I/O 函数",
		"name": "不得使用 stdio.h 中的 I/O 函数",
		"desc": "不得使用 stdio.h 中的 I/O 函数",
		"details": "#### 概要\n不得使用 stdio.h 中的 I/O 函数\n\n#### 解释\n由于I/O具有未指定的、未定义的和实现定义的行为，因此在stdio.h中，I/O函数及其字符等价物不得用于C90和C99模式"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_21_7",
		"master_id": "2054",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <iostream>\n#include <cstdlib>\n\nint foo()\n{\n  char s[] = \"98\";\n  long num;\n\n  num = atol(s);\n\n  std::cout << \"number in long = \" << num << std::endl;\n    \n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中使用了 stdlib.h 中的 ascii 转换函数",
		"name": "不得使用 stdlib.h 中的 ascii 转换函数",
		"desc": "不得使用 stdlib.h 中的 ascii 转换函数",
		"details": "#### 概要\n不得使用 stdlib.h 中的 ascii 转换函数\n\n#### 解释\n由于atof、atol和atol函数在字符串无法转换时具有未定义的行为，因此它们不应用于C90和C99模式"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_21_8",
		"master_id": "2055",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid func () {\n   printf(\"Start of program\\n\");\n   \n   // Do not use abort, exit, getenv or system\n\n   printf(\"End of program\\n\");\n\n   return(0);\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(void)\n{\n  char* ptr_h;\n  char h[64];\n\n  ptr_h = getenv(\"HOME\");  // value of HOME could be > 64, need size guard\n  if (ptr_h != NULL) {\n    // ...\n  }\n  return 0;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中使用了 getenv、getenv 和 exit 函数",
		"name": "不得使用 getenv、getenv 和 exit 函数",
		"desc": "不得使用 getenv、getenv 和 exit 函数",
		"details": "#### 概要\n不得使用 getenv、getenv 和 exit 函数\n\n#### 解释\n由于getenv、getenv和exit函数具有未定义和实现定义的行为，因此它们不应用于C90和C99模式。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "",
		"code": "MSR_21_9",
		"master_id": "2056",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n#include <stdlib.h>\n\n\nint cmpfunc(const void * a, const void * b) {\n   return ( *(int*)a - *(int*)b );\n}\n\nint arr[] = { 1, 2, 3, 4, 5 };\n\nvoid func () {\n   int *item;\n   int key = 3;\n\n   // use bsearch to compare and find values of 3 in the array arr\n   item = (int*) bsearch (&key, arr, 5, sizeof (int), cmpfunc);\n   if( item != NULL ) {\n      printf(\"Found item\");\n   } else {\n      printf(\"Item is not in the array\");\n   }\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中使用了 bsearch 和 qsort",
		"name": "不得使用 bsearch 和 qsort",
		"desc": "不得使用 bsearch 和 qsort",
		"details": "#### 概要\n不得使用 bsearch 和 qsort\n\n#### 解释\n如果bsearch和qsort函数在比较元素时行为不一致，或者它们修改了任何元素，则该行为未定义。因此，它们不应用于C90和C99模式"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_21_10",
		"master_id": "2057",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n#include <time.h>\n \nvoid func (){\n   // Using time and date function can lead to undefined behaviour\n   printf(\"%ld\", time(NULL));\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中使用了 stdlib.h 中的时间和日期函数",
		"name": "不得使用 stdlib.h 中的时间和日期函数",
		"desc": "不得使用 stdlib.h 中的时间和日期函数",
		"details": "#### 概要\n不得使用 stdlib.h 中的时间和日期函数\n\n#### 解释\n由于时间和日期函数具有未指定、未定义和实现定义的行为，因此它们不应用于C90和C99模式。"
	},
	{
		"category": "",
		"mapping": "",
		"gjb5369": "",
		"gjb8114": "",
		"language": "c++",
		"code": "MSR_5_0_1",
		"master_id": "3001",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					"\n#define LEN 1024\n\nint array_int[LEN];\n\nint foo(int i, int j)\n{\n  if (j > 0) {\n    return i+1;\n  }\n  else\n    return i;\n}\n\nint bar(unsigned int parm_b)\n{\n  if (parm_b < LEN) {\n    unsigned int temp = parm_b++;\n    array_int[temp] = parm_b ;  // behavior is deterministic\n  \n  return parm_b;\n}\n\nint call_foo(int i)\n{\n  int j = i++;\n  return foo(j, i);  // return value non-ambiguous\n}"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					"\n#define LEN 1024\n\nint array_int[LEN];\n\nint foo(int i, int j)\n{\n  if (j > 0) {\n    return i+1;\n  }\n  else\n    return i;\n}\n\n\nint bar(unsigned int parm_b)\n{\n  if (parm_b < LEN)\n    array_int[parm_b++] = parm_b ;  // behavior is undefined\n  \n  return parm_b;\n}\n\n\nint call_foo(int i)\n{\n  return foo(i++, i);  // return value is implementation defined\n}\n"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}的结果值在任何编程语言允许的运行顺序下都不是一样的",
		"name": "MSR_5_0_1",
		"desc": "评估一个表达式及其副作用时，其结果值在任何编程语言允许的运行顺序下都应该是一样的",
		"details": "#### 概要\n评估一个表达式及其副作用时，其结果值在任何编程语言允许的运行顺序下都应该是一样的\n\n#### 解释\n由于表达式可能有多层运行顺序，表达式的设计应确保在所有可能的符合词法的运行顺序下，其结果值和副作用都是一样的。"
	},
	{
		"category": "",
		"mapping": "",
		"gjb5369": "",
		"gjb8114": "",
		"language": "c++",
		"code": "MSR_5_0_8",
		"master_id": "3002",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					"\nvoid func_5_0_8(int si, short sh_j, float flt_k)\n{\n  short  local_sh = 0x1234;\n  int    local_int1, local_int2;\n  float  local_flt = 1.0;\n  double local_dbl, local_dbl2;\n\n  local_int1 = static_cast< int > (int)local_sh + sh_j;  // compliant\n  local_int2 = static_cast< int > (local_sh) + sh_j;     // compliant\n\n  local_dbl2 = static_cast<double> ((double)flt_k) + local_flt;  // compliant\n  \n}"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					"\nvoid func_5_0_8(int si, short sh_j, float flt_k)\n{\n  short  local_sh = 0x1234;\n  int    local_int1, local_int2;\n  float  local_flt = 1.0;\n  double local_dbl, local_dbl2;\n\n  local_int1 = static_cast< int > (local_sh + sh_j);  // non-compliant\n\n  local_dbl2 = static_cast<double> (flt_k + local_flt);  // non-compliant\n  \n}"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中，表达式的值转换后大于表达式现有类型的大小",
		"name": "MSR_5_0_8",
		"desc": "表达式的值转换后不能大于表达式现有类型的大小",
		"details": "#### 概要\n表达式的值转换后不能大于表达式现有类型的大小\n\n#### 解释\n当表达式的值在转换后大于现有类型的大小时，有可能导致信息损失，譬如表达式值的符号。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c++",
		"code": "MSR_5_0_19",
		"master_id": "3003",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					"\nint array[10][20];\n\n// this example is equivalent to the \"avoid\" example\n// \nint mlk_three_indirect(int val)\n{\n  int j = val;\n  int *p = &j;\n  int **p_2, **r_2;\n  int *p_2_array = &array[*p][0];\n  int p3;\n  \n  array[val][0] = val;\n  p3 = array[val][0];\n  return p3;\n\n}"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					"\nint array[10][20];\n\nint mlk_three_indirect(int val)\n{\n  int j = val;\n  int *p = &j;\n  int **p_2, **r_2;\n  int *p_2_array = &array[*p][0];\n  int ***p3;\n\n  // ... \n  p_2 = &p;\n  \n  // ...\n  array[val][0] = **p_2;\n  \n  //...\n  r_2 = &p_2_array;\n  \n  // ...\n  p3 = &r_2;\n  \n  // ... \n  return ***p3;\n\n}"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}，在声明对象时有多于两层的间接指针",
		"name": "多于两层间接指针",
		"desc": "在声明对象时不能有多于两层的间接指针",
		"details": "#### 概要\n在声明对象时不能有多于两层的间接指针\n\n#### 解释\n当声明对象时有多于两层的间接指针，会引起至少三层的解引用，从而给理解程序预期的行为带来困难。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c++",
		"code": "MSR_8_5_3",
		"master_id": "3004",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					"\ntypedef enum color { red=3 } GoodEnum;   // compliant\n\n// compliant (but assignment not in sequence )\ntypedef enum bad_enum_color { white=0,\n         blue=1,         // 2 is not used \n         yellow=3 } BadEnum;  \n\ntypedef enum no_assign { NO_ONE, NO_TWO, NO_THREE } GoodEnum_NoAssign;\n\nextern void bar( color c, bad_enum_color b, no_assign n);\n\nvoid func_use(void)\n{\n  color var_color = red;\n  bad_enum_color var_bad_color = blue;\n  no_assign var_no_assign = NO_TWO;\n\n  bar(var_color, var_bad_color, var_no_assign);\n  return;\n}"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					"\ntypedef enum color { red=3 } GoodEnum;   // compliant\n\ntypedef enum bad_enum_color { white=0,\n\t\t\t      blue=1,\n\t\t\t      yellow } BadEnum;  // non-compliant\n\ntypedef enum no_assign { NO_ONE, NO_TWO, NO_THREE } GoodEnum_NoAssign;\n\nextern void bar( color c, bad_enum_color b, no_assign n);\n\nvoid func_use(void)\n{\n  color var_color = red;\n  bad_enum_color var_bad_color = blue;\n  no_assign var_no_assign = NO_TWO;\n\n  bar(var_color, var_bad_color, var_no_assign);\n  return;\n}"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中出现错误的枚举初始化",
		"name": "错误的枚举初始化",
		"desc": "对于带有“=”构造的枚举，显式初始化能初始化或者不初始化全部枚举，也能仅初始化第一个枚举",
		"details": "#### 概要\n对于带有“=”构造的枚举，显式初始化能初始化或者不初始化全部枚举，也能仅初始化第一个枚举\n\n#### 解释\n使用显式且一致的方式对枚举列表进行初始化，可以避免因混淆自动与手动赋值而造成错误，并且能使编译器发现枚举中可能是超出范围的错误。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c++",
		"code": "MSR_10_1_3",
		"master_id": "3005",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					"\nclass Expr {\n  int i;\npublic:\n  Expr(); // def constructor\n  Expr(const Expr&); // copy constructor\n\n  virtual Expr* newExpr() { i+=2; return new Expr(); }\n  virtual Expr* clone()   { i++; return new Expr(*this); }\n};\n\n\nclass B1 : public virtual Expr {};\nclass B2 : public virtual Expr {};\nclass B3 : public         Expr {};\n\nclass C  : public B1, B2 {};  // both B1 and B2 are virtual\n\nclass D  : public B3, B1 {};  // B3 and B1 are different base classes"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					"\nclass Expr {\n  int i;\npublic:\n  Expr(); // def constructor\n  Expr(const Expr&); // copy constructor\n\n  virtual Expr* newExpr() { i+=2; return new Expr(); }\n  virtual Expr* clone()   { i++; return new Expr(*this); }\n};\n\n\nclass B1 : public virtual Expr {};\nclass B2 : public virtual Expr {};\nclass B3 : public         Expr {};\n\n// B2 and B3 are virtual and non-virtual in a multiple inheritance hierarchy\nclass C  : public B1, B2, B3 {}; "
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中的基类在多继承体系中既是虚拟的又是非虚拟的",
		"name": "基类有虚拟和非虚拟的",
		"desc": "基类不能在多继承体系中既是虚拟的又是非虚拟的",
		"details": "#### 概要\n基类不能在多继承体系中既是虚拟的又是非虚拟的\n\n#### 解释\n如果基类在多继承体系中既是虚拟的又是非虚拟的，那么会在派生对象中产生多个基类子对象的复制版。这可能导致声明错误。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c++",
		"code": "MSR_12_1_1",
		"master_id": "3006",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					"\nclass Expr {\n  int i;\n  \npublic:\n  Expr(const Expr&); // copy constructor\n  virtual ~Expr ();\n\n  virtual Expr* newExpr() { i+=2; return new Expr(); }\n  virtual Expr* clone()   { i++; return new Expr(*this); }\n  Expr() {\n    Expr::clone();                // not a virtual call, hence compliant\n    clone();                      // a virtual call\n    // the following line must be removed from this constructor declaration\n    // commented out in the example to be clear\n    // dynamic_cast<Expr*> (this);  \n  }\n};\n"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					"\nclass Expr {\n  int i;\n  \npublic:\n  Expr(const Expr&); // copy constructor\n  virtual ~Expr ();\n\n  virtual Expr* newExpr() { i+=2; return new Expr(); }\n  virtual Expr* clone()   { i++; return new Expr(*this); }\n  Expr() {\n    Expr::clone();                // not a virtual call, hence compliant\n    clone();                      // a virtual call\n    dynamic_cast<Expr*> (this);   // non-compliant\n  }\n};\n"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中，对象的动态类型在构造函数或者析构函数本体使用",
		"name": "ctor 或 dtor 中的动态类型",
		"desc": "对象的动态类型不能在构造函数或者析构函数本体使用",
		"details": "#### 概要\n对象的动态类型不能在构造函数或者析构函数本体使用\n\n#### 解释\n对象的非静态成员能通过成员声明进行初始化（NSDMI)。为避免混淆，成员既可以通过NSDMI方式来初始化也可以通过构造函数来初始化，两种方式对于成员的初始化应该是一样的。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c++",
		"code": "MSR_12_1_2",
		"master_id": "3007",
		"compliance": "A",
		"examples": {
			"good": {
				"cpp": [
					"\nclass Base {\npublic:\n  Base() {}\n  Base(int i);\n};\n\n\nclass Derived1 : public virtual Base {\npublic:\n  Derived1() {}\n  Derived1(int) : Base(0) {}\n}; \n\nclass Derived2 : public virtual Base {\npublic:\n  Derived2() {}\n  Derived2(int) : Base(1) {}\n}; \n\n\nclass Hier : public Derived1, public Derived2 {\n  //  Hier()    {}\n  Hier(int) {} // constructor used is ambiguous w.r.t. Derived1 or Derived2\n\n};"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					"\nclass Base {\npublic:\n  Base() {}\n  Base(int i);\n};\n\n\nclass Derived1 : public virtual Base {\npublic:\n  Derived1() {}\n  Derived1(int) : Base(0) {}\n}; \n\nclass Derived2 : public virtual Base {\npublic:\n  Derived2() {}\n  Derived2(int) : Base(1) {}\n}; \n\n\nclass Hier : public Derived1, public Derived2 {\n  //  Hier()    {}\n  Hier(int) {} // constructor used is ambiguous w.r.t. Derived1 or Derived2\n\n};"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中ctor没有为其所有直接基类显式调用 ctor",
		"name": "ctor 必须为其所有直接基类显式调用 ctor",
		"desc": "ctor 必须为其所有直接基类显式调用 ctor",
		"details": "#### 概要\nctor 必须为其所有直接基类显式调用 ctor\n\n#### 解释\n"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_12_1_3",
		"master_id": "3008",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					"\nclass Base {\npublic:\n  Base() {}\n  explicit Base(int i);\n};\n\n\nclass Derived1 : public virtual Base {\npublic:\n  Derived1() {} \n  explicit Derived1(int) : Base(0) {}    // make explicit\n}; \n\nclass Derived2 : public virtual Base {\npublic:\n  Derived2() {}\n  explicit Derived2(int) : Base(1) {}    // make explicit\n}; \n\n\nclass Hier : public Derived1, public Derived2 {\n  explicit Hier(int) : Derived1(2), Derived2(), Base() {}  // make explicit\n\n};"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					"\n\nclass Base {\npublic:\n  Base(void) {}\n  Base(int i);\n};\n\n\nclass Derived1 : public virtual Base {\npublic:\n  Derived1() {}\n  Derived1(int) : Base(0) {}\n}; \n\nclass Derived2 : public virtual Base {\npublic:\n  Derived2() {}\n  Derived2(int) : Base(1) {}\n}; \n\nclass Hier : public Derived1, public Derived2 {\n  Hier(int)    {}\n};"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中，具有基本类型的单个参数的 ctor 不是显式的",
		"name": "具有基本类型的单个参数的 ctor 应该是显式的",
		"desc": "具有基本类型的单个参数的 ctor 应该是显式的",
		"details": "#### 概要\n具有基本类型的单个参数的 ctor 应该是显式的\n\n#### 解释\n"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_11_0_1",
		"master_id": "3009",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					"\ntypedef char    Letter;  \ntypedef Letter* pLetter;\n  \nclass Class_Without_POD    \n{\npublic:\n  Letter  c;  \n  pLetter p;\n};\n\nclass Class_with_POD\n{\nprivate:\n  char    c;         // will need interfaces to access and modify\n  char*   pc;  \n};"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					"\n#include <stdint.h>\n\ntypedef char    Letter;  \ntypedef Letter* pLetter;\n  \nclass Class_Without_POD    \n{\npublic:\n  Letter  c;  \n  pLetter p;\n};\n\nclass Class_with_POD\n{\npublic:\n  int8_t   c;         // POD has no default constructor\n  char*   pc;  \n};"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中，类中的非 POD 成员必须不是私有的",
		"name": "类中的非 POD 成员必须是私有的",
		"desc": "类中的非 POD 成员必须是私有的",
		"details": "#### 概要\n类中的非 POD 成员必须是私有的\n\n#### 解释\n"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c++",
		"code": "MSR_10_2_1",
		"master_id": "3010",
		"compliance": "A",
		"examples": {
			"good": {
				"cpp": [
					"\n\nclass Base {\npublic:\n  void func_char(char) {};\n};\n\nclass Derived : public Base {\npublic:\n  void func_int(int) {};\n};\n\n\nint foo(void)\n{\n  int   i;\n  char ch;\n  Derived example;\n\n  example.func_int(i);\n\n  example.func_char(ch);  // func(char) in Base is not visible \n  \n}"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					"\n\nclass Base {\npublic:\n  void func(char) {};\n};\n\nclass Derived : public Base {\npublic:\n  void func(int) {};\n};\n\n\nint foo(void)\n{\n  int   i;\n  char ch;\n  Derived example;\n\n  example.func(i);\n  example.func(ch);  // func(char) in Base is not visible \n  \n}"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中，继承层次结构中的所有可见名称不是唯一的",
		"name": "继承层次结构中的所有可见名称必须是唯一的",
		"desc": "继承层次结构中的所有可见名称必须是唯一的",
		"details": "#### 概要\n继承层次结构中的所有可见名称必须是唯一的\n\n#### 解释\n"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_17_7",
		"master_id": "2058",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nextern int func_ret_int(int, int);\n\n\nvoid bar(int n, int m)\n{\n  if (n > 0) {\n    n += func_ret_int(n, m);\n  }\n  else {\n    (void)func_ret_int(m, m); // func return value ignored\n  }\n}\n"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nextern int func_ret_int(int, int);\n\n\nvoid bar(int n, int m)\n{\n  if (n > 0) {\n    n += func_ret_int(n);\n  }\n  else {\n    func_ret_int(m); // func return value ignored\n  }\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}的返回值未被使用",
		"name": "应使用函数返回的值",
		"desc": "应使用具有非 void 返回类型的函数返回的值",
		"details": "#### 概要\n应使用具有非 void 返回类型的函数返回的值\n\n#### 解释\n对于 C90 和 C99 模式，不使用返回值调用函数可能是错误的。如果不打算显式使用函数的返回值，则应将其强制转换为 void 类型。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_17_8",
		"master_id": "2059",
		"compliance": "A",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func(int param){\n    // Only use param, do not ever modify it by assigning another value\n    printf(\"%d\\n\", param);\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func(int param){\n    // Modifying parameter can cause confusion\n    param = 5;\n    printf(\"%d\\n\", param);\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中函数的参数被修改",
		"name": "不得修改函数参数",
		"desc": "不得修改函数的参数",
		"details": "#### 概要\n不得修改函数的参数\n\n#### 解释\n对 C90 和 C99 模式而言，修改函数的参数可能会令人困惑并与程序员的期望相冲突。 所以不能修改函数的参数。"
	},
	{
		"category": "",
		"language": "c",
		"code": "MSR_10_2",
		"master_id": "2046",
		"examples": {
			"good": {
				"cpp": "",
				"java": "",
				"c": "\n#include <stdio.h>\n\nint func( void );\n\nint func( void )\n{\n    // essentially character type declared\n  char char_var;   \n  char numb;\n  char_var = '9';\n  // convert numa to digit value 9\n  numb = char_var - '0';\n  return numb\n\n}\n",
				"general": ""
			},
			"bad": {
				"cpp": "",
				"java": "",
				"c": "\n#include <stdio.h>\n\nint func( void );\n\nint func( void )\n{\n    // essentially character type declared\n    char char_var;\n    int numb;\n    char_var = '9';\n    // the result of char_var + '>' do not make sense\n    numb = char_var + '>';\n    return numb;\n\n}",
				"general": ""
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，算术表达式${so.func}中使用了字符",
		"name": "算术表达式中不允许使用字符",
		"desc": "正确使用基本字符型变量进行加减法运算",
		"details": "#### 概要\n正确使用基本字符型变量进行加减法运算\n\n#### 解释\n由于基本字符型变量中的数据并不代表数值，在加法和减法表达式中应该正确地使用基本字符型变量。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "",
		"code": "MSR_14_2",
		"master_id": "2060",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nvoid func() {\n    for (int i = 0; i < 5; i++) {\n        // Do something \n    }\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nvoid func() {\n    for (int i = 0; i < 5; i++) {\n        // modifying the induction variable i. Error prone and hard to review\n        i = i + 4;\n    }\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中的for循环语句的格式不准确",
		"name": "for循环应该是格式良好的",
		"desc": "一个循环由三个子句组成。 首先，正确分配和定义一个循环计数器（允许为空）。 其次，使用循环计数器的循环终止表达式，没有持久的副作用。 并且该表达式不包含在循环体中修改的对象。 第三，循环计数器被修改且循环体中没有使用其他被修改的对象的表达式。",
		"details": "#### 概要\nfor循环应该是格式良好的\n\n#### 解释\nfor循环语句的第二个和第三个子句不应使用在 for 循环体中修改的任何对象。 使用限制形式的 for 循环将使代码更容易检查和审查。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_14_3",
		"master_id": "2061",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdbool.h>\n\nvoid func() {\n    // Compliant by exception 1\n    while (true) {\n        // Do something\n    } \n\n    // Compliant by exception 2\n    do {\n        // Do something\n    } while (0 == 1);\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nvoid func() {\n    // The if statement always evaluates to false, dead code\n    if (10 > 11) {\n        // Do something\n    }\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}的控制表达式不应是不变的",
		"name": "控制表达式不应是不变的",
		"desc": "语句的控制表达式不应是不变的",
		"details": "#### 概要\n语句的控制表达式不应是不变的\n\n#### 解释\n使用不变值作为控制表达式会导致编程错误。 编译器甚至可能会删除代码，因为由于表达式不变，它可能无法访问。 这可能会导致不必要地删除防御性代码。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_15_1",
		"master_id": "2062",
		"compliance": "A",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nvoid func() {\n    int num = 0;\n\n    num += 1;\n    // Do not use the goto statement\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nvoid func() {\n    int num = 0;\n\n    P1:\n    num += 1;\n\n    // Using the goto statement can cause confusion\n    goto P1;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}使用了goto语句",
		"name": "不应该使用goto语句",
		"desc": "不应该使用goto语句",
		"details": "#### 概要\n不应该使用goto语句\n\n#### 解释\n在没有约束的情况下使用 goto 语句会导致程序无结构化且极难理解。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_15_2",
		"master_id": "2063",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nvoid func() {\n    int num = 0;\n\n    // No back jump in the code\n    goto P1;\n\n    P1:\n    num += 1;\n}\n"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nvoid func() {\n    int num = 0;\n\n    P1:\n    num += 1;\n\n    // Non-compliant as back jump is allowed\n    goto P1;\n}\n"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中的goto语句未跳转到稍后在同一函数中声明的标签",
		"name": "goto语句应跳转到稍后在同一函数中声明的标签",
		"desc": "如果确实需要goto语句，则应为forward goto。",
		"details": "#### 概要\n如果确实需要goto语句，则应为forward goto。\n\n#### 解释\n由于使用没有约束的 goto 语句会导致程序非结构化且极难理解，因此应限制使用 goto 语句。 使用语言提供的迭代语句会产生更具可读性的代码。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_15_3",
		"master_id": "2064",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nvoid func() {\n    int num = 0;\n\n    P1:\n        if (num == 5) {\n        P2:\n            num += 1;\n        }\n\n    // Jumping into the reference label outside of the nested block\n    goto P1;\n}\n"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nvoid func() {\n    int num = 0;\n\n    P1:\n        if (num == 5) {\n        P2:\n            num += 1;\n        }\n\n    // Jumping into nested label is non-compliant\n    goto P2;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}中的goto语句和它的标签不在同一范围内",
		"name": "goto语句和它的标签必须在同一范围内",
		"desc": "标签应在与其goto语句相同的范围内声明。",
		"details": "#### 概要\n标签应在与其goto语句相同的范围内声明。\n\n#### 解释\n在没有约束的情况下使用goto语句会导致程序无结构化且极难理解。 允许goto语句在块之间跳转或在嵌套块中跳转到引用标签使代码在视觉上变得复杂。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "",
		"code": "MSR_15_4",
		"master_id": "2065",
		"compliance": "A",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nvoid func() {\n    for (int i = 0; i < 5; i++) {\n        // Only use either break or goto, don"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nvoid func() {\n    for (int i = 0; i < 5; i++) {\n        // Multiple early termination\n        if (i == 2) {\n            break;\n        }\n        // Multiple early termination\n        else if (i == 2) {\n            goto EXIT;\n        }\n        else {\n            // Continue\n        }\n    }\n\n    EXIT:\n        ;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}的循环提前退出在同一循环中同时使用了break和goto。",
		"name": "循环提前退出不应在同一循环中同时使用break和goto",
		"desc": "循环提前退出不应在同一循环中同时使用break和goto。",
		"details": "#### 概要\n循环提前退出不应在同一循环中同时使用break和goto。\n\n#### 解释\n在没有约束的情况下使用goto语句会导致程序无结构化且极难理解。 限制循环中的退出次数有助于简化源代码。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_15_7",
		"master_id": "2066",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdbool.h>\n\nvoid func() {\n    bool flag;\n\n    if (flag == true) {\n        // Do something\n    }\n    else if (flag == false) {\n        // Do something\n    }\n    else {\n        // Add else statement as defensive programming\n        // Do something\n    }\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdbool.h>\n\nvoid func() {\n    bool flag;\n\n    if (flag == true) {\n        // Do something\n    }\n    else if (flag == false) {\n        // Do something\n    }\n    // Non-compliant as there is no else statement\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}的if-else缺少else语句。",
		"name": "if-else中的每一个if语句都应该有一个else语句",
		"desc": "if-else应包括if语句并以else语句结束。",
		"details": "#### 概要\nif-else应包括if语句并以else语句结束。\n\n#### 解释\n使用else语句终止if...else if 结构补充了switch语句中对默认子句的要求，这是一种防御性编程。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_16_5",
		"master_id": "2067",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func() {\n    int num = 2;\n\n    switch(num + 2) {\n        case 1:\n            printf(\"case 1\");\n            break;\n        case 2:\n            printf(\"case 2\");\n            break;\n        default:\n            // Default case is placed at last\n            printf(\"default case\");\n            break;\n    }\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func() {\n    int num = 2;\n    switch(num + 2) {\n        case 1:\n            printf(\"case 1\");\n            break;\n        default:\n            // Default case is not at first or last\n            printf(\"default case\");\n            break;\n        case 2:\n            printf(\"case 2\");\n            break;\n    }\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}，switch语句的默认标签没有放在first或last。",
		"name": "默认标签应作为switch语句的第一个或最后一个switch标签出现",
		"desc": "switch语句的默认标签没有放在第一个或最后一个位置。",
		"details": "#### 概要\nswitch语句的默认标签没有放在第一个或最后一个位置。\n\n#### 解释\n将默认标签放在switch语句中的第一个或最后一个以外的任何其他位置会使其难以定位。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_16_7",
		"master_id": "2068",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdbool.h>\n#include <stdio.h>\n\nvoid func() {\n    int num = 0;\n    // If else is more appropriate than switch for controlling expression with boolean\n    if (num == 0) {\n        printf(\"True\");\n    }\n    else {\n        printf(\"default\");\n    }\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdbool.h>\n#include <stdio.h>\n\nvoid func() {\n    int num = 0;\n    // Switch with boolean caluse as the controlling expression is redundant\n    switch(num == 0) {\n        case true:\n            printf(\"True case\");\n            break;\n        default:\n            printf(\"default case\");\n            break;\n    }\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}，switch表达式是布尔类型。",
		"name": "switch表达式不应具有本质上的布尔类型",
		"desc": "switch表达式不应是布尔类型。",
		"details": "#### 概要\nswitch表达式不应是布尔类型。\n\n#### 解释\n尽管可以使用布尔值实现switch语句控制表达式，但使用标准定义的if-else构造实现逻辑会更合适。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_17_1",
		"master_id": "2069",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdarg.h>\n\nvoid func(double arg) {\n    double var;\n    \n    // Should not use <stdarg.h> for variable argument processing\n    var = arg;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdarg.h>\n\nvoid func(va_list var_arg) {\n    double var;\n    \n    // Using va_list and va_arg can cause undefined behaviour\n    var = va_arg(var_arg, double);\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}使用了<stdarg.h>的特性。",
		"name": "不得使用<stdarg.h>的特性",
		"desc": "不能使用<stdarg.h>的特性。",
		"details": "#### 概要\n不能使用<stdarg.h>的特性。\n\n#### 解释\n不应使用va_list、va_arg、va_start、va_end和va_copy。 当源代码没有正确组织导致类型或用法不一致时，有许多未定义行为的实例。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_17_2",
		"master_id": "2070",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func(int num){\n    // Implement recursion using for loop instead\n    for (int i = num; i == 0; i--){\n        printf(\"%d\\n\", i);\n    }\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func(int num){\n    if (num == 0) {\n        return;\n    }\n\n    printf(\"%d\\n\", num);\n\n    func(num - 1); // Using recursion unless tightly controlled can exceed available stack\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}调用了自身。",
		"name": "函数不应直接或间接调用自身",
		"desc": "函数不得直接或间接调用自身 - 不得重用递归函数（直接或间接）。",
		"details": "#### 概要\n函数不得直接或间接调用自身 - 不得重用递归函数（直接或间接）。\n\n#### 解释\n当函数调用自身时，即递归，它会导致堆栈空间耗尽。 在执行之前无法确定最坏情况下的堆栈使用情况。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_17_5",
		"master_id": "2071",
		"compliance": "A",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nvoid arr1 (int array[4]) {\n    // Do something\n}\n\nvoid func(int num){\n    int arr[4] = {1, 2, 3, 4};\n\n    // Array size match prototype\n    arr1(arr);\n}\n"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nvoid arr1 (int array[4]) {\n    // Do something\n}\n\nvoid func(int num){\n    int arr[3] = {1, 2, 3};\n\n    // Array size does not match prototype\n    arr1(arr);\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}，数组类型的参数未确定其大小。",
		"name": "数组类型的参数应具有特定大小",
		"desc": "数组类型的参数应具有特定大小。",
		"details": "#### 概要\n数组类型的参数应具有特定大小。\n\n#### 解释\n尽管在C中将未指定大小的数组传递给具有指定大小的参数是合法的，但这样做会导致意外行为，例如数组越界。"
	},
	{
		"category": "",
		"mapping": "",
		"gjb5369": "",
		"gjb8114": "",
		"language": "",
		"code": "MSR_18_1",
		"master_id": "2072",
		"severity": "H",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nvoid func(){\n    int arr[3] = {0, 1, 2};\n\n    // Points to one beyond only, still defined\n    int *p = &arr[3];\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nvoid func(){\n    int arr[3] = {0, 1, 2};\n\n    // Points to two beyond, undefined\n    int *p = &arr[4];\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}使用了越界的指针评估未定义的位置。",
		"name": "对指针操作数进行算术运算产生的指针应寻址与该指针操作数相同的数组中的元素",
		"desc": "指针运算不应导致数组越界访问",
		"details": "#### 概要\n指针运算不应导致数组越界访问\n\n#### 解释\n编译器只能在编译时确定是否超出了数组边界。 在运行时不检查无效的数组索引。 使用无效的索引会导致程序出现错误行为。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_21_11",
		"master_id": "2073",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <tgmath.h>\n\nvoid func() {\n   float f1;\n   // Generic square root is used, can cause undefined behaviour\n   f1 = sqrt(49);\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}使用标准头文件 <tgmath.h>",
		"name": "不得使用标准头文件 <tgmath.h>",
		"desc": "不得使用标准头文件 <tgmath.h>",
		"details": "#### 概要\n不得使用标准头文件 <tgmath.h>\n\n#### 解释\n因为使用 tgmath.h 中声明的函数可能会导致未定义的行为，所以不应该使用<tgmath.h>"
	},
	{
		"category": "",
		"mapping": "",
		"gjb5369": "",
		"gjb8114": "",
		"language": "c",
		"code": "MSR_21_12",
		"master_id": "2074",
		"compliance": "A",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <fenv.h>\n#include <stdio.h>\n#include <math.h>\n\nvoid func() {\n   // Using exception handlinf features can cause undefined behaviour\n   feclearexcept(FE_ALL_EXCEPT);\n   \n   sqrt(-1);\n\n   if (fetestexcept(FE_INVALID)) {\n      printf(\"FE_INVALID casued by sqrt(-1\");\n   }\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}使用了 <fenv.h> 中声明的异常处理特性",
		"name": "不应使用 <fenv.h> 的异常处理功能",
		"desc": "程序使用了 <fenv.h> 中声明的异常处理特性",
		"details": "#### 概要\n程序使用了 <fenv.h> 中声明的异常处理特性\n\n#### 解释\n在某些情况下，浮点状态标志可能变得未指定。 尝试访问它们可能会导致未定义的行为"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_14_1",
		"master_id": "2075",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nvoid func() {\n    // Using float as a loop counter can lead to unexpected result\n    for (float f = 0.0f; f < 10.0f; f += 0.1f) {\n        // Do something\n    }\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}使用了浮点作为循环计数器",
		"name": "循环计数器不应具有本质上的浮动类型",
		"desc": "该程序使用浮点作为循环计数器，这可能导致预期结果与实际结果不匹配。",
		"details": "#### 概要\n该程序使用浮点作为循环计数器，这可能导致预期结果与实际结果不匹配。\n\n#### 解释\n使用浮点数作为循环计数器会导致舍入误差的累积。 这可能会导致程序运行时预期迭代次数与实际迭代次数不匹配，具体取决于实现。"
	},
	{
		"category": "",
		"mapping": "",
		"gjb5369": "",
		"gjb8114": "",
		"language": "",
		"code": "MSR_16_6",
		"master_id": "2076",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func() {\n    int num = 2;\n    switch(num + 2) {\n        default:\n            // Only one switch-clause\n            printf(\"default case\");\n            break;\n    }\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}有少于两个 switch 子句",
		"name": "每个 switch 语句应至少有两个 switch 子句",
		"desc": "每个 switch 语句应该有多个 switch 子句",
		"details": "#### 概要\n每个 switch 语句应该有多个 switch 子句\n\n#### 解释\nswitch 语句只有一条路径不仅是多余的，而且也是编程错误的指示。"
	},
	{
		"category": "",
		"mapping": "",
		"gjb5369": "",
		"gjb8114": "",
		"language": "",
		"code": "MSR_9_1",
		"master_id": "2077",
		"compliance": "M",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}，在设置之前就读取具有自动存储持续时间的对象的值",
		"name": "局部变量在被读取之前应该被初始化",
		"desc": "局部变量在被读取之前应该被初始化",
		"details": "#### 概要\n局部变量在被读取之前应该被初始化\n\n#### 解释\n具有静态存储持续时间的对象会自动初始化为零\n除非显式初始化。 具有自动存储持续时间的对象不会自动初始化，因此它们可能具有不确定的值。"
	},
	{
		"category": "",
		"mapping": "",
		"gjb5369": "",
		"gjb8114": "",
		"language": "c",
		"code": "MSR_18_2",
		"master_id": "2078",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nvoid func(){\n    int arr[3] = {0, 1, 2};\n\n    // Points to two beyond\n    int *p1 = &arr[0];\n    int *p2 = &arr[2];\n\n    ptrdiff_t diff;\n    diff = p1 - p2 // undefined\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}，指针减法导致了数组越界访问",
		"name": "指针之间的减法应仅适用于寻址同一数组元素的指针",
		"desc": "指针减法不应导致访问冲突，例如数组越界。",
		"details": "#### 概要\n指针减法不应导致访问冲突，例如数组越界。\n\n#### 解释\n如果指针不指向同一数组的元素或超出该数组末尾的元素，则它们之间的减法是未定义的行为。"
	},
	{
		"category": "",
		"mapping": "",
		"gjb5369": "",
		"gjb8114": "",
		"language": "c",
		"code": "MSR_18_6",
		"master_id": "2079",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}，具有自动存储的对象的地址被复制到第一个对象不存在后仍然存在的另一个对象",
		"name": "具有自动存储的对象的地址不应复制到第一个对象不存在后仍然存在的另一个对象",
		"desc": "具有自动存储的对象的地址不应复制到第一个对象不存在后仍然存在的另一个对象",
		"details": "#### 概要\n具有自动存储的对象的地址不应复制到第一个对象不存在后仍然存在的另一个对象\n\n#### 解释\n当一个对象的生命周期到期时，其地址变得不确定。因此使用该中间终止地址将导致未定义的行为。"
	},
	{
		"category": "",
		"mapping": "",
		"gjb5369": "",
		"gjb8114": "",
		"language": "c",
		"code": "MSR_22_1",
		"master_id": "2080",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}，通过标准库函数动态获取的资源没有被释放",
		"name": "所有通过标准库函数动态获取的资源都应该被释放",
		"desc": "应释放从标准库函数动态获取的资源。",
		"details": "#### 概要\n应释放从标准库函数动态获取的资源。\n\n#### 解释\n如果没有明确释放这些资源，则可能由于资源耗尽而发生故障。 尽快释放资源可以减少耗尽的可能性。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_22_2",
		"master_id": "2081",
		"compliance": "M",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}，不是由标准库函数分配的内存块被释放",
		"name": "内存块仅当由标准库函数分配时才可以被释放",
		"desc": "内存块仅当由标准库函数分配时才可以被释放",
		"details": "#### 概要\n内存块仅当由标准库函数分配时才可以被释放\n\n#### 解释\n释放未分配的内存或多次释放相同的分配内存是未定义的行为。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_22_4",
		"master_id": "2082",
		"compliance": "M",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}，以只读方式打开的流被写入。",
		"name": "不应尝试写入已以只读方式打开的流",
		"desc": "不应写入以只读方式打开的流。",
		"details": "#### 概要\n不应写入以只读方式打开的流。\n\n#### 解释\n由于标准没有指定尝试写入只读流时的行为，因此写入只读流是不安全的。"
	}
]